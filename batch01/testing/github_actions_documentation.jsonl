{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from CircleCI with GitHub Actions Importer?\n\nAssistant: Learn how to use GitHub Actions Importer to automate the migration of your CircleCI pipelines to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About migrating from CircleCI with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate CircleCI pipelines to GitHub Actions.\n\n## Prerequisites\n- A CircleCI account or organization with projects and pipelines that you want to convert to GitHub Actions workflows.\n- Access to create a CircleCI personal API token for your account or organization.\n- An environment where you can run Linux-based containers, and can install the necessary tools.\n\n  - Docker is [installed](https://docs.docker.com/get-docker/) and running.\n\n  - [GitHub CLI](https://cli.github.com/) is installed.\n\nNote\n\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n\n## Limitations\nThere are some limitations when migrating from CircleCI to GitHub Actions with GitHub Actions Importer:\n\n- Automatic caching in between jobs of different workflows is not supported.\n- The `audit` command is only supported when you use a CircleCI organization account. The `dry-run` and `migrate` commands can be used with a CircleCI organization or user account.\n\n## Manual tasks\nCertain CircleCI constructs must be migrated manually. These include:\n\n- Contexts\n- Project-level environment variables\n- Unknown job properties\n- Unknown orbs\n\n## Installing the GitHub Actions Importer CLI extension\n1. Install the GitHub Actions Importer CLI extension:\n\n```hljs bash\ngh extension install github/gh-actions-importer\n```\n\n2. Verify that the extension is installed:\n\n```hljs bash\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Configuring credentials\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with CircleCI and GitHub.\n\n1. Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n\nYour token must have the `workflow` scope.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n2. Create a CircleCI personal API token. For more information, see [Managing API Tokens](https://circleci.com/docs/managing-api-tokens/#creating-a-personal-api-token) in the CircleCI documentation.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n3. In your terminal, run the GitHub Actions Importer `configure` CLI command:\n\n```hljs shell\ngh actions-importer configure\n```\n\nThe `configure` command will prompt you for the following information:\n\n   - For \"Which CI providers are you configuring?\", use the arrow keys to select `CircleCI`, press `Space` to select it, then press `Enter`.\n   - For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press `Enter`.\n   - For \"Base url of the GitHub instance\", press `Enter` to accept the default value ( `https://github.com`).\n   - For \"Personal access token for CircleCI\", enter the value for the CircleCI personal API token that you created earlier, and press `Enter`.\n   - For \"Base url of the CircleCI instance\", press `Enter` to accept the default value ( `https://circleci.com`).\n   - For \"CircleCI organization name\", enter the name for your CircleCI organization, and press `Enter`.\n\nAn example of the `configure` command is shown below:\n\n```hljs shell\n$ gh actions-importer configure\n✔ Which CI providers are you configuring?: CircleCI\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for CircleCI: ********************\n✔ Base url of the CircleCI instance: https://circleci.com\n✔ CircleCI organization name: mycircleciorganization\nEnvironment variables successfully updated.\n```\n\n## Perform an audit of CircleCI\nYou can use the `audit` command to get a high-level view of all projects in a CircleCI organization.\n\nThe `audit` command performs the following steps:\n\n1. Fetches all of the projects defined in a CircleCI organization.\n2. Converts each pipeline to its equivalent GitHub Actions workflow.\n3. Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n## Running the audit command\nTo perform an audit of a CircleCI organization, run the following command in your terminal:\n\n```hljs shell\ngh actions-importer audit circle-ci --output-dir tmp/audit\n```\n\n## Inspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\n## Pipelines\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Pipelines\" section:\n\n- **Successful** pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\n- **Partially successful** pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\n- **Unsupported** pipelines are definition types that are not supported by GitHub Actions Importer.\n- **Failed** pipelines encountered a fatal error when being converted. This can occur for one of three reasons:\n\n  - The pipeline was originally misconfigured and not valid.\n  - GitHub Actions Importer encountered an internal error when converting it.\n  - There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\n\n## Build steps\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Build steps\" section:\n\n- A **known** build step is a step that was automatically converted to an equivalent action.\n- An **unknown** build step is a step that was not automatically converted to an equivalent action.\n- An **unsupported** build step is a step that is either:\n  - Fundamentally not supported by GitHub Actions.\n  - Configured in a way that is incompatible with GitHub Actions.\n- An **action** is a list of the actions that were used in the converted workflows. This can be important for:\n  - If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\n  - Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\n\n## Manual tasks\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\n\nListed below are some key terms that can appear in the \"Manual tasks\" section:\n\n- A **secret** is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n- A **self-hosted runner** refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\n\n## Files\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\n\nEach pipeline file has a variety of files included in the audit, including:\n\n- The original pipeline as it was defined in GitHub.\n- Any network responses used to convert the pipeline.\n- The converted workflow file.\n- Stack traces that can be used to troubleshoot a failed pipeline conversion.\n\nAdditionally, the `workflow_usage.csv` file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\n\n## Forecast potential GitHub Actions usage\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in CircleCI.\n\n## Running the forecast command\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```hljs shell\ngh actions-importer forecast circle-ci --output-dir tmp/forecast_reports\n```\n\n## Inspecting the forecast report\nThe `forecast_report.md` file in the specified output directory contains the results of the forecast.\n\nListed below are some key terms that can appear in the forecast report:\n\n- The **job count** is the total number of completed jobs.\n- The **pipeline count** is the number of unique pipelines used.\n- **Execution time** describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.\n- **Queue time** metrics describe the amount of time a job spent waiting for a runner to be available to execute it.\n- **Concurrent jobs** metrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure.\n\n## Perform a dry-run migration of a CircleCI pipeline\nYou can use the `dry-run` command to convert a CircleCI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\n## Running the dry-run command\nTo perform a dry run of migrating your CircleCI project to GitHub Actions, run the following command in your terminal, replacing `my-circle-ci-project` with the name of your CircleCI project.\n\n```hljs shell\ngh actions-importer dry-run circle-ci --output-dir tmp/dry-run --circle-ci-project my-circle-ci-project\n```\n\n## Perform a production migration of a CircleCI pipeline\nYou can use the `migrate` command to convert a CircleCI pipeline and open a pull request with the equivalent GitHub Actions workflow.\n\n## Running the migrate command\nTo migrate a CircleCI pipeline to GitHub Actions, run the following command in your terminal, replacing the `target-url` value with the URL for your GitHub repository, and `my-circle-ci-project` with the name of your CircleCI project.\n\n```hljs shell\ngh actions-importer migrate circle-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --circle-ci-project my-circle-ci-project\n```\n\n## Inspecting the pull request\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\nSome important elements of the pull request include:\n\n- In the pull request description, a section called **Manual steps**, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\n- The converted workflows file. Select the **Files changed** tab in the pull request to view the workflow file that will be added to your GitHub repository.\n\n## Reference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from CircleCI.\n\n## Using environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command. For more information, see the [Configuring credentials](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-circleci-with-github-actions-importer#configuring-credentials) section.\n\n## Optional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n## --source-file-path\nYou can use the `--source-file-path` argument with the `forecast`, `dry-run`, or `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--source-file-path` argument tells GitHub Actions Importer to use the specified source file path instead.\n\n## --config-file-path\nYou can use the `--config-file-path` argument with the `audit`, `dry-run`, and `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--config-file-path` argument tells GitHub Actions Importer to use the specified source files instead.\n\n## Audit example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\n\n```hljs bash\ngh actions-importer audit circle-ci --output-dir ./output/ --config-file-path ./path/to/circle-ci/config.yml\n```\n\n## Dry run example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run.\n\n## Specify the repository of converted composite actions\nGitHub Actions Importer uses the YAML file provided to the `--config-file-path` argument to determine the repository that converted composite actions are migrated to.\n\n## --include-from\nYou can use the `--include-from` argument with the `audit` subcommand.\n\n## Supported syntax for CircleCI pipelines\nThe following table shows the type of properties that GitHub Actions Importer is currently able to convert.\n\n## Environment variable mapping\nGitHub Actions Importer uses the mapping in the table below to convert default CircleCI environment variables to the closest equivalent in GitHub Actions.\n\n## Legal notice\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\naUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from CircleCI with GitHub Actions Importer?\n\nAssistant: Here are some code examples:\n\n### Installing the GitHub Actions Importer CLI extension\n```yaml\ngh extension install github/gh-actions-importer\n```\n\n### Verifying the extension is installed\n```yaml\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n### Configuring credentials\n```yaml\ngh actions-importer configure\n```\n\n### Running the audit command\n```yaml\ngh actions-importer audit circle-ci --output-dir tmp/audit\n```\n\n### Running the forecast command\n```yaml\ngh actions-importer forecast circle-ci --output-dir tmp/forecast_reports\n```\n\n### Performing a dry run migration of a CircleCI pipeline\n```yaml\ngh actions-importer dry-run circle-ci --output-dir tmp/dry-run --circle-ci-project my-circle-ci-project\n```\n\n### Performing a production migration of a CircleCI pipeline\n```yaml\ngh actions-importer migrate circle-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --circle-ci-project my-circle-ci-project\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from CircleCI with GitHub Actions Importer?\n\nAssistant: Here are the recommended best practices:\n\n• The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n• Ensure that your GitHub personal access token has the `workflow` scope for proper functionality.\n• Manually create any secrets used in your workflows after migration for them to function properly.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using an API gateway with OIDC?\n\nAssistant: You can use OpenID Connect (OIDC) tokens to authenticate your workflow.\n\nHere's a detailed explanation:\n\n\n## Using an API gateway with OIDC\nWith GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For example, you could run an API gateway on the edge of your private network that authenticates incoming requests with the OIDC token and then makes API requests on behalf of your workflow in your private network.\n\nThe following diagram gives an overview of this solution's architecture:\n\n![Diagram of an OIDC gateway architecture, starting with a GitHub Actions runner and ending with a private network's private service.](https://docs.github.com/assets/cb-22109/images/help/actions/actions-oidc-gateway.png)\n\nIt's important that you verify not just that the OIDC token came from GitHub Actions, but that it came specifically from your expected workflows, so that other GitHub Actions users aren't able to access services in your private network. You can use OIDC claims to create these conditions. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#defining-trust-conditions-on-cloud-roles-using-oidc-claims).\n\nThe main disadvantages of this approach are that you must implement the API gateway to make requests on your behalf, and you must run the gateway on the edge of your network.\n\nThe following advantages apply.\n\n- You don't need to configure any firewalls, or modify the routing of your private network.\n- The API gateway is stateless and scales horizontally to handle high availability and high throughput.\n\nFor more information, see [a reference implementation of an API Gateway](https://github.com/github/actions-oidc-gateway-example) in the github/actions-oidc-gateway repository. This implementation requires customization for your use case and is not ready-to-run as-is). For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using an API gateway with OIDC?\n\nAssistant: Here are the recommended best practices:\n\n• Verify that the OIDC token came specifically from your expected workflows to prevent unauthorized access.\n• Use OIDC claims to create conditions for trust.\n• Consider the implementation and operational requirements of running an API gateway.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using self-hosted runners in a workflow?\n\nAssistant: To use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can target self-hosted runners for use in a workflow based on the labels assigned to the runners, or their group membership, or a combination of these.\n\nImportant\n\nRunner Scale Sets do not support multiple labels, only the name of the runner can be used in place of a label. See [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n\n## About self-hosted runner labels\nLabels allow you to send workflow jobs to specific types of self-hosted runners, based on their shared characteristics. For example, if your job requires a particular hardware component or software package, you can assign a custom label to a runner and then configure your job to only execute on runners with that label.\n\nTo specify a self-hosted runner for your job, configure `runs-on` in your workflow file with self-hosted runner labels.\n\nSelf-hosted runners may have the `self-hosted` label. When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\n\nNote that Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.\n\nFor information on creating custom and default labels, see [Using labels with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-labels-with-self-hosted-runners).\n\n## About self-hosted runner groups\nFor self-hosted runners defined at the organization level, you can group your runners with shared characteristics into a single runner group and then configure your job to target the runner group.\n\nTo specify a self-hosted runner group for your job, configure `runs-on.group` in your workflow file.\n\nFor information on creating and managing runner groups, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\n## Viewing available runners for a repository\nIf you have `repo: write` access to a repository, you can view a list of the runners available to the repository.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. In the left sidebar, under the \"Management\" section, click **Runners**.\n4. Click the **Self hosted** tab at the top of the list of runners.\n5. Review the list of available self-hosted runners for the repository. This list includes both self-hosted runners and runner scale sets created with Actions Runner Controller. For more information, see [About Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller).\n6. Optionally, to copy a runner's label to use it in a workflow, click  to the right of the runner, then click **Copy label**.\n\nNote\n\nEnterprise and organization owners can create runners from this page. To create a new runner, click **New runner** at the top right of the list of runners to add runners to the repository.\n\nFor more information, see [Managing larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/managing-larger-runners) and [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n\n## Using default labels to route jobs\nA self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform:\n\n- `self-hosted`: Default label applied to self-hosted runners.\n- `linux`, `windows`, or `macOS`: Applied depending on operating system.\n- `x64`, `ARM`, or `ARM64`: Applied depending on hardware architecture.\n\nYou can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:\n\n```hljs yaml\nruns-on: [self-hosted, linux, ARM64]\n```\n\n- `self-hosted` \\- Run this job on a self-hosted runner.\n- `linux` \\- Only use a Linux-based runner.\n- `ARM64` \\- Only use a runner based on ARM64 hardware.\n\nTo create individual self-hosted runners without the default labels, pass the `--no-default-labels` flag when you create the runner. Actions Runner Controller does not support multiple labels.\n\n## Using custom labels to route jobs\nYou can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled.\n\nFor example, if you have a job that requires a specific type of graphics hardware, you can create a custom label called `gpu` and assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job.\n\nThis example shows a job that combines default and custom labels:\n\n```hljs yaml\nruns-on: [self-hosted, linux, x64, gpu]\n```\n\n- `self-hosted` \\- Run this job on a self-hosted runner.\n- `linux` \\- Only use a Linux-based runner.\n- `x64` \\- Only use a runner based on x64 hardware.\n- `gpu` \\- This custom label has been manually assigned to self-hosted runners with the GPU hardware installed.\n\nThese labels operate cumulatively, so a self-hosted runner must have all four labels to be eligible to process the job.\n\n## Using groups to route jobs\nIn this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:\n\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## Using labels and groups to route jobs\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:\n\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## Routing precedence for self-hosted runners\nWhen routing a job to a self-hosted runner, GitHub looks for a runner that matches the job's `runs-on` labels and groups:\n\n- If GitHub finds an online and idle runner that matches the job's `runs-on` labels and groups, the job is then assigned and sent to the runner.\n\n  - If the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.\n- If GitHub doesn't find an online and idle runner that matches the job's `runs-on` labels and groups, then the job will remain queued until a runner comes online.\n- If the job remains queued for more than 24 hours, the job will fail.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using self-hosted runners in a workflow?\n\nAssistant: Here are some code examples:\n\n### Using default labels to route jobs\n```yaml\n```hljs yaml\nruns-on: [self-hosted, linux, ARM64]\n```\n```\n\n### Using custom labels to route jobs\n```yaml\n```hljs yaml\nruns-on: [self-hosted, linux, x64, gpu]\n```\n```\n\n### Using groups to route jobs\n```yaml\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n### Using labels and groups to route jobs\n```yaml\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using self-hosted runners in a workflow?\n\nAssistant: Here are the recommended best practices:\n\n• Runner Scale Sets do not support multiple labels, only the name of the runner can be used in place of a label.\n• When specifying an array of labels, jobs will be queued on runners that have all the labels that you specify.\n• Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.\n• To create individual self-hosted runners without the default labels, pass the `--no-default-labels` flag when you create the runner.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Java with Gradle?\n\nAssistant: You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Gradle build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Gradle. For a list of software and the pre-installed versions for JDK and Gradle, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n- [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Gradle framework. For more information, see the [Gradle User Manual](https://docs.gradle.org/current/userguide/userguide.html).\n\n## Using a Gradle workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n01. On GitHub, navigate to the main page of the repository.\n\n02. Under your repository name, click **Actions**.\n\n03. If you already have a workflow in your repository, click **New workflow**.\n\n04. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Gradle\".\n\n05. On the \"Java with Gradle\" workflow, click **Configure**.\n    This workflow performs the following steps:\n\n06. Checks out a copy of project's repository.\n\n07. Sets up the Java JDK.\n\n08. Sets up the Gradle environment. The [`gradle/actions/setup-gradle`](https://github.com/gradle/actions) action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.\n\n09. The \"Build with Gradle\" step executes the `build` task using the [Gradle Wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html).\n\n10. Edit the workflow as required. For example, change the Java version.\n\nNote\n\n- This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\n- If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions).\n\n11. Click **Commit changes**.\n\n    The `gradle.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying the Java version and architecture\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( `x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the `build` task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to use a different task, you can specify those.\n\n## Caching dependencies\nYour build dependencies can be cached to speed up your workflow runs. After a successful run, `gradle/actions/setup-gradle` caches important parts of the Gradle user home directory. In future jobs, the cache will be restored so that build scripts won't need to be recompiled and dependencies won't need to be downloaded from remote package repositories.\n\nCaching is enabled by default when using the `gradle/actions/setup-gradle` action.\n\n## Packaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Java with Gradle?\n\nAssistant: Here are some code examples:\n\n### Specifying the Java version and architecture\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n\n```\n\n### Building and testing your code\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew -b ci.gradle package\n\n```\n\n### Packaging workflow data as artifacts\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew build\n\n  - name: Upload build artifacts\n    uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/libs\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Java with Gradle?\n\nAssistant: Here are the recommended best practices:\n\n• Use a version specified by a commit SHA for third-party actions to ensure stability.\n• Update the SHA if you want to use a newer version of a third-party action.\n• Refer to the security hardening guidelines when using third-party actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying?\n\nAssistant: Automatically deploy projects with GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Deploying with GitHub Actions\nLearn how to control deployments with features like environments and concurrency.\n\n## Deploying Node.js to Azure App Service\nYou can deploy your Node.js project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying Python to Azure App Service\nYou can deploy your Python project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying Java to Azure App Service\nYou can deploy your Java project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying .NET to Azure App Service\nYou can deploy your .NET project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying PHP to Azure App Service\nYou can deploy your PHP project to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying Docker to Azure App Service\nYou can deploy a Docker container to Azure App Service as part of your continuous deployment (CD) workflows.\n\n## Deploying to Azure Static Web App\nYou can deploy your web app to Azure Static Web App as part of your continuous deployment (CD) workflows.\n\n## Deploying to Azure Kubernetes Service\nYou can deploy your project to Azure Kubernetes Service (AKS) as part of your continuous deployment (CD) workflows.\n\n## Deploying to Amazon Elastic Container Service\nYou can deploy to Amazon Elastic Container Service (ECS) as part of your continuous deployment (CD) workflows.\n\n## Deploying to Google Kubernetes Engine\nYou can deploy to Google Kubernetes Engine as part of your continuous deployment (CD) workflows.\n\n## Installing an Apple certificate on macOS runners for Xcode development\nYou can sign Xcode apps within your continuous integration (CI) workflow by installing an Apple code signing certificate on GitHub Actions runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Swift?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your Swift project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to build and test a Swift package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, and the Ubuntu and macOS runners include the dependencies for building Swift packages. For a full list of up-to-date software and the preinstalled versions of Swift and Xcode, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of Swift packages. For more information, see [Swift Packages](https://developer.apple.com/documentation/xcode/swift-packages) in the Apple developer documentation.\n\n## Using a Swift workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Swift that should work for most Swift projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. If you already have a workflow in your repository, click **New workflow**.\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"swift\".\n5. Filter the selection of workflows by clicking **Continuous integration**.\n6. On the \"Swift\" workflow, click **Configure**.\n7. Edit the workflow as required. For example, change the branch on which the workflow will run.\n8. Click **Commit changes**.\n\nThe `swift.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying a Swift version\nTo use a specific preinstalled version of Swift on a GitHub-hosted runner, use the `swift-actions/setup-swift` action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to `PATH`. These changes will persist for the remainder of a job. For more information, see the [`swift-actions/setup-swift`](https://github.com/marketplace/actions/setup-swift) action.\n\nIf you are using a self-hosted runner, you must install your desired Swift versions and add them to `PATH`.\n\n## Using multiple Swift versions\nYou can configure your job to use multiple versions of Swift in a matrix.\n\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Swift\n\non: [push]\n\njobs:\n  build:\n    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n        swift: [\"5.2\", \"5.3\"]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n        with:\n          swift-version: ${{ matrix.swift }}\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n```\n\n## Using a single specific Swift version\nYou can configure your job to use a single specific version of Swift, such as `5.3.3`.\n\n```hljs yaml\nsteps:\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Get swift version\n    run: swift --version # Swift 5.3.3\n```\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to use `swift build` and `swift test` in a job:\n\n```hljs yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Build\n    run: swift build\n  - name: Run tests\n    run: swift test\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Swift?\n\nAssistant: Here are some code examples:\n\n### Using multiple Swift versions\n```yaml\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Swift\n\non: [push]\n\njobs:\n  build:\n    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n        swift: [\"5.2\", \"5.3\"]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n        with:\n          swift-version: ${{ matrix.swift }}\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n```\n```\n\n### Using a single specific Swift version\n```yaml\n```hljs yaml\nsteps:\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Get swift version\n    run: swift --version # Swift 5.3.3\n```\n```\n\n### Building and testing your code\n```yaml\n```hljs yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Build\n    run: swift build\n  - name: Run tests\n    run: swift test\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Swift?\n\nAssistant: Here are the recommended best practices:\n\n• GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Writing workflows?\n\nAssistant: GitHub Actions workflows can automate tasks throughout the software development lifecycle.\n\nHere's a detailed explanation:\n\n\n## Quickstart for GitHub Actions\n[Quickstart for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/quickstart)\n\n## About workflows\n[About workflows](https://docs.github.com/en/actions/writing-workflows/about-workflows)\n\n## Using workflow templates\n[Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-workflow-templates)\n\n## Choosing when your workflow runs\n[Choosing when your workflow runs](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs) \n\n- [Triggering a workflow](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow)  \n- [Using conditions to control job execution](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/using-conditions-to-control-job-execution)  \n- [Events that trigger workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows)\n\n## Choosing where your workflow runs\n[Choosing where your workflow runs](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs)  \n\n- [Choosing the runner for a job](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job)  \n- [Running jobs in a container](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container)\n\n## Choosing what your workflow does\n[Choosing what your workflow does](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does)  \n\n- [Using jobs in a workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow)  \n- [Using pre-written building blocks in your workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow)  \n- [Using GitHub CLI in workflows](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-github-cli-in-workflows)  \n- [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions)  \n- [Adding scripts to your workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow)  \n- [Controlling permissions for GITHUB_TOKEN](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token)  \n- [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions)  \n- [Store information in variables](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables)  \n- [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs)  \n- [Passing information between jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs)  \n- [Setting a default shell and working directory](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/setting-a-default-shell-and-working-directory)  \n- [Using environments for deployment](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-environments-for-deployment)  \n- [Control the concurrency of workflows and jobs](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs)  \n- [Running variations of jobs in a workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow)  \n- [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows)  \n- [Storing and sharing data from a workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow)\n\n## Workflow syntax for GitHub Actions\n[Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About support for Actions Runner Controller?\n\nAssistant: What to know before you contact GitHub Support for assistance with Actions Runner Controller.\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can contact GitHub Support for assistance with Actions Runner Controller.\n\n## About support for Actions Runner Controller Versions\nThe Actions Runner Controller (ARC) project was adopted by GitHub to release as a new GitHub product. As a result, there are currently two ARC releases: the legacy community-maintained ARC and GitHub's Autoscaling Runner Sets.\n\nGitHub only supports the latest Autoscaling Runner Sets version of ARC. Support for the legacy ARC is provided by the community in the Actions Runner Controller repository only.\n\n## Scope of support for Actions Runner Controller\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\n\n- The legacy community-maintained version of ARC\n- Installing, configuring, or maintaining dependencies\n- Template spec customization\n- Container orchestration, such as Kubernetes setup, networking, building images in ARC (DinD), etc.\n- Applying Kubernetes policies\n- Managed Kubernetes providers or provider-specific configurations\n- Runner Container Hooks in conjunction with ARC's `kubernetes` mode\n- Installation tooling other than Helm\n- Storage provisioners and PersistentVolumeClaims (PVCs)\n- Best practices, such as configuring metrics servers, image caching, etc.\n\nWhile ARC may be deployed successfully with different tooling and configurations, your support request is possibly out of GitHub Support's scope if ARC has been deployed with:\n\n- Installation tooling other than Helm\n- Service account and/or template spec customization\n\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.\n\nFor more information about contacting GitHub Support, see Contacting GitHub Support.\n\nNote\n\n- OpenShift clusters are currently unsupported.\n- ARC is only supported on GitHub Enterprise Server versions 3.9 and greater.\n\n## Working with GitHub Support for Actions Runner Controller\nGitHub Support may ask questions about your Actions Runner Controller deployment and request that you collect and attach the controller, listener, and runner logs to the support ticket.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About support for Actions Runner Controller?\n\nAssistant: Here are the recommended best practices:\n\n• Open a ticket if you're uncertain if the issue is out of scope.\n• Note that OpenShift clusters are currently unsupported.\n• ARC is only supported on GitHub Enterprise Server versions 3.9 and greater.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Approving workflow runs from private forks?\n\nAssistant: When someone without write access submits a pull request to a private repository, a maintainer may need to approve any workflow runs.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nMaintainers with write access to a repository can approve workflow runs.\n\n## About workflow runs from private forks\nIf you rely on using forks of your private repositories, you can configure policies that control how users can run workflows on `pull_request` events. Available to private repositories only, you can configure these policy settings for organizations or repositories. For more information, see [Enforcing policies for GitHub Actions in your enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-fork-pull-requests-in-private-repositories).\n\n## Approving workflow runs on a pull request from a private fork\nMaintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval.\n\n1. Under your repository name, click **Pull requests**.\n\n2. In the list of pull requests, click the pull request you'd like to review.\n\n3. On the pull request, click **Files changed**.\n\n4. Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the `.github/workflows/` directory that affect workflow files.\n\n5. If you are comfortable with running workflows on the pull request branch, return to the **Conversation** tab, and under \"Workflow(s) awaiting approval\", click **Approve and run**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Approving workflow runs from private forks?\n\nAssistant: Here are the recommended best practices:\n\n• Be especially alert to any proposed changes in the `.github/workflows/` directory that affect workflow files.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Customizing GitHub-hosted runners?\n\nAssistant: You can install additional software on GitHub-hosted runners as a part of your workflow.\n\nHere's a detailed explanation:\n\n\n## In this article\nIf you require additional software packages on GitHub-hosted runners, you can create a job that installs the packages as part of your workflow.\n\nTo see which packages are already installed by default, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#preinstalled-software).\n\nThis guide demonstrates how to create a job that installs additional software on a GitHub-hosted runner.\n\n## Installing software on Ubuntu runners\nThe following example demonstrates how to install an `apt` package as part of a job.\n\n```hljs yaml\nname: Build on Ubuntu\non: push\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install jq tool\n        run: |\n          sudo apt-get update\n          sudo apt-get install jq\n```\n\nNote\n\nAlways run `sudo apt-get update` before installing a package. In case the `apt` index is stale, this command fetches and re-indexes any available packages, which helps prevent package installation failures.\n\n## Installing software on macOS runners\nThe following example demonstrates how to install Brew packages and casks as part of a job.\n\n```hljs yaml\nname: Build on macOS\non: push\n\njobs:\n  build:\n    runs-on: macos-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install GitHub CLI\n        run: |\n          brew update\n          brew install gh\n      - name: Install Microsoft Edge\n        run: |\n          brew update\n          brew install --cask microsoft-edge\n```\n\n## Installing software on Windows runners\nThe following example demonstrates how to use [Chocolatey](https://community.chocolatey.org/packages) to install the GitHub CLI as part of a job.\n\n```hljs yaml\nname: Build on Windows\non: push\njobs:\n  build:\n    runs-on: windows-latest\n    steps:\n      - run: choco install gh\n      - run: gh version\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Customizing GitHub-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Installing software on Ubuntu runners\n```yaml\n```hljs yaml\nname: Build on Ubuntu\non: push\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install jq tool\n        run: |\n          sudo apt-get update\n          sudo apt-get install jq\n```\n```\n\n### Installing software on macOS runners\n```yaml\n```hljs yaml\nname: Build on macOS\non: push\n\njobs:\n  build:\n    runs-on: macos-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install GitHub CLI\n        run: |\n          brew update\n          brew install gh\n      - name: Install Microsoft Edge\n        run: |\n          brew update\n          brew install --cask microsoft-edge\n```\n```\n\n### Installing software on Windows runners\n```yaml\n```hljs yaml\nname: Build on Windows\non: push\njobs:\n  build:\n    runs-on: windows-latest\n    steps:\n      - run: choco install gh\n      - run: gh version\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Customizing GitHub-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• Always run `sudo apt-get update` before installing a package to prevent installation failures.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Publishing actions in GitHub Marketplace?\n\nAssistant: You can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.\n\nHere's a detailed explanation:\n\n\n## About publishing actions\nBefore you can publish an action, you'll need to create an action in your repository. For more information, see Sharing automations.\n\nWhen you plan to publish your action to GitHub Marketplace, you'll need to ensure that the repository only includes the metadata file, code, and files necessary for the action. Creating a single repository for the action allows you to tag, release, and package the code in a single unit. GitHub also uses the action's metadata on your GitHub Marketplace page.\n\nActions are published to GitHub Marketplace immediately and aren't reviewed by GitHub as long as they meet these requirements:\n\n- The action must be in a public repository.\n- Each repository must contain a single action metadata file ( action.yml or action.yaml) at the root.\n\n  - Repositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.\n- Each repository must not contain any workflow files.\n- The name in the action's metadata file must be unique.\n\n  - The name cannot match an existing action name published on GitHub Marketplace.\n  - The name cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action named github.\n  - The name cannot match an existing GitHub Marketplace category.\n  - GitHub reserves the names of GitHub features.\n\n## Publishing an action\nYou can add the action you've created to GitHub Marketplace by tagging it as a new release and publishing it.\n\nTo draft a new release and publish the action to GitHub Marketplace, follow these instructions:\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Navigate to the action metadata file in your repository ( action.yml), and you'll see a banner to publish the action to GitHub Marketplace. Click Draft a release.\n\n3. Under \"Release Action\", select Publish this Action to the GitHub Marketplace.\n\n\nNote\n\n\nThe \"Publish\" checkbox is disabled if the account that owns the repository has not yet accepted the GitHub Marketplace Developer Agreement. If you own the repository or are an organization owner, click the link to \"accept the GitHub Marketplace Developer Agreement\", then accept the agreement. If there is no link, send the organization owner a link to this \"Release Action\" page and ask them to accept the agreement.\n\n4. If the labels in your metadata file contain any problems, you will see an error message or a warning message. Address them by updating your metadata file. Once complete, you will see an \"Everything looks good!\" message.\n\n5. Select the Primary Category dropdown menu and click a category that will help people find your action in GitHub Marketplace.\n\n6. Optionally, select the Another Category dropdown menu and click a secondary category.\n\n7. In the tag field, type a version for your action. This helps people know what changes or features the release includes. People will see the version in the action's dedicated GitHub Marketplace page.\n\n8. In the title field, type a release title.\n\n9. Complete all other fields and click Publish release. Publishing requires you to use two-factor authentication. For more information, see Configuring two-factor authentication.\n\n## Removing an action from GitHub Marketplace\nTo remove a published action from GitHub Marketplace, you'll need to update each published release. Perform the following steps for each release of the action you've published to GitHub Marketplace.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. To the right of the list of files, click Releases.\n\n3. Next to the release you want to edit, click .\n\n4. Select Publish this action to the GitHub Marketplace to remove the check from the box.\n\n5. Click Update release at the bottom of the page.\n\n## Transferring an action repository\nYou can transfer an action repository to another user or organization. For more information, see Transferring a repository.\n\nWhen a repository admin transfers an action repository, GitHub automatically creates a redirect from the previous URL to the new URL, meaning workflows that use the affected action do not need to be updated.\n\nActions published on GitHub Marketplace are linked to a repository by their unique name identifier, meaning you can publish new releases of an action from the transferred repository under the same GitHub Marketplace listing. If an action repository is deleted, the GitHub Marketplace listing is also deleted, and the unique name identifier becomes available.\n\n## About badges in GitHub Marketplace\nActions with the , or verified creator badge, indicate that GitHub has verified the creator of the action as a partner organization. Partners can email partnerships@github.com to request the verified creator badge.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Publishing actions in GitHub Marketplace?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure the action is in a public repository.\n• Include only the necessary metadata file and code in the repository.\n• Use a unique name for the action in the metadata file.\n• Accept the GitHub Marketplace Developer Agreement before publishing.\n• Address any issues in the metadata file before publishing.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using pre-written building blocks in your workflow?\n\nAssistant: Actions are the building blocks that power your workflow. A workflow can contain actions created by the community, or you can create your own actions directly within your application's repository. This guide will show you how to discover, use, and customize actions.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can use pre-written building blocks, called actions, in your workflow. An action is a pre-defined, reusable set of jobs or code that perform specific tasks within a workflow.\n\nActions can be:\n\n- **Reusable:** actions can be used across different workflows and repositories, allowing you to avoid rewriting the same code.\n- **Pre-written:** many actions are available in the GitHub Marketplace, covering a wide range of tasks like checking out code, setting up environments, running tests, and deploying applications.\n- **Configurable:** you can configure actions with inputs, outputs, and environment variables to tailor them to your specific needs.\n- **Community-driven:** you can create your own actions and share them with others or use actions developed by the community.\n\nThe actions you use in your workflow can be defined in:\n\n- The same repository as your workflow file\n- Any public repository\n- A published Docker container image on Docker Hub\n\nGitHub Marketplace is a central location for you to find actions created by the GitHub community. [GitHub Marketplace page](https://github.com/marketplace/actions/) enables you to filter for actions by category.\n\n## Browsing Marketplace actions in the workflow editor\nYou can search and browse actions directly in your repository's workflow editor. From the sidebar, you can search for a specific action, view featured actions, and browse featured categories. You can also view the number of stars an action has received from the GitHub community.\n\n1. In your repository, browse to the workflow file you want to edit.\n2. In the upper right corner of the file view, to open the workflow editor, click .\n\n![Screenshot of a workflow file showing the header section. The pencil icon for editing files is highlighted with a dark orange outline.](https://docs.github.com/assets/cb-26543/images/help/repository/actions-edit-workflow-file.png)\n\n3. To the right of the editor, use the GitHub Marketplace sidebar to browse actions. Actions with the  badge indicate GitHub has verified the creator of the action as a partner organization.\n\n![Screenshot of a workflow in the file editor. The sidebar shows Marketplace actions. A \"Creator verified by GitHub\" badge is outlined in orange.](https://docs.github.com/assets/cb-93797/images/help/repository/actions-marketplace-sidebar.png)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using pre-written building blocks in your workflow?\n\nAssistant: Here are some code examples:\n\n### Adding an action from the same repository\n```yaml\nExample repository file structure:\n\n```hljs shell\n|-- hello-world (repository)\n|   |__ .github\n|       └── workflows\n|           └── my-first-workflow.yml\n|       └── actions\n|           |__ hello-world-action\n|               └── action.yml\n```\n\nExample workflow file:\n\n```hljs yaml\njobs:\n  my_first_job:\n    runs-on: ubuntu-latest\n    steps:\n      # This step checks out a copy of your repository.\n      - name: My first step - check out repository\n        uses: actions/checkout@v4\n      # This step references the directory that contains the action.\n      - name: Use local hello-world-action\n        uses: ./.github/actions/hello-world-action\n```\n```\n\n### Adding an action from a different repository\n```yaml\nIf an action is defined in a different repository than your workflow file, you can reference the action with the `{owner}/{repo}@{ref}` syntax in your workflow file.\n\nThe action must be stored in a public repository.\n\n```hljs yaml\njobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: actions/setup-node@v4\n```\n```\n\n### Referencing a container on Docker Hub\n```yaml\nIf an action is defined in a published Docker container image on Docker Hub, you must reference the action with the `docker://{image}:{tag}` syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow.\n\n```hljs yaml\njobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: docker://alpine:3.8\n```\n```\n\n### Using inputs and outputs with an action\n```yaml\nAn action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing.\n\nTo see the inputs and outputs of an action, check the `action.yml` in the root directory of the repository.\n\nIn this example `action.yml`, the `inputs` keyword defines a required input called `file-path`, and includes a default value that will be used if none is specified. The `outputs` keyword defines an output called `results-file`, which tells you where to locate the results.\n\n```hljs yaml\nname: \"Example\"\ndescription: \"Receives file and generates output\"\ninputs:\n  file-path: # id of input\n    description: \"Path to test script\"\n    required: true\n    default: \"test-file.js\"\noutputs:\n  results-file: # id of output\n    description: \"Path to results file\"\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using pre-written building blocks in your workflow?\n\nAssistant: Here are the recommended best practices:\n\n• To enhance security, GitHub Actions does not support redirects for actions or reusable workflows.\n• We recommend that you use a SHA value when using third-party actions.\n• Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer.\n• If you need more reliable versioning, you should use the SHA value associated with the version of the action.\n• Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating PostgreSQL service containers?\n\nAssistant: You can create a PostgreSQL service container to use in your workflow. This guide shows examples of creating a PostgreSQL service for jobs that run in containers or directly on the runner machine.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you workflow examples that configure a service container using the Docker Hub `postgres` image. The workflow runs a script that connects to the PostgreSQL service, creates a table, and then populates it with data. To test that the workflow creates and populates the PostgreSQL table, the script prints the data from the table to the console.\n\nNote\n\nIf your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:\n\n- If you are using GitHub-hosted runners, you must use an Ubuntu runner.\n- If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.\n\n## Prerequisites\nYou should be familiar with how service containers work with GitHub Actions and the networking differences between running jobs directly on the runner or in a container. For more information, see [About service containers](https://docs.github.com/en/actions/using-containerized-services/about-service-containers).\n\nYou may also find it helpful to have a basic understanding of YAML, the syntax for GitHub Actions, and PostgreSQL. For more information, see:\n\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n- [PostgreSQL tutorial](https://www.postgresqltutorial.com/) in the PostgreSQL documentation.\n\n## Running jobs in containers\nConfiguring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow.\n\nYou can copy this workflow file to the `.github/workflows` directory of your repository and modify it as needed.\n\n## Configuring the runner job for jobs in containers\nThis workflow configures a job that runs in the `node:20-bookworm-slim` container and uses the `ubuntu-latest` GitHub-hosted runner as the Docker host for the container. For more information about the `node:20-bookworm-slim` container, see the [node image](https://hub.docker.com/_/node) on Docker Hub.\n\nThe workflow configures a service container with the label `postgres`. All services must run in a container, so each service requires that you specify the container `image`. This example uses the `postgres` container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the [postgres image](https://hub.docker.com/_/postgres) on Docker Hub.\n\n## Configuring the steps for jobs in containers\nThe workflow performs the following steps:\n\n1. Checks out the repository on the runner\n2. Installs dependencies\n3. Runs a script to create a client\n\n## Running jobs directly on the runner machine\nWhen you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using `localhost` and the Docker host port number.\n\nYou can copy this workflow file to the `.github/workflows` directory of your repository and modify it as needed.\n\n## Configuring the runner job for jobs directly on the runner machine\nThe example uses the `ubuntu-latest` GitHub-hosted runner as the Docker host.\n\nThe workflow configures a service container with the label `postgres`. All services must run in a container, so each service requires that you specify the container `image`. This example uses the `postgres` container image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see the [postgres image](https://hub.docker.com/_/postgres) on Docker Hub.\n\nThe workflow maps port 5432 on the PostgreSQL service container to the Docker host. For more information about the `ports` keyword, see [About service containers](https://docs.github.com/en/actions/using-containerized-services/about-service-containers#mapping-docker-host-and-service-container-ports).\n\n## Configuring the steps for jobs directly on the runner machine\nThe workflow performs the following steps:\n\n1. Checks out the repository on the runner\n2. Installs dependencies\n3. Runs a script to create a client\n\n## Testing the PostgreSQL service container\nYou can test your workflow using the following script, which connects to the PostgreSQL service and adds a new table with some placeholder data. The script then prints the values stored in the PostgreSQL table to the terminal. Your script can use any language you'd like, but this example uses Node.js and the `pg` npm module. For more information, see the [npm pg module](https://www.npmjs.com/package/pg).\n\nYou can modify _client.js_ to include any PostgreSQL operations needed by your workflow. In this example, the script connects to the PostgreSQL service, adds a table to the `postgres` database, inserts some placeholder data, and then retrieves the data.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating PostgreSQL service containers?\n\nAssistant: Here are some code examples:\n\n### PostgreSQL service example\n```yaml\nname: PostgreSQL service example\non: push\n\njobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to PostgreSQL\n        # Runs a script that creates a PostgreSQL table, populates\n        # the table with data, and then retrieves the data.\n        run: node client.js\n        # Environment variables used by the `client.js` script to create a new PostgreSQL table.\n        env:\n          # The hostname used to communicate with the PostgreSQL service container\n          POSTGRES_HOST: postgres\n          # The default PostgreSQL port\n          POSTGRES_PORT: 5432\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating PostgreSQL service containers?\n\nAssistant: Here are the recommended best practices:\n\n• Use a Linux runner for workflows that utilize Docker container actions, job containers, or service containers.\n• Familiarize yourself with service containers and networking differences between running jobs directly on the runner or in a container.\n• Ensure Docker is installed on self-hosted runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About continuous integration with GitHub Actions?\n\nAssistant: You can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About continuous integration\nContinuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.\n\nWhen you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks.\n\nBuilding and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository.\n\n## About continuous integration using GitHub Actions\nCI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, see Using GitHub-hosted runners and About self-hosted runners.\n\nYou can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook.\n\nGitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure.\n\nWhen you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests.\n\nIn addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, see Writing workflows.\n\nFor a definition of common terms, see Understanding GitHub Actions.\n\n## Workflow templates\nGitHub offers CI workflow templates for a variety of languages and frameworks.\n\nBrowse the complete list of CI workflow templates offered by GitHub in the actions/starter-workflows repository.\n\n## Further reading\n- Building and testing\n- Managing billing for GitHub Actions\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Monitoring and troubleshooting self-hosted runners?\n\nAssistant: You can monitor your self-hosted runners to view their activity and diagnose common issues.\n\nHere's a detailed explanation:\n\n\n## Platform navigation\n\n\n## In this article\n\n\n## Using repository-level self-hosted runners\nYou may not be able to create a self-hosted runner for an organization-owned repository.\n\nOrganization owners can choose which repositories are allowed to create repository-level self-hosted runners.\n\nFor more information, see [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#limiting-the-use-of-self-hosted-runners).\n\n## Checking the status of a self-hosted runner\nA self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:\n\n- **User repository:** You must be the repository owner.\n- **Organization:** You must be an organization owner.\n- **Organization repository:** You must be an organization owner, or have admin access to the repository.\n\n1. In your organization or repository, navigate to the main page and click **Settings**.\n\n2. In the left sidebar, click **Actions**, then click **Runners**.\n\n3. Under \"Runners\", you can view a list of registered runners, including the runner's name, labels, and status.\n\nThe status can be one of the following:\n   - **Idle:** The runner is connected to GitHub and is ready to execute jobs.\n   - **Active:** The runner is currently executing a job.\n   - **Offline:** The runner is not connected to GitHub. This could be because the machine is offline, the self-hosted runner application is not running on the machine, or the self-hosted runner application cannot communicate with GitHub.\n\n## Troubleshooting network connectivity\n\n\n## Checking self-hosted runner network connectivity\nYou can use the self-hosted runner application's `config` script with the `--check` parameter to check that a self-hosted runner can access all required network services on GitHub.\n\nIn addition to `--check`, you must provide two arguments to the script:\n\n- `--url` with the URL to your GitHub repository, organization, or enterprise. For example, `--url https://github.com/octo-org/octo-repo`.\n- `--pat` with the value of a personal access token (classic), which must have the `workflow` scope, or a fine-grained personal access token with workflows read and write access. For example, `--pat ghp_abcd1234`. For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\n\nFor example:\n\n```hljs shell\n./config.sh --check --url URL --pat ghp_abcd1234\n```\n\n```hljs shell\n./config.sh --check --url URL --pat ghp_abcd1234\n```\n\n```hljs powershell\nconfig.cmd --check --url https://github.com/YOUR-ORG/YOUR-REPO --pat GHP_ABCD1234\n```\n\nThe script tests each service, and outputs either a `PASS` or `FAIL` for each one. If you have any failing checks, you can see more details on the problem in the log file for the check. The log files are located in the `_diag` directory where you installed the runner application, and the path of the log file for each check is shown in the console output of the script.\n\nIf you have any failing checks, you should also verify that your self-hosted runner machine meets all the communication requirements. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-requirements).\n\n## Disabling TLS certificate verification\nBy default, the self-hosted runner application verifies the TLS certificate for GitHub. If you encounter network problems, you may wish to disable TLS certificate verification for testing purposes.\n\nTo disable TLS certification verification in the self-hosted runner application, set the `GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY` environment variable to `1` before configuring and running the self-hosted runner application.\n\n```hljs shell\nexport GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1\n./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.sh\n```\n\n```hljs shell\nexport GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1\n./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.sh\n```\n\n```hljs powershell\n[Environment]::SetEnvironmentVariable('GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY', '1')\n./config.cmd --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.cmd\n```\n\nWarning\n\nDisabling TLS verification is not recommended since TLS provides privacy and data integrity between the self-hosted runner application and GitHub. We recommend that you install the GitHub certificate in the operating system certificate store for your self-hosted runner. For guidance on how to install the GitHub certificate, check with your operating system vendor.\n\n## Reviewing the self-hosted runner application log files\nYou can monitor the status of the self-hosted runner application and its activities. Log files are kept in the `_diag` directory where you installed the runner application, and a new log is generated each time the application is started. The filename begins with `Runner_`, and is followed by a UTC timestamp of when the application was started.\n\nWarning\n\nRunner application log files for ephemeral runners must be forwarded and preserved externally for troubleshooting and diagnostic purposes. For more information about ephemeral runners and autoscaling self-hosted runners, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners#using-ephemeral-runners-for-autoscaling).\n\n## Reviewing a job's log file\nThe self-hosted runner application creates a detailed log file for each job that it processes. These files are stored in the `_diag` directory where you installed the runner application, and the filename begins with `Worker_`.\n\n## Using journalctl to check the self-hosted runner application service\nFor Linux-based self-hosted runners running the application using a service, you can use `journalctl` to monitor their real-time activity. The default systemd-based service uses the following naming convention: `actions.runner.<org>-<repo>.<runnerName>.service`. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the _.service_ file. For example:\n\n```hljs shell\n$ cat ~/actions-runner/.service\nactions.runner.octo-org-octo-repo.runner01.service\n```\n\nIf this fails due to the service being installed elsewhere, you can find the service name in the list of running services. For example, on most Linux systems you can use the `systemctl` command:\n\n```hljs shell\n$ systemctl --type=service | grep actions.runner\nactions.runner.octo-org-octo-repo.hostname.service loaded active running GitHub Actions Runner (octo-org-octo-repo.hostname)\n```\n\nYou can use `journalctl` to monitor the real-time activity of the self-hosted runner:\n\n```hljs shell\nsudo journalctl -u actions.runner.octo-org-octo-repo.runner01.service -f\n```\n\nIn this example output, you can see `runner01` start, receive a job named `testAction`, and then display the resulting status:\n\n```hljs shell\nFeb 11 14:57:07 runner01 runsvc.sh[962]: Starting Runner listener with startup type: service\nFeb 11 14:57:07 runner01 runsvc.sh[962]: Started listener process\nFeb 11 14:57:07 runner01 runsvc.sh[962]: Started running service\nFeb 11 14:57:16 runner01 runsvc.sh[962]: √ Connected to GitHub\nFeb 11 14:57:17 runner01 runsvc.sh[962]: 2020-02-11 14:57:17Z: Listening for Jobs\nFeb 11 16:06:54 runner01 runsvc.sh[962]: 2020-02-11 16:06:54Z: Running job: testAction\nFeb 11 16:07:10 runner01 runsvc.sh[962]: 2020-02-11 16:07:10Z: Job testAction completed with result: Succeeded\n```\n\nTo view the `systemd` configuration, you can locate the service file here: `/etc/systemd/system/actions.runner.<org>-<repo>.<runnerName>.service`.\nIf you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described in [Configuring the self-hosted runner application as a service](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service#customizing-the-self-hosted-runner-service).\n\n## Using `launchd` to check the self-hosted runner application service\nFor macOS-based self-hosted runners running the application as a service, you can use `launchctl` to monitor their real-time activity. The default launchd-based service uses the following naming convention: `actions.runner.<org>-<repo>.<runnerName>`. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the _.service_ file in the runner directory:\n\n```hljs shell\n% cat ~/actions-runner/.service\n/Users/exampleUsername/Library/LaunchAgents/actions.runner.octo-org-octo-repo.runner01.plist\n```\n\nThe `svc.sh` script uses `launchctl` to check whether the application is running. For example:\n\n```hljs shell\n$ ./svc.sh status\nstatus actions.runner.example.runner01:\n/Users/exampleUsername/Library/LaunchAgents/actions.runner.example.runner01.plist\nStarted:\n379 0 actions.runner.example.runner01\n```\n\nThe resulting output includes the process ID and the name of the application’s `launchd` service.\n\nTo view the `launchd` configuration, you can locate the service file here: `/Users/exampleUsername/Library/LaunchAgents/actions.runner.<repoName>.<runnerName>.service`.\nIf you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described in [Configuring the self-hosted runner application as a service](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service#customizing-the-self-hosted-runner-service-1).\n\n## Using PowerShell to check the self-hosted runner application service\nFor Windows-based self-hosted runners running the application as a service, you can use PowerShell to monitor their real-time activity. The service uses the naming convention `GitHub Actions Runner (<org>-<repo>.<runnerName>)`. You can also find the service's name by checking the _.service_ file in the runner directory:\n\n```hljs powershell\nPS C:\\actions-runner> Get-Content .service\nactions.runner.octo-org-octo-repo.runner01.service\n```\n\nYou can view the status of the runner in the Windows _Services_ application ( `services.msc`). You can also use PowerShell to check whether the service is running:\n\n```hljs powershell\nPS C:\\actions-runner> Get-Service \"actions.runner.octo-org-octo-repo.runner01.service\" | Select-Object Name, Status\nName                                                  Status\n----                                                  ------\nactions.runner.octo-org-octo-repo.runner01.service    Running\n```\n\nYou can use PowerShell to check the recent activity of the self-hosted runner. In this example output, you can see the application start, receive a job named `testAction`, and then display the resulting status:\n\n```hljs powershell\nPS C:\\actions-runner> Get-EventLog -LogName Application -Source ActionsRunnerService\n\n   Index Time          EntryType   Source                 InstanceID Message\n   ----- ----          ---------   ------                 ---------- -------\n     136 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:48Z: Job Greeting completed with result: Succeeded\n     135 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:34Z: Running job: testAction\n     134 Mar 17 13:41  Information ActionsRunnerService          100 2020-03-17 13:41:54Z: Listening for Jobs\n     133 Mar 17 13:41  Information ActionsRunnerService          100 û Connected to GitHub\n     132 Mar 17 13:41  Information ActionsRunnerService            0 Service started successfully.\n     131 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner listener\n     130 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner Service\n     129 Mar 17 13:41  Information ActionsRunnerService          100 create event log trace source for actions-runner service\n```\n\n## Monitoring the automatic update process\nWe recommend that you regularly check the automatic update process, as the self-hosted runner will not be able to process jobs if it falls below a certain version threshold. The self-hosted runner application automatically updates itself, but note that this process does not include any updates to the operating system or other software; you will need to separately manage these updates.\n\nYou can view the update activities in the `Runner_` log files. For example:\n\n```hljs shell\n[Feb 12 12:37:07 INFO SelfUpdater] An update is available.\n```\n\n## Troubleshooting containers in self-hosted runners\n\n\n## Checking that Docker is installed\nIf your jobs require containers, then the self-hosted runner must be Linux-based and needs to have Docker installed. Check that your self-hosted runner has Docker installed and that the service is running.\n\nYou can use `systemctl` to check the service status:\n\n```hljs shell\n$ sudo systemctl is-active docker.service\nactive\n```\n\nIf Docker is not installed, then dependent actions will fail with the following errors:\n\n```hljs shell\n[2020-02-13 16:56:10Z INFO DockerCommandManager] Which: 'docker'\n[2020-02-13 16:56:10Z INFO DockerCommandManager] Not found.\n[2020-02-13 16:56:10Z ERR  StepsRunner] Caught exception from step: System.IO.FileNotFoundException: File not found: 'docker'\n```\n\n## Checking the Docker permissions\nIf your job fails with the following error:\n\n```hljs shell\ndial unix /var/run/docker.sock: connect: permission denied\n```\n\nCheck that the self-hosted runner's service account has permission to use the Docker service. You can identify this account by checking the configuration of the self-hosted runner in `systemd`. For example:\n\n```hljs shell\n$ sudo systemctl show -p User actions.runner.octo-org-octo-repo.runner01.service\nUser=runner-user\n```\n\n## Checking which Docker engine is installed on the runner\nIf your build fails with the following error:\n\n```hljs shell\nError: Input required and not supplied: java-version\n```\n\nCheck which Docker engine is installed on your self-hosted runner. To pass the inputs of an action into the Docker container, the runner uses environment variables that might contain dashes as part of their names. The action may not be able to get the inputs if the Docker engine is not a binary executable, but is instead a shell wrapper or a link (for example, a Docker engine installed on Linux using `snap`). To address this error, configure your self-hosted runner to use a different Docker engine.\n\nTo check if your Docker engine was installed using `snap`, use the `which` command. In the following example, the Docker engine was installed using `snap`:\n\n```hljs shell\n$ which docker\n/snap/bin/docker\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Monitoring and troubleshooting self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Check self-hosted runner network connectivity\n```yaml\n./config.sh --check --url URL --pat ghp_abcd1234\n```\n\n### Check self-hosted runner network connectivity (PowerShell)\n```yaml\nconfig.cmd --check --url https://github.com/YOUR-ORG/YOUR-REPO --pat GHP_ABCD1234\n```\n\n### Disable TLS certificate verification\n```yaml\nexport GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1\n./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.sh\n```\n\n### Using journalctl to check the self-hosted runner application service\n```yaml\nsudo journalctl -u actions.runner.octo-org-octo-repo.runner01.service -f\n```\n\n### Check Docker service status\n```yaml\n$ sudo systemctl is-active docker.service\nactive\n```\n\n### Check Docker permissions\n```yaml\n$ sudo systemctl show -p User actions.runner.octo-org-octo-repo.runner01.service\nUser=runner-user\n```\n\n### Check which Docker engine is installed on the runner\n```yaml\n$ which docker\n/snap/bin/docker\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Monitoring and troubleshooting self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• Disabling TLS verification is not recommended since TLS provides privacy and data integrity between the self-hosted runner application and GitHub. We recommend that you install the GitHub certificate in the operating system certificate store for your self-hosted runner.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using a proxy server with self-hosted runners?\n\nAssistant: You can configure self-hosted runners to use a proxy server to communicate with GitHub.\n\nHere's a detailed explanation:\n\n\n## Configuring a proxy server using environment variables\nIf you need a self-hosted runner to communicate via a proxy server, the self-hosted runner application uses proxy configurations set in the following environment variables:\n\n- `https_proxy`: Proxy URL for HTTPS traffic. You can also include basic authentication credentials, if required. For example:\n\n  - `http://proxy.local`\n  - `http://192.168.1.1:8080`\n  - `http://username:password@proxy.local`\n- `http_proxy`: Proxy URL for HTTP traffic. You can also include basic authentication credentials, if required. For example:\n\n  - `http://proxy.local`\n  - `http://192.168.1.1:8080`\n  - `http://username:password@proxy.local`\n- `no_proxy`: Comma separated list of hosts that should not use a proxy. Only hostnames are allowed in `no_proxy`, you cannot use IP addresses. For example:\n\n  - `example.com`\n  - `example.com,myserver.local:443,example.org`\n\nThe proxy environment variables are read when the self-hosted runner application starts, so you must set the environment variables before configuring or starting the self-hosted runner application. If your proxy configuration changes, you must restart the self-hosted runner application.\n\nNote\n\nTo avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using.\n\nOn Windows machines, the proxy environment variable names are case insensitive. On Linux and macOS machines, we recommend that you use all lowercase environment variables. If you have an environment variable in both lowercase and uppercase on Linux or macOS, for example `https_proxy` and `HTTPS_PROXY`, the self-hosted runner application uses the lowercase environment variable.\n\nThe connection between self-hosted runners and GitHub is over HTTPS (port 443).\n\n## Using a .env file to set the proxy configuration\nIf setting environment variables is not practical, you can set the proxy configuration variables in a file named `.env` in the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). For example, this might be necessary if you want to configure the runner application as a service under a system account. When the runner application starts, it reads the variables set in `.env` for the proxy configuration.\n\n## Example `.env` proxy configuration\n```hljs shell\nhttps_proxy=http://proxy.local:8080\nno_proxy=example.com,myserver.local:443\n```\n\n## Setting proxy configuration for Docker containers\nIf you use Docker container actions or service containers in your workflows, you might also need to configure Docker to use your proxy server in addition to setting the above environment variables.\n\nFor information on the required Docker configuration, see [Configure Docker to use a proxy server](https://docs.docker.com/network/proxy/) in the Docker documentation.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using a proxy server with self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Example `.env` proxy configuration\n```yaml\n```hljs shell\nhttps_proxy=http://proxy.local:8080\nno_proxy=example.com,myserver.local:443\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using a proxy server with self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using.\n• On Windows machines, the proxy environment variable names are case insensitive.\n• On Linux and macOS machines, we recommend that you use all lowercase environment variables.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3?\n\nAssistant: Building software with reusable workflows and artifact attestations can streamline your supply chain security and help you achieve SLSA v1.0 Build Level 3.\n\nHere's a detailed explanation:\n\n\n## Introduction\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\n\nBut remember that by itself, artifact attestations provides links, like the build instructions an artifact was built with, which meets SLSA v1.0 Build Level 2. To make an informed risk decision, it's up to you to follow those links and evaluate those build instructions.\n\nYou can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3.\n\nBefore starting this guide, you should be familiar with:\n\n- Generating artifact attestations. See [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n- Writing and using reusable workflows. See [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Step 1: Configuring your builds\nFirst, we need to build with both artifact attestations and a reusable workflow.\n\n### Building with a reusable workflow\nIf you aren't already using reusable workflows to build your software, you'll need to take your build steps and move them into a reusable workflow. For more information on how to write and call a reusable workflow, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n### Building with artifact attestations\nThe reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\nWhen you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions.\n\n```hljs yaml\npermissions:\n  attestations: write\n  contents: read\n  id-token: write\n```\n\nIf you are building container images, you will also need to include the `packages: write` permission.\n\n## Step 2: Verifying artifact attestations built with a reusable workflow\nTo verify the artifact attestations generated with your builds, you can use [`gh attestation verify`](https://cli.github.com/manual/gh_attestation_verify) from the GitHub CLI.\n\nThe `gh attestation verify` command requires either `--owner` or `--repo` flags to be used with it. These flags do two things.\n\n- They tell `gh attestation verify` where to fetch the attestation from. This will always be your caller workflow.\n- They tell `gh attestation verify` where the workflow that did the signing came from. This will always be the workflow that uses [`attest-build-provenance` action](https://github.com/actions/attest-build-provenance), which may be a reusable workflow.\n\nYou can use optional flags with the `gh attestation verify` command.\n\n- If your reusable workflow is not in the same repository as the caller workflow, use the `--signer-repo` flag to specify the repository that contains the reusable workflow.\n- If you would like to require an artifact attestation to be signed with a specific workflow, use the `--signer-workflow` flag to indicate the workflow file that should be used.\n\nFor example, if your calling workflow is `ORGANIZATION_NAME/REPOSITORY_NAME/.github/workflows/calling.yml` and it uses `REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml` you could do:\n\n```hljs bash\ngh attestation verify -o ORGANIZATION_NAME --signer-repo REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\nOr if you want to specify the exact workflow:\n\n```hljs bash\ngh attestation verify -o ORGANIZATION_NAME --signer-workflow REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\n## Conclusion\nYou are now building and signing your artifacts in a reusable workflow, which can provide the isolation required by SLSA v1.0 Build Level 3. You can verify artifacts are built with known, vetted build instructions by requiring your artifact was built with a specific workflow, reusable or not.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3?\n\nAssistant: Here are some code examples:\n\n### Permissions for reusable workflow\n```yaml\npermissions:\n  attestations: write\n  contents: read\n  id-token: write\n\n```\n\n### Verify artifact attestation (general)\n```yaml\ngh attestation verify -o ORGANIZATION_NAME --signer-repo REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\n### Verify artifact attestation (specific workflow)\n```yaml\ngh attestation verify -o ORGANIZATION_NAME --signer-workflow REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml PATH/TO/YOUR/BUILD/ARTIFACT-BINARY\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure you are familiar with generating artifact attestations and writing reusable workflows before starting.\n• Use known, vetted build instructions in your reusable workflows to enhance security.\n• Verify artifact attestations using the GitHub CLI for better provenance assurance.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating an example workflow?\n\nAssistant: Learn how to create a basic workflow that is triggered by a push event.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a basic workflow that is triggered when code is pushed to your repository.\n\nTo get started with preconfigured workflows, browse through the list of templates in the actions/starter-workflows repository. For more information, see Using workflow templates.\n\n## Creating an example workflow\nGitHub Actions uses YAML syntax to define the workflow. Each workflow is stored as a separate YAML file in your code repository, in a directory named .github/workflows.\n\nYou can create an example workflow in your repository that automatically triggers a series of commands whenever code is pushed. In this workflow, GitHub Actions checks out the pushed code, installs the bats testing framework, and runs a basic command to output the bats version: `bats -v`.\n\n1. In your repository, create the .github/workflows/ directory to store your workflow files.\n\n2. In the .github/workflows/ directory, create a new file called learn-github-actions.yml and add the following code.\n\n```yaml\nname: learn-github-actions\nrun-name: ${{ github.actor }} is learning GitHub Actions\non: [push]\njobs:\n     check-bats-version:\n       runs-on: ubuntu-latest\n       steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n3. Commit these changes and push them to your GitHub repository.\n\nYour new GitHub Actions workflow file is now installed in your repository and will run automatically each time someone pushes a change to the repository. To see the details about a workflow's execution history, see Viewing the activity for a workflow run.\n\n## Understanding the workflow file\nTo help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example:\n\n```yaml\nname: learn-github-actions\n```\n\nOptional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.\n\n```yaml\nrun-name: ${{ github.actor }} is learning GitHub Actions\n```\n\nOptional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see Workflow syntax for GitHub Actions.\n\n```yaml\non: [push]\n```\n\nSpecifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see Workflow syntax for GitHub Actions.\n\n```yaml\njobs:\n```\n\nGroups together all the jobs that run in the `learn-github-actions` workflow.\n\n```yaml\ncheck-bats-version:\n```\n\nDefines a job named `check-bats-version`. The child keys will define properties of the job.\n\n```yaml\n    runs-on: ubuntu-latest\n```\n\nConfigures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see Workflow syntax for GitHub Actions.\n\n```yaml\n    steps:\n```\n\nGroups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.\n\n```yaml\n      - uses: actions/checkout@v4\n```\n\nThe `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.\n\n```yaml\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n```\n\nThis step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.\n\n```yaml\n      - run: npm install -g bats\n```\n\nThe `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.\n\n```yaml\n      - run: bats -v\n```\n\nFinally, you'll run the `bats` command with a parameter that outputs the software version.\n\n## Visualizing the workflow file\nIn this diagram, you can see the workflow file you just created and how the GitHub Actions components are organized in a hierarchy. Each step executes a single action or shell script. Steps 1 and 2 run actions, while steps 3 and 4 run shell scripts. To find more prebuilt actions for your workflows, see Using pre-written building blocks in your workflow.\n\n## Viewing the activity for a workflow run\nWhen your workflow is triggered, a workflow run is created that executes the workflow. After a workflow run has started, you can see a visualization graph of the run's progress and view each step's activity on GitHub.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. In the left sidebar or in the visualization graph, click the job you want to see.\n\n6. To view the results of a step, click the step.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating an example workflow?\n\nAssistant: Here are some code examples:\n\n### Example Workflow YAML\n```yaml\nname: learn-github-actions\nrun-name: ${{ github.actor }} is learning GitHub Actions\non: [push]\njobs:\n     check-bats-version:\n       runs-on: ubuntu-latest\n       steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm install -g bats\n      - run: bats -v\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating an example workflow?\n\nAssistant: Here are the recommended best practices:\n\n• Use the checkout action any time your workflow will use the repository's code.\n• For syntax examples using other runners, see Workflow syntax for GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using artifact attestations?\n\nAssistant: Use artifact attestations to establish build provenance for the software you produce and to verify the software you consume.\n\nHere's a detailed explanation:\n\n\n## Using artifact attestations to establish provenance for builds\nArtifact attestations enable you to increase the supply chain security of your builds by establishing where and how your software was built.\n\n## Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3\nBuilding software with reusable workflows and artifact attestations can streamline your supply chain security and help you achieve SLSA v1.0 Build Level 3.\n\n## Enforcing artifact attestations with a Kubernetes admission controller\nUse an admission controller to enforce artifact attestations in your Kubernetes cluster.\n\n## Verifying attestations offline\nArtifact attestations can be verified without an internet connection.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Installing an Apple certificate on macOS runners for Xcode development?\n\nAssistant: You can sign Xcode apps within your continuous integration (CI) workflow by installing an Apple code signing certificate on GitHub Actions runners.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to add a step to your continuous integration (CI) workflow that installs an Apple code signing certificate and provisioning profile on GitHub Actions runners. This will allow you to sign your Xcode apps for publishing to the Apple App Store, or distributing it to test groups.\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n- [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n\nYou should have an understanding of Xcode app building and signing. For more information, see the [Apple developer documentation](https://developer.apple.com/documentation/).\n\n## Creating secrets for your certificate and provisioning profile\nThe signing process involves storing certificates and provisioning profiles, transferring them to the runner, importing them to the runner's keychain, and using them in your build.\n\nTo use your certificate and provisioning profile on a runner, we strongly recommend that you use GitHub secrets. For more information on creating secrets and using them in a workflow, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\nCreate secrets in your repository or organization for the following items:\n\n- Your Apple signing certificate.\n  - This is your `p12` certificate file. For more information on exporting your signing certificate from Xcode, see the [Xcode documentation](https://help.apple.com/xcode/mac/current/#/dev154b28f09).\n\n  - You should convert your certificate to Base64 when saving it as a secret. In this example, the secret is named `BUILD_CERTIFICATE_BASE64`.\n\n  - Use the following command to convert your certificate to Base64 and copy it to your clipboard:\n\n\n    ```hljs shell\n    base64 -i BUILD_CERTIFICATE.p12 | pbcopy\n\n    ```\n- The password for your Apple signing certificate.\n  - In this example, the secret is named `P12_PASSWORD`.\n- Your Apple provisioning profile.\n  - For more information on exporting your provisioning profile from Xcode, see the [Xcode documentation](https://help.apple.com/xcode/mac/current/#/deva899b4fe5).\n\n  - You should convert your provisioning profile to Base64 when saving it as a secret. In this example, the secret is named `BUILD_PROVISION_PROFILE_BASE64`.\n\n  - Use the following command to convert your provisioning profile to Base64 and copy it to your clipboard:\n\n\n    ```hljs shell\n    base64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy\n\n    ```\n- A keychain password.\n  - A new keychain will be created on the runner, so the password for the new keychain can be any new random string. In this example, the secret is named `KEYCHAIN_PASSWORD`.\n\n## Add a step to your workflow\nThis example workflow includes a step that imports the Apple certificate and provisioning profile from the GitHub secrets, and installs them on the runner.\n\n```hljs yaml\nname: App build\non: push\n\njobs:\n  build_with_signing:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: Install the Apple certificate and provisioning profile\n        env:\n          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}\n          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}\n          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          # create variables\n          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12\n          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # import certificate and provisioning profile from secrets\n          echo -n \"$BUILD_CERTIFICATE_BASE64\" | base64 --decode -o $CERTIFICATE_PATH\n          echo -n \"$BUILD_PROVISION_PROFILE_BASE64\" | base64 --decode -o $PP_PATH\n\n          # create temporary keychain\n          security create-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH\n          security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n\n          # import certificate to keychain\n          security import $CERTIFICATE_PATH -P \"$P12_PASSWORD\" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH\n          security set-key-partition-list -S apple-tool:,apple: -k \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security list-keychain -d user -s $KEYCHAIN_PATH\n\n          # apply provisioning profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n      - name: Build app\n          # ...\n\n```\n\nNote\n\nFor iOS build targets, your provisioning profile should have the extension `.mobileprovision`. For macOS build targets, the extension should be `.provisionprofile`. The example workflow above should be updated to reflect your target platform.\n\n## Required clean-up on self-hosted runners\nGitHub-hosted runners are isolated virtual machines that are automatically destroyed at the end of the job execution. This means that the certificates and provisioning profile used on the runner during the job will be destroyed with the runner when the job is completed.\n\nOn self-hosted runners, the `$RUNNER_TEMP` directory is cleaned up at the end of the job execution, but the keychain and provisioning profile might still exist on the runner.\n\nIf you use self-hosted runners, you should add a final step to your workflow to help ensure that these sensitive files are deleted at the end of the job. The workflow step shown below is an example of how to do this.\n\n```hljs yaml\n- name: Clean up keychain and provisioning profile\n  if: ${{ always() }}\n  run: |\n    security delete-keychain $RUNNER_TEMP/app-signing.keychain-db\n    rm ~/Library/MobileDevice/Provisioning\\ Profiles/build_pp.mobileprovision\n\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Installing an Apple certificate on macOS runners for Xcode development?\n\nAssistant: Here are some code examples:\n\n### Convert certificate to Base64\n```yaml\nbase64 -i BUILD_CERTIFICATE.p12 | pbcopy\n```\n\n### Convert provisioning profile to Base64\n```yaml\nbase64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy\n```\n\n### Example workflow for installing Apple certificate and provisioning profile\n```yaml\nname: App build\non: push\n\njobs:\n  build_with_signing:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: Install the Apple certificate and provisioning profile\n        env:\n          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}\n          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}\n          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          # create variables\n          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12\n          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # import certificate and provisioning profile from secrets\n          echo -n \"$BUILD_CERTIFICATE_BASE64\" | base64 --decode -o $CERTIFICATE_PATH\n          echo -n \"$BUILD_PROVISION_PROFILE_BASE64\" | base64 --decode -o $PP_PATH\n\n          # create temporary keychain\n          security create-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH\n          security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n\n          # import certificate to keychain\n          security import $CERTIFICATE_PATH -P \"$P12_PASSWORD\" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH\n          security set-key-partition-list -S apple-tool:,apple: -k \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security list-keychain -d user -s $KEYCHAIN_PATH\n\n          # apply provisioning profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n      - name: Build app\n          # ...\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Installing an Apple certificate on macOS runners for Xcode development?\n\nAssistant: Here are the recommended best practices:\n\n• Use GitHub secrets to store sensitive information like certificates and passwords.\n• Ensure that your provisioning profile has the correct extension based on your target platform (iOS or macOS).\n• Add a clean-up step in your workflow for self-hosted runners to delete sensitive files after the job execution.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Removing self-hosted runners?\n\nAssistant: You can permanently remove a self-hosted runner from a repository or organization.\n\nHere's a detailed explanation:\n\n\n## Removing a runner from a repository\nNote\n\n- This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop the `run` application. The runner will remain assigned in an \"Offline\" state, and won't execute any jobs until you restart the runner using the `run` application.\n- A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.\n- Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub.\n\nTo remove a self-hosted runner from a user repository you must be the repository owner. Organization owners can remove a runner from a repository in the organization.\n\nWe recommend that you also have access to the self-hosted runner machine.\n\nFor information about how to remove a self-hosted runner with the REST API, see [REST API endpoints for self-hosted runners](https://docs.github.com/en/rest/actions/self-hosted-runners).\n\nAlternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the `.runner` file inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n\n3. In the left sidebar, click **Actions**, then click **Runners**.\n\n4. In the list of runners, click on the name of the runner you'd like to configure.\n\n5. Click **Remove**.\n\n6. You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:\n   - **If you have access to the runner machine:** Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.\n\n     The removal command does the following tasks:\n     - Removes the runner from GitHub.\n     - Removes any self-hosted runner application configuration files on the machine.\n     - Removes any services configured if not running in interactive mode.\n   - **If you don't have access to the machine:** Click **Force remove this runner** to force GitHub to remove the runner.\n\n## Removing a runner from an organization\nNote\n\n- This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop the `run` application. The runner will remain assigned in an \"Offline\" state, and won't execute any jobs until you restart the runner using the `run` application.\n- A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.\n- Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub.\n\nTo remove a self-hosted runner from an organization, you must be an organization owner. We recommend that you also have access to the self-hosted runner machine. For information about how to remove a self-hosted runner with the REST API, see [REST API endpoints for self-hosted runners](https://docs.github.com/en/rest/actions/self-hosted-runners).\n\nAlternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the `.runner` file inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application.\n\n1. On GitHub, navigate to the main page of the organization.\n\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n\n3. In the left sidebar, click **Actions**, then click **Runners**.\n\n4. In the list of runners, click on the name of the runner you'd like to configure.\n\n5. Click **Remove**.\n\n6. You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:\n   - **If you have access to the runner machine:** Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.\n\n     The removal command does the following tasks:\n     - Removes the runner from GitHub.\n     - Removes any self-hosted runner application configuration files on the machine.\n     - Removes any services configured if not running in interactive mode.\n   - **If you don't have access to the machine:** Click **Force remove this runner** to force GitHub to remove the runner.\n\n## Removing a runner from an enterprise\nIf you use GitHub Enterprise Cloud, you can also remove runners from an enterprise. For more information, see the [GitHub Enterprise Cloud documentation](https://docs.github.com/en/enterprise-cloud@latest/actions/hosting-your-own-runners/managing-self-hosted-runners/removing-self-hosted-runners#removing-a-runner-from-an-enterprise).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Removing self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop the `run` application.\n• A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days.\n• An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.\n• Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About GitHub-hosted runners?\n\nAssistant: GitHub offers hosted virtual machines to run workflows. The virtual machine contains an environment of tools, packages, and settings available for GitHub Actions to use.\n\nHere's a detailed explanation:\n\n\n## Overview of GitHub-hosted runners\nRunners are the machines that execute jobs in a GitHub Actions workflow. For example, a runner can clone your repository locally, install testing software, and then run commands that evaluate your code.\n\nGitHub provides runners that you can use to run your jobs, or you can host your own runners. Each GitHub-hosted runner is a new virtual machine (VM) hosted by GitHub with the runner application and other tools preinstalled, and is available with Ubuntu Linux, Windows, or macOS operating systems. When you use a GitHub-hosted runner, machine maintenance and upgrades are taken care of for you.\n\nYou can choose one of the standard GitHub-hosted runner options or, if you are on the GitHub Team or GitHub Enterprise Cloud plan, you can provision a runner with more cores, or a runner that's powered by a GPU processor. These machines are referred to as \"larger runner.\" For more information, see About larger runners.\n\nUsing GitHub-hosted runners requires network access with at least 70 kilobits per second upload and download speeds.\n\n## Using a GitHub-hosted runner\nTo use a GitHub-hosted runner, create a job and use `runs-on` to specify the type of runner that will process the job, such as `ubuntu-latest`, `windows-latest`, or `macos-latest`. For the full list of runner types, see About GitHub-hosted runners. If you have `repo: write` access to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, see Viewing available runners for a repository.\n\nWhen the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned.\n\nThe following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners.\n\nThe following example workflow has two jobs, named `Run-npm-on-Ubuntu` and `Run-PSScriptAnalyzer-on-Windows`. When this workflow is triggered, GitHub provisions a new virtual machine for each job.\n\n- The job named `Run-npm-on-Ubuntu` is executed on a Linux VM, because the job's `runs-on:` specifies `ubuntu-latest`.\n- The job named `Run-PSScriptAnalyzer-on-Windows` is executed on a Windows VM, because the job's `runs-on:` specifies `windows-latest`.\n\n## Viewing available runners for a repository\nIf you have `repo: write` access to a repository, you can view a list of the runners available to the repository.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. In the left sidebar, under the \"Management\" section, click **Runners**.\n4. Review the list of available GitHub-hosted runners for the repository.\n5. Optionally, to copy a runner's label to use it in a workflow, click to the right of the runner, then click **Copy label**.\n\nNote: Enterprise and organization owners can create runners from this page. To create a new runner, click **New runner** at the top right of the list of runners to add runners to the repository.\n\n## Supported runners and hardware resources\nRanges of GitHub-hosted runners are available for use in public and private repositories.\n\nFor lists of available runners, see:\n\n- Standard runners for **public** repositories\n- Standard runners for **private** repositories\n\nGitHub-hosted Linux runners support hardware acceleration for Android SDK tools, which makes running Android tests much faster and consumes fewer minutes. For more information on Android hardware acceleration, see Configure hardware acceleration for the Android Emulator in the Android Developers documentation.\n\n## Limitations for arm64 macOS runners\n- All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\n- Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\n- Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\n- The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically `4203018E-580F-C1B5-9525-B745CECA79EB`. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\n\n## Larger runners\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:\n\n- More RAM, CPU, and disk space\n- Static IP addresses\n- Azure private networking\n- The ability to group runners\n- Autoscaling to support concurrent workflows\n- GPU-powered and ARM-powered runners\n\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\n\n## Runner Images\nGitHub maintains our own set of VM images for our standard hosted runners. This includes the images for macOS, x64 linux and Windows images. The list of images and their included tools are managed in the actions/runner-images repository. Our arm64 linux images are partner images, and those are managed in the actions/partner-runner-images repository.\n\n## Preinstalled software for GitHub-owned images\nThe software tools included in our GitHub-owned images are updated weekly. The update process takes several days, and the list of preinstalled software on the main branch is updated after the whole deployment ends.\n\nWorkflow logs include a link to the preinstalled tools on the exact runner. To find this information in the workflow log, expand the Set up job section. Under that section, expand the Runner Image section. The link following Included Software will describe the preinstalled tools on the runner that ran the workflow.\n\n## Using preinstalled software\nWe recommend using actions to interact with the software installed on runners. This approach has several benefits:\n\n- Usually, actions provide more flexible functionality like version selection, ability to pass arguments, and parameters\n- It ensures the tool versions used in your workflow will remain the same regardless of software updates\n\nIf there is a tool that you'd like to request, please open an issue at actions/runner-images. This repository also contains announcements about all major software updates on runners.\n\n## Installing additional software\nYou can install additional software on GitHub-hosted runners. For more information, see Customizing GitHub-hosted runners.\n\n## Cloud hosts used by GitHub-hosted runners\nGitHub hosts Linux and Windows runners on virtual machines in Microsoft Azure with the GitHub Actions runner application installed. The GitHub-hosted runner application is a fork of the Azure Pipelines Agent. Inbound ICMP packets are blocked for all Azure virtual machines, so ping or traceroute commands might not work. GitHub hosts macOS runners in Azure data centers.\n\n## Workflow continuity\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.\n\n## Administrative privileges\nThe Linux and macOS virtual machines both run using passwordless `sudo`. When you need to execute commands or install tools that require more privileges than the current user, you can use `sudo` without needing to provide a password. Windows virtual machines are configured to run as administrators with User Account Control (UAC) disabled.\n\n## IP addresses\nTo get a list of IP address ranges that GitHub Actions uses for GitHub-hosted runners, you can use the GitHub REST API. For more information, see the actions key in the response of the GET /meta endpoint.\n\n## Communication requirements for GitHub-hosted runners\nA GitHub-hosted runner must establish connections to GitHub-owned endpoints to perform essential communication operations. In addition, your runner may require access to additional networks that you specify or utilize within an action.\n\n## The etc/hosts file\nGitHub-hosted runners are provisioned with an etc/hosts file that blocks network access to various cryptocurrency mining pools and malicious sites.\n\n## File systems\nGitHub executes actions and shell commands in specific directories on the virtual machine. The file paths on virtual machines are not static. Use the environment variables GitHub provides to construct file paths for the home, workspace, and workflow directories.\n\n## Docker container filesystem\nActions that run in Docker containers have static directories under the /github path. However, we strongly recommend using the default environment variables to construct file paths in Docker containers.\n\n## Further reading\n- Managing billing for GitHub Actions\n- You can use a matrix strategy to run your jobs on multiple images.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About GitHub-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Example workflow for GitHub-hosted runners\n```yaml\nname: Run commands on different operating systems\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  Run-npm-on-Ubuntu:\n    name: Run npm on Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm help\n\n  Run-PSScriptAnalyzer-on-Windows:\n    name: Run PSScriptAnalyzer on Windows\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Get list of rules\n        shell: pwsh\n        run: |\n          Get-ScriptAnalyzerRule\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About GitHub-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• Using actions to interact with the software installed on runners is recommended for flexibility and consistency in tool versions.\n• For additional software installation, refer to the documentation on customizing GitHub-hosted runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is GitHub Actions learning paths?\n\nAssistant: Learning paths are a collection of guides that help you master a particular subject.\n\nHere's a detailed explanation:\n\n\n## Get started with GitHub Actions\nDiscover the possibilities of GitHub Actions by creating your first workflow.\n\n1. Overview [Understanding GitHub Actions](https://docs.github.com/en/actions/about-github-actions/understanding-github-actions?learn=getting_started&learnProduct=actions)\n2. How-to guide [Using pre-written building blocks in your workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow?learn=getting_started&learnProduct=actions)\n3. Overview [About workflows](https://docs.github.com/en/actions/writing-workflows/about-workflows?learn=getting_started&learnProduct=actions)\n4. How-to guide [Reusing workflows](https://docs.github.com/en/actions/sharing-automations/reusing-workflows?learn=getting_started&learnProduct=actions)\n5. Overview [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions?learn=getting_started&learnProduct=actions)\n\n## Host your own runners\nYou can create self-hosted runners to run workflows in a highly customizable environment.\n\n1. Overview [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners?learn=hosting_your_own_runners&learnProduct=actions)\n2. Tutorial [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners?learn=hosting_your_own_runners&learnProduct=actions)\n3. Tutorial [Configuring the self-hosted runner application as a service](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service?learn=hosting_your_own_runners&learnProduct=actions)\n4. Tutorial [Using a proxy server with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-a-proxy-server-with-self-hosted-runners?learn=hosting_your_own_runners&learnProduct=actions)\n5. Tutorial [Using labels with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-labels-with-self-hosted-runners?learn=hosting_your_own_runners&learnProduct=actions)\n6. Tutorial [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow?learn=hosting_your_own_runners&learnProduct=actions)\n7. Tutorial [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups?learn=hosting_your_own_runners&learnProduct=actions)\n8. Tutorial [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners?learn=hosting_your_own_runners&learnProduct=actions)\n\n## Create an action\nDo you have an idea for a new action? Have you built something custom for your project? Learn how to build shareable actions and publish them to GitHub Marketplace.\n\n1. Overview [About custom actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions?learn=create_actions&learnProduct=actions)\n2. Tutorial [Creating a Docker container action](https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action?learn=create_actions&learnProduct=actions)\n3. Tutorial [Creating a JavaScript action](https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action?learn=create_actions&learnProduct=actions)\n4. Tutorial [Creating a composite action](https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action?learn=create_actions&learnProduct=actions)\n5. Reference [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions?learn=create_actions&learnProduct=actions)\n6. Reference [Dockerfile support for GitHub Actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions?learn=create_actions&learnProduct=actions)\n7. How-to guide [Setting exit codes for actions](https://docs.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions?learn=create_actions&learnProduct=actions)\n8. How-to guide [Publishing actions in GitHub Marketplace](https://docs.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace?learn=create_actions&learnProduct=actions)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using environments for deployment?\n\nAssistant: Specify a deployment environment in your workflow.\n\nHere's a detailed explanation:\n\n\n## About environments\nEnvironments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\nEach job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner. The job can access the environment's secrets only after the job is sent to a runner.\n\nWhen a workflow references an environment, the environment will appear in the repository's deployments. For more information about viewing current and previous deployments, see [Viewing deployment history](https://docs.github.com/en/actions/deployment/managing-your-deployments/viewing-deployment-history).\n\n## Using an environment in a workflow\nYou can specify an environment for each job in your workflow. To do so, add a [`jobs.<job_id>.environment`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenvironment) key followed by the name of the environment.\n\nFor example, this workflow will use an environment called `production`.\n\n```hljs yaml\nname: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps\n\n```\n\nWhen the above workflow runs, the `deployment` job will be subject to any rules configured for the `production` environment. For example, if the environment requires reviewers, the job will pause until one of the reviewers approves the job.\n\nYou can also specify a URL for the environment. The specified URL will appear on the deployments page for the repository (accessed by clicking **Environments** on the home page of your repository) and in the visualization graph for the workflow run. If a pull request triggered the workflow, the URL is also displayed as a **View deployment** button in the pull request timeline. When using the \"Require deployments to succeed before merging\" rule, only the `name` specified is being checked even if a URL has also been specified. See [About protected branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches#require-deployments-to-succeed-before-merging).\n\n## Code Example\n```hljs yaml\nname: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment:\n      name: production\n      url: https://github.com\n    steps:\n      - name: deploy\n        # ...deployment-specific steps\n\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using environments for deployment?\n\nAssistant: Here are some code examples:\n\n### Using an environment in a workflow\n```yaml\n```hljs yaml\nname: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps\n\n```\n```\n\n### Specifying a URL for the environment\n```yaml\n```hljs yaml\nname: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment:\n      name: production\n      url: https://github.com\n    steps:\n      - name: deploy\n        # ...deployment-specific steps\n\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using environments for deployment?\n\nAssistant: Here are the recommended best practices:\n\n• Use environments to require approval for a job to proceed.\n• Restrict which branches can trigger a workflow using environments.\n• Gate deployments with custom deployment protection rules.\n• Limit access to secrets using environments.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in PyPI?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with PyPI.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with PyPI to publish Python packages.\n\nThis guide gives an overview of how to configure PyPI to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the `pypa/gh-action-pypi-publish` action to publish packages to PyPI (or other Python package repositories) without any manual API token management.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\n## Adding the identity provider to PyPI\nTo use OIDC with PyPI, add a trust configuration that links each project on PyPI to each repository and workflow combination that's allowed to publish for it.\n\n1. Sign in to PyPI and navigate to the trusted publishing settings for the project you'd like to configure. For a project named `myproject`, this will be at `https://pypi.org/manage/project/myproject/settings/publishing/`.\n\n2. Configure a trust relationship between the PyPI project and a GitHub repository (and workflow within the repository). For example, if your GitHub repository is at `myorg/myproject` and your release workflow is defined in `release.yml` with an environment of `release`, you should use the following settings for your trusted publisher on PyPI.\n\n   - Owner: `myorg`\n   - Repository name: `myproject`\n   - Workflow name: `release.yml`\n   - (Optionally) a GitHub Actions environment name: `release`.\n\n## Updating your GitHub Actions workflow\nOnce your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing.\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\nThe `pypa/gh-action-pypi-publish` action has built-in support for trusted publishing, which can be enabled by giving its containing job the `id-token: write` permission and omitting `username` and `password`.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in PyPI?\n\nAssistant: Here are some code examples:\n\n### Example GitHub Actions Workflow for PyPI Publishing\n```yaml\n```yaml\njobs:\n  release-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.x\"\n\n      - name: build release distributions\n        run: |\n          # NOTE: put your own distribution build steps here.\n          python -m pip install build\n          python -m build\n\n      - name: upload windows dists\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  pypi-publish:\n    runs-on: ubuntu-latest\n    needs:\n      - release-build\n    permissions:\n      id-token: write\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in PyPI?\n\nAssistant: Here are the recommended best practices:\n\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Bitbucket Pipelines with GitHub Actions Importer?\n\nAssistant: Learn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About migrating from Bitbucket Pipelines with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bitbucket Pipelines to GitHub Actions.\n\n## Prerequisites\n- An environment where you can run Linux-based containers, and can install the necessary tools.\n\n  - Docker is [installed](https://docs.docker.com/get-docker/) and running.\n\n  - [GitHub CLI](https://cli.github.com/) is installed.\n\nNote\n\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n\n## Limitations\nThere are some limitations when migrating from Bitbucket Pipelines to GitHub Actions with GitHub Actions Importer.\n\n- Images in a private AWS ECR are not supported.\n\n- The Bitbucket Pipelines option `size` is not supported. If additional runner resources are required in GitHub Actions, consider using larger runners. For more information, see [Using larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners).\n\n- Metrics detailing the queue time of jobs is not supported by the `forecast` command.\n\n- Bitbucket [after-scripts](https://support.atlassian.com/bitbucket-cloud/docs/step-options/#After-script) are supported using GitHub Actions `always()` in combination with checking the `steps.<step_id>.conclusion` of the previous step. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context).\n\n## Manual tasks\nCertain Bitbucket Pipelines constructs must be migrated manually. These include:\n\n- Secured repository, workspace, and deployment variables\n- SSH keys\n\n## Installing the GitHub Actions Importer CLI extension\n1. Install the GitHub Actions Importer CLI extension:\n\n```hljs bash\ngh extension install github/gh-actions-importer\n```\n\n2. Verify that the extension is installed:\n\n```hljs bash\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Configuring credentials\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with Bitbucket Pipelines and GitHub.\n\n1. Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n\nYour token must have the `workflow` scope.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n2. Create a Workspace Access Token for Bitbucket Pipelines. For more information, see [Workspace Access Token permissions](https://support.atlassian.com/bitbucket-cloud/docs/workspace-access-token-permissions/) in the Bitbucket documentation. Your token must have the `read` scope for pipelines, projects, and repositories.\n\n3. In your terminal, run the GitHub Actions Importer `configure` CLI command:\n\n```hljs shell\ngh actions-importer configure\n```\n\nThe `configure` command will prompt you for the following information:\n\n   - For \"Which CI providers are you configuring?\", use the arrow keys to select `Bitbucket`, press `Space` to select it, then press `Enter`.\n   - For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press `Enter`.\n   - For \"Base url of the GitHub instance\", press `Enter` to accept the default value ( `https://github.com`).\n   - For \"Personal access token for Bitbucket\", enter the Workspace Access Token that you created earlier, and press `Enter`.\n   - For \"Base url of the Bitbucket instance\", enter the URL for your Bitbucket instance, and press `Enter`.\n\nAn example of the `configure` command is shown below:\n\n```hljs shell\n$ gh actions-importer configure\n✔ Which CI providers are you configuring?: Bitbucket\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Bitbucket: ********************\n✔ Base url of the Bitbucket instance: https://bitbucket.example.com\nEnvironment variables successfully updated.\n```\n\n4. In your terminal, run the GitHub Actions Importer `update` CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\n\n```hljs shell\ngh actions-importer update\n```\n\nThe output of the command should be similar to below:\n\n```hljs shell\nUpdating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date\n```\n\n## Perform an audit of the Bitbucket instance\nYou can use the audit command to get a high-level view of pipelines in a Bitbucket instance.\n\nThe audit command performs the following steps.\n\n1. Fetches all of the pipelines for a workspace.\n2. Converts pipeline to its equivalent GitHub Actions workflow.\n3. Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n## Running the audit command\nTo perform an audit run the following command in your terminal, replacing `:workspace` with the name of the Bitbucket workspace to audit.\n\n```hljs bash\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit\n```\n\nOptionally, a `--project-key` option can be provided to the audit command to limit the results to only pipelines associated with a project.\n\nIn the below example command `:project_key` should be replaced with the key of the project that should be audited. Project keys can be found in Bitbucket on the workspace projects page.\n\n```hljs bash\ngh actions-importer audit bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/audit\n```\n\n## Inspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\nThe audit summary has the following sections.\n\n## Forecasting usage\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Bitbucket instance.\n\n## Running the forecast command\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal, replacing `:workspace` with the name of the Bitbucket workspace to forecast. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```hljs shell\ngh actions-importer forecast bitbucket --workspace :workspace --output-dir tmp/forecast_reports\n```\n\n## Performing a dry-run migration\nYou can use the dry-run command to convert a Bitbucket pipeline to an equivalent GitHub Actions workflow(s). A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\n## Running the dry-run command\nTo perform a dry run of migrating a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing `:workspace` with the name of the workspace and `:repo` with the name of the repository in Bitbucket.\n\n```hljs bash\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run\n```\n\n## Performing a production migration\nYou can use the migrate command to convert a Bitbucket pipeline and open a pull request with the equivalent GitHub Actions workflow(s).\n\n## Running the migrate command\nTo migrate a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing the following values.\n\n- Replace `target-url` value with the URL for your GitHub repository.\n- Replace `:repo` with the name of the repository in Bitbucket.\n- Replace `:workspace` with the name of the workspace.\n\n```hljs bash\ngh actions-importer migrate bitbucket --workspace :workspace --repository :repo --target-url https://github.com/:owner/:repo --output-dir tmp/dry-run\n```\n\n## Inspecting the pull request\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\n## Reference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bitbucket Pipelines.\n\n## Using environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command.\n\n## Optional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n## Supported syntax for Bitbucket Pipelines\nThe following table shows the type of properties that GitHub Actions Importer is currently able to convert.\n\n## Environment variable mapping\nGitHub Actions Importer uses the mapping in the table below to convert default Bitbucket environment variables to the closest equivalent in GitHub Actions.\n\n## System Variables\nSystem variables used in tasks are transformed to the equivalent bash shell variable and are assumed to be available. For example, `${system.<variable.name>}` will be transformed to `$variable_name`. We recommend you verify this to ensure proper operation of the workflow.\n\n## Legal notice\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nauthors or copyright holders be liable for any claim, damages or other\nliability, whether in an action of contract, tort or otherwise, arising from,\nout of or in connection with the Software or the use or other dealings in the\nSoftware.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Bitbucket Pipelines with GitHub Actions Importer?\n\nAssistant: Here are some code examples:\n\n### After Script Example\n```yaml\n  - name: After Script 1\n    run: |-\n      echo \"I'm after the script ran!\"\n      echo \"We should be grouped!\"\n    id: after-script-1\n    if: \"${{ always() }}\"\n  - name: After Script 2\n    run: |-\n      echo \"this is really the end\"\n      echo \"goodbye, for now!\"\n    id: after-script-2\n    if: \"${{ steps.after-script-1.conclusion == 'success' && always() }}\"\n```\n\n### Installing the GitHub Actions Importer CLI extension\n```yaml\ngh extension install github/gh-actions-importer\n```\n\n### Verifying the extension installation\n```yaml\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n### Configuring credentials command\n```yaml\ngh actions-importer configure\n```\n\n### Running the audit command\n```yaml\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit\n```\n\n### Running the forecast command\n```yaml\ngh actions-importer forecast bitbucket --workspace :workspace --output-dir tmp/forecast_reports\n```\n\n### Running the dry-run command\n```yaml\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run\n```\n\n### Running the migrate command\n```yaml\ngh actions-importer migrate bitbucket --workspace :workspace --repository :repo --target-url https://github.com/:owner/:repo --output-dir tmp/dry-run\n```\n\n### Configuring with a config file\n```yaml\ngh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit --config-file-path \"path/to/my/bitbucket/config.yml\"\n```\n\n### Using source file path\n```yaml\ngh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run --source-file-path path/to/my/pipeline/file.yml\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from Bitbucket Pipelines with GitHub Actions Importer?\n\nAssistant: Here are the recommended best practices:\n\n• The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n• Ensure that your personal access tokens have the required scopes for GitHub and Bitbucket.\n• Review the audit summary to understand the conversion rate and identify any manual tasks that need to be completed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Monitoring and troubleshooting workflows?\n\nAssistant: You can view the status and results of each step in your workflow, debug a failed workflow, and search and download logs.\n\nHere's a detailed explanation:\n\n\n## Monitoring workflows\n- About monitoring workflows\n- Notifications for workflow runs\n- Using the visualization graph\n- Viewing workflow run history\n- Viewing job execution time\n- Adding a workflow status badge\n- Using workflow run logs\n\n## Troubleshooting workflows\n- About troubleshooting workflows\n- Using Copilot to troubleshoot workflows\n- Enabling debug logging\n- Working with Support for GitHub Actions\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in JFrog?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with JFrog.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with JFrog to download and publish artifacts without storing JFrog passwords, tokens, or API keys in GitHub.\n\nThis guide gives an overview of how to configure JFrog to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in a GitHub Actions workflow.\n\nFor an example GitHub Actions workflow, see Sample GitHub Actions Integration in the JFrog documentation.\n\nFor an example GitHub Actions workflow using the JFrog CLI, see build-publish.yml in the jfrog-github-oidc-example repository.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\n\n- To be secure, you need to set a Claims JSON in JFrog when configuring identity mappings. For more information, see AUTOTITLE and About security hardening with OpenID Connect.\n\nFor example, you can set `iss` to `https://token.actions.githubusercontent.com`, and the `repository` to something like \"octo-org/octo-repo\". This will ensure only Actions workflows from the specified repository will have access to your JFrog platform. The following is an example Claims JSON when configuring identity mappings.\n\n## Adding the identity provider to JFrog\nTo use OIDC with JFrog, establish a trust relationship between GitHub Actions and the JFrog platform. For more information about this process, see OpenID Connect Integration in the JFrog documentation.\n\n1. Sign in to your JFrog Platform.\n2. Configure trust between JFrog and your GitHub Actions workflows.\n3. Configure identity mappings.\n\n## Updating your GitHub Actions workflow\nOnce you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file.\n\nIn your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in JFrog?\n\nAssistant: Here are some code examples:\n\n### Claims JSON Example\n```yaml\n{\n    \"iss\": \"https://token.actions.githubusercontent.com\",\n    \"repository\": \"octo-org/octo-repo\"\n}\n```\n\n### Fetch Access Token from Artifactory\n```yaml\n- name: Fetch Access Token from Artifactory\n  id: fetch_access_token\n  env:\n    ID_TOKEN: $\n  run: |\n    ACCESS_TOKEN=$(curl \\\n    -X POST \\\n    -H \"Content-type: application/json\" \\\n    https://example.jfrog.io/access/api/v1/oidc/token \\\n    -d \\\n    \"{\\\"grant_type\\\": \\\"urn:ietf:params:oauth:grant-type:token-exchange\\\", \\\"subject_token_type\\\":\\\"urn:ietf:params:oauth:token-type:id_token\\\", \\\"subject_token\\\": \\\"$ID_TOKEN\\\", \\\"provider_name\\\": \\\"YOUR_PROVIDER_NAME\\\"}\" | jq .access_token | tr -d '\"')\n    echo ACCESS_TOKEN=$ACCESS_TOKEN >> $GITHUB_OUTPUT\n\n```\n\n### Get ID Token (cURL method)\n```yaml\n- name: Get ID Token (cURL method)\n  id: idtoken\n  run: |\n    ID_TOKEN=$(curl -sLS -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \\\n    \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=jfrog-github\" | jq .value | tr -d '\"')\n    echo \"ID_TOKEN=${ID_TOKEN}\" >> $GITHUB_OUTPUT\n\n```\n\n### Using env context to retrieve OIDC audience\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      OIDC_AUDIENCE: 'YOUR_AUDIENCE'\n\n```\n\n### Get ID Token (using env context)\n```yaml\n- name: Get ID Token (using env context)\n  uses: actions/github-script@v7\n  id: idtoken\n  with:\n    script: |\n      const coredemo = require('@actions/core');\n      let id_token = await coredemo.getIDToken(process.env.OIDC_AUDIENCE);\n      coredemo.setOutput('id_token', id_token);\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in JFrog?\n\nAssistant: Here are the recommended best practices:\n\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Viewing workflow run history?\n\nAssistant: You can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.\n\nHere's a detailed explanation:\n\n\n## Tool navigation\nRead access to the repository is required to perform these steps.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n## Viewing recent workflow runs\nTo list the recent workflow runs, use the `run list` subcommand.\n\nTo specify the maximum number of runs to return, you can use the `-L` or `--limit` flag. The default is `10`.\n\nTo only return runs for the specified workflow, you can use the `-w` or `--workflow` flag. Replace `workflow` with either the workflow name, workflow ID, or workflow file name.\n\n## Viewing details for a specific workflow run\nTo display details for a specific workflow run, use the `run view` subcommand. Replace `run-id` with the ID of the run that you want to view. If you don't specify a `run-id`, GitHub CLI returns an interactive menu for you to choose a recent run.\n\nTo include job steps in the output, use the `-v` or `--verbose` flag.\n\nTo view details for a specific job in the run, use the `-j` or `--job` flag. Replace `job-id` with the ID of the job that you want to view.\n\nTo view the full log for a job, use the `--log` flag.\n\nUse the `--exit-status` flag to exit with a non-zero status if the run failed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Viewing workflow run history?\n\nAssistant: Here are some code examples:\n\n### List recent workflow runs\n```yaml\ngh run list\n```\n\n### List recent workflow runs with limit\n```yaml\ngh run list --limit 5\n```\n\n### List runs for a specific workflow\n```yaml\ngh run list --workflow WORKFLOW\n```\n\n### View details for a specific workflow run\n```yaml\ngh run view RUN_ID\n```\n\n### View details with verbose output\n```yaml\ngh run view RUN_ID --verbose\n```\n\n### View details for a specific job\n```yaml\ngh run view --job JOB_ID\n```\n\n### View full log for a job\n```yaml\ngh run view --job JOB_ID --log\n```\n\n### Exit with non-zero status if run failed\n```yaml\ngh run view 0451 --exit-status && echo \"run pending or passed\"\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Ruby?\n\nAssistant: This guide shows you how to create a continuous integration (CI) workflow that builds and tests a Ruby application. If your CI tests pass, you may want to deploy your code or publish a gem.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a continuous integration (CI) workflow that builds and tests a Ruby application. If your CI tests pass, you may want to deploy your code or publish a gem.\n\n## Prerequisites\nWe recommend that you have a basic understanding of Ruby, YAML, workflow configuration options, and how to create a workflow file. For more information, see:\n\n- [Learn GitHub Actions](https://docs.github.com/en/actions/learn-github-actions)\n- [Ruby in 20 minutes](https://www.ruby-lang.org/en/documentation/quickstart/)\n\n## Using a Ruby workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Ruby that should work for most Ruby projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. If you already have a workflow in your repository, click **New workflow**.\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"ruby\".\n5. Filter the selection of workflows by clicking **Continuous integration**.\n6. On the \"Ruby\" workflow, click **Configure**.\n7. Edit the workflow as required. For example, change the Ruby versions you want to use.\n\nNote\n\n- This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.\n- If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions).\n\n8. Click **Commit changes**.\n\nThe `ruby.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying the Ruby version\nThe easiest way to specify a Ruby version is by using the `ruby/setup-ruby` action provided by the Ruby organization on GitHub. The action adds any supported Ruby version to `PATH` for each job run in a workflow. For more information and available Ruby versions, see [`ruby/setup-ruby`](https://github.com/ruby/setup-ruby).\n\nUsing Ruby's `ruby/setup-ruby` action is the recommended way of using Ruby with GitHub Actions because it ensures consistent behavior across different runners and different versions of Ruby.\n\nThe `setup-ruby` action takes a Ruby version as an input and configures that version on the runner.\n\n## Testing with multiple versions of Ruby\nYou can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7.\n\n## Installing dependencies with Bundler\nThe `setup-ruby` action will automatically install bundler for you. The version is determined by your `gemfile.lock` file. If no version is present in your lockfile, then the latest compatible version will be installed.\n\n## Caching dependencies\nThe `setup-ruby` actions provides a method to automatically handle the caching of your gems between runs.\n\nTo enable caching, set the following.\n\n## Matrix testing your code\nThe following example matrix tests all stable releases and head versions of MRI, JRuby and TruffleRuby on Ubuntu and macOS.\n\n## Linting your code\nThe following example installs `rubocop` and uses it to lint all files. For more information, see [RuboCop](https://github.com/rubocop-hq/rubocop). You can [configure Rubocop](https://docs.rubocop.org/rubocop/configuration.html) to decide on the specific linting rules.\n\n## Publishing Gems\nYou can configure your workflow to publish your Ruby package to any package registry you'd like when your CI tests pass.\n\nYou can store any access tokens or credentials needed to publish your package using repository secrets.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Ruby?\n\nAssistant: Here are some code examples:\n\n### Specifying Ruby version\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1' # Not needed with a .ruby-version file\n- run: bundle install\n- run: bundle exec rake\n\n```\n\n### Testing with multiple versions of Ruby\n```yaml\nstrategy:\n  matrix:\n    ruby-version: ['3.1', '3.0', '2.7']\n\n```\n\n### Full updated workflow with a matrix strategy\n```yaml\nname: Ruby CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ruby-version: ['3.1', '3.0', '2.7']\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby ${{ matrix.ruby-version }}\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby-version }}\n      - name: Install dependencies\n        run: bundle install\n      - name: Run tests\n        run: bundle exec rake\n\n```\n\n### Installing dependencies with Bundler\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1'\n- run: bundle install\n\n```\n\n### Caching dependencies\n```yaml\nsteps:\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    bundler-cache: true\n\n```\n\n### Caching without setup-ruby\n```yaml\nsteps:\n- uses: actions/cache@v4\n  with:\n    path: vendor/bundle\n    key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}\n    restore-keys: |\n      ${{ runner.os }}-gems-\n- name: Bundle install\n  run: |\n    bundle config path vendor/bundle\n    bundle install --jobs 4 --retry 3\n\n```\n\n### Matrix testing your code\n```yaml\nname: Matrix Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu, macos]\n        ruby: [2.5, 2.6, 2.7, head, debug, jruby, jruby-head, truffleruby, truffleruby-head]\n    continue-on-error: ${{ endsWith(matrix.ruby, 'head') || matrix.ruby == 'debug' }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n      - run: bundle install\n      - run: bundle exec rake\n\n```\n\n### Linting your code\n```yaml\nname: Linting\n\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n      - name: Rubocop\n        run: rubocop -f github\n\n```\n\n### Publishing Gems\n```yaml\nname: Ruby Gem\n\non:\n  workflow_dispatch:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    name: Build + Publish\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby 2.6\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n\n      - name: Publish to GPR\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:github: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push --KEY github --host https://rubygems.pkg.github.com/${OWNER} *.gem\n        env:\n          GEM_HOST_API_KEY: \"Bearer ${{secrets.GITHUB_TOKEN}}\"\n          OWNER: ${{ github.repository_owner }}\n\n      - name: Publish to RubyGems\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:rubygems_api_key: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push *.gem\n        env:\n          GEM_HOST_API_KEY: \"${{secrets.RUBYGEMS_AUTH_TOKEN}}\"\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Ruby?\n\nAssistant: Here are the recommended best practices:\n\n• Use the `ruby/setup-ruby` action to ensure consistent behavior across different runners and Ruby versions.\n• Pin actions to a commit SHA for security and stability.\n• Consider caching dependencies to speed up workflow runs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Skipping workflow runs?\n\nAssistant: You can skip workflow runs triggered by the push and pull_request events by including a command in your commit message.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can skip workflow runs triggered by the `push` and `pull_request` events by including a command in your commit message.\n\n## Skip Instructions\nWorkflows that would otherwise be triggered using `on: push` or `on: pull_request` won't be triggered if you add any of the following strings to the commit message in a push, or the HEAD commit of a pull request:\n\n- `[skip ci]`\n- `[ci skip]`\n- `[no ci]`\n- `[skip actions]`\n- `[actions skip]`\n\n## Using skip-checks Trailer\nAlternatively, you can add a `skip-checks` trailer to your commit message. The trailers section should be included at the end of your commit message and be preceded by two empty lines. If you already have other trailers in your commit message, `skip-checks` should be last. You can use either of the following:\n\n- `skip-checks:true`\n- `skip-checks: true`\n\n## Git Commit Options\nBy default, Git automatically removes consecutive newlines. To leave the commit message exactly as you entered it, use the `--cleanup=verbatim` option on your commit. For more information, see [`--cleanup=<mode>`](https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---cleanupltmodegt) in the Git documentation.\n\n## Merging Pull Requests\nYou won't be able to merge the pull request if your repository is configured to require specific checks to pass first. To allow the pull request to be merged you can push a new commit to the pull request without the skip instruction in the commit message.\n\n## Limitations of Skip Instructions\nSkip instructions only apply to the `push` and `pull_request` events. For example, adding `[skip ci]` to a commit message won't stop a workflow that's triggered `on: pull_request_target` from running.\n\nSkip instructions only apply to the workflow run(s) that would be triggered by the commit that contains the skip instructions. You can also disable a workflow from running. For more information, see [Disabling and enabling a workflow](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Skipping workflow runs?\n\nAssistant: Here are the recommended best practices:\n\n• Use skip instructions to prevent unnecessary workflow runs for specific commits.\n• Ensure that the `skip-checks` trailer is the last trailer in your commit message if you are using multiple trailers.\n• Use the `--cleanup=verbatim` option to preserve the exact format of your commit message.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Choosing where your workflow runs?\n\nAssistant: You can specify the compute environment your jobs and workflows run in.\n\nHere's a detailed explanation:\n\n\n## Choosing the runner for a job\nDefine the type of machine that will process a job in your workflow.\n\n## Running jobs in a container\nUse a container to run the steps in a job.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using labels with self-hosted runners?\n\nAssistant: You can use labels to organize your self-hosted runners based on their characteristics.\n\nHere's a detailed explanation:\n\n\n## In this article\nFor information on how to use labels to route jobs to specific types of self-hosted runners, see [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow). You can also route jobs to runners in a specific group. For more information, see [Choosing the runner for a job](https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job#targeting-runners-in-a-group).\n\nA self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:\n\n- **User repository:** You must be the repository owner.\n- **Organization:** You must be an organization owner.\n- **Organization repository:** You must be an organization owner, or have admin access to the repository.\n\nNote\n\nActions Runner Controller does not support multiple labels, to find out more please read our [Actions Runner Controller documentation](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller#using-arc-runners-in-a-workflow)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using labels with self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Programmatically assign labels\n```yaml\n./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpu\n```\n\n### Assign multiple labels\n```yaml\n./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpu,x64,linux\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using labels with self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• Labels are case-insensitive.\n• Custom labels can be removed from self-hosted runners, but they currently can't be manually deleted. Any unused labels that are not assigned to a runner will be automatically deleted within 24 hours.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Python?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your Python project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to build, test, and publish a Python package.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Python and PyPy. You don't have to install anything! For a full list of up-to-date software and the pre-installed versions of Python and PyPy, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see [Writing workflows](https://docs.github.com/en/actions/learn-github-actions).\n\nWe recommend that you have a basic understanding of Python, and pip. For more information, see:\n\n- [Getting started with Python](https://www.python.org/about/gettingstarted/)\n- [Pip package manager](https://pypi.org/project/pip/)\n\n## Using a Python workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Python that should work if your repository already contains at least one `.py` file. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. If you already have a workflow in your repository, click **New workflow**.\n\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Python application\".\n\n5. On the \"Python application\" workflow, click **Configure**.\n\n6. Edit the workflow as required. For example, change the Python version.\n\n7. Click **Commit changes**.\n\nThe `python-app.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying a Python version\nTo use a pre-installed version of Python or PyPy on a GitHub-hosted runner, use the `setup-python` action. This action finds a specific version of Python or PyPy from the tools cache on each runner and adds the necessary binaries to `PATH`, which persists for the rest of the job. If a specific version of Python is not pre-installed in the tools cache, the `setup-python` action will download and set up the appropriate version from the [`python-versions`](https://github.com/actions/python-versions) repository.\n\nUsing the `setup-python` action is the recommended way of using Python with GitHub Actions because it ensures consistent behavior across different runners and different versions of Python. If you are using a self-hosted runner, you must install Python and add it to `PATH`. For more information, see the [`setup-python` action](https://github.com/marketplace/actions/setup-python).\n\nThe table below describes the locations for the tools cache in each GitHub-hosted runner.\n\n|  | Ubuntu | Mac | Windows |\n| --- | --- | --- | --- |\n| **Tool Cache Directory** | `/opt/hostedtoolcache/*` | `/Users/runner/hostedtoolcache/*` | `C:\\hostedtoolcache\\windows\\*` |\n| **Python Tool Cache** | `/opt/hostedtoolcache/Python/*` | `/Users/runner/hostedtoolcache/Python/*` | `C:\\hostedtoolcache\\windows\\Python\\*` |\n| **PyPy Tool Cache** | `/opt/hostedtoolcache/PyPy/*` | `/Users/runner/hostedtoolcache/PyPy/*` | `C:\\hostedtoolcache\\windows\\PyPy\\*` |\n\nIf you are using a self-hosted runner, you can configure the runner to use the `setup-python` action to manage your dependencies. For more information, see [using setup-python with a self-hosted runner](https://github.com/actions/setup-python#using-setup-python-with-a-self-hosted-runner) in the `setup-python` README.\n\nGitHub supports semantic versioning syntax. For more information, see [Using semantic versioning](https://docs.npmjs.com/about-semantic-versioning#using-semantic-versioning-to-specify-update-types-your-package-can-accept) and the [Semantic versioning specification](https://semver.org/).\n\n## Using multiple Python versions\nThe following example uses a matrix for the job to set up multiple Python versions. For more information, see [Running variations of jobs in a workflow](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs).\n\n## Using a specific Python version\nYou can configure a specific version of Python. For example, 3.12. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of Python 3.\n\n## Excluding a version\nIf you specify a version of Python that is not available, `setup-python` fails with an error such as: `##[error]Version 3.7 with arch x64 not found`. The error message includes the available versions.\n\nYou can also use the `exclude` keyword in your workflow if there is a configuration of Python that you do not wish to run. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy).\n\n## Using the default Python version\nWe recommend using `setup-python` to configure the version of Python used in your workflows because it helps make your dependencies explicit. If you don't use `setup-python`, the default version of Python set in `PATH` is used in any shell when you call `python`. The default version of Python varies between GitHub-hosted runners, which may cause unexpected changes or use an older version than expected.\n\n## Installing dependencies\nGitHub-hosted runners have the pip package manager installed. You can use pip to install dependencies from the PyPI package registry before building and testing your code. For example, the YAML below installs or upgrades the `pip` package installer and the `setuptools` and `wheel` packages.\n\n## Requirements file\nAfter you update `pip`, a typical next step is to install dependencies from `requirements.txt`. For more information, see [pip](https://pip.pypa.io/en/stable/cli/pip_install/#example-requirements-file).\n\n## Caching Dependencies\nYou can cache and restore the dependencies using the [`setup-python` action](https://github.com/actions/setup-python).\n\n## Testing your code\nYou can use the same commands that you use locally to build and test your code.\n\n## Testing with pytest and pytest-cov\nThis example installs or upgrades `pytest` and `pytest-cov`. Tests are then run and output in JUnit format while code coverage results are output in Cobertura. For more information, see [JUnit](https://junit.org/junit5/) and [Cobertura](https://cobertura.github.io/cobertura/).\n\n## Using Ruff to lint and/or format code\nThe following example installs or upgrades `ruff` and uses it to lint all files. For more information, see [Ruff](https://docs.astral.sh/ruff).\n\n## Running tests with tox\nWith GitHub Actions, you can run tests with tox and spread the work across multiple jobs. You'll need to invoke tox using the `-e py` option to choose the version of Python in your `PATH`, rather than specifying a specific version. For more information, see [tox](https://tox.readthedocs.io/en/latest/).\n\n## Packaging workflow data as artifacts\nYou can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\n## Publishing to PyPI\nYou can configure your workflow to publish your Python package to PyPI once your CI tests pass. This section demonstrates how you can use GitHub Actions to upload your package to PyPI each time you publish a release. For more information, see [Managing releases in a repository](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Python?\n\nAssistant: Here are some code examples:\n\n### Using multiple Python versions\n```yaml\nname: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"pypy3.10\", \"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      # You can test your matrix by printing the current Python version\n      - name: Display Python version\n        run: python -c \"import sys; print(sys.version)\"\n```\n\n### Using a specific Python version\n```yaml\nname: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python\n        # This is the version of the action for setting up Python, not the Python version.\n        uses: actions/setup-python@v5\n        with:\n          # Semantic version range syntax or exact version of a Python version\n          python-version: '3.x'\n          # Optional - x64 or x86 architecture, defaults to x64\n          architecture: 'x64'\n      # You can test your matrix by printing the current Python version\n      - name: Display Python version\n        run: python -c \"import sys; print(sys.version)\"\n```\n\n### Excluding a version\n```yaml\nname: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n        python-version: [\"3.9\", \"3.11\", \"3.13\", \"pypy3.10\"]\n        exclude:\n          - os: macos-latest\n            python-version: \"3.11\"\n          - os: windows-latest\n            python-version: \"3.11\"\n```\n\n### Installing dependencies\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: python -m pip install --upgrade pip setuptools wheel\n```\n\n### Requirements file\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: |\n    python -m pip install --upgrade pip\n    pip install -r requirements.txt\n```\n\n### Caching Dependencies\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: actions/setup-python@v5\n  with:\n    python-version: '3.12'\n    cache: 'pip'\n- run: pip install -r requirements.txt\n- run: pip test\n```\n\n### Testing with pytest and pytest-cov\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: |\n    python -m pip install --upgrade pip\n    pip install -r requirements.txt\n- name: Test with pytest\n  run: |\n    pip install pytest pytest-cov\n    pytest tests.py --doctest-modules --junitxml=junit/test/results.xml --cov=com --cov-report=xml --cov-report=html\n```\n\n### Using Ruff to lint and/or format code\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install the code linting and formatting tool Ruff\n  run: pipx install ruff\n- name: Lint code with Ruff\n  run: ruff check --output-format=github --target-version=py39\n- name: Check code formatting with Ruff\n  run: ruff format --diff --target-version=py39\n  continue-on-error: true\n```\n\n### Running tests with tox\n```yaml\nname: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python: [\"3.9\", \"3.11\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python }}\n      - name: Install tox and any other packages\n        run: pip install tox\n      - name: Run tox\n        # Run tox using the version of Python in `PATH`\n        run: tox -e py\n```\n\n### Packaging workflow data as artifacts\n```yaml\nname: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Python # Set Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      # Install pip and pytest\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pytest\n      - name: Test with pytest\n        run: pytest tests.py --doctest-modules --junitxml=junit/test/results-${{ matrix.python-version }}.xml\n      - name: Upload pytest test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: pytest-results-${{ matrix.python-version }}\n          path: junit/test-results-${{ matrix.python-version }}.xml\n        # Use always() to always run this step to publish test results when there are test failures\n        if: ${{ always() }}\n```\n\n### Publishing to PyPI\n```yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Upload Python Package\n\non:\n  release:\n    types: [published]\n\npermissions:\n  contents: read\n\njobs:\n  release-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.x\"\n\n      - name: Build release distributions\n        run: |\n          # NOTE: put your own distribution build steps here.\n          python -m pip install build\n          python -m build\n\n      - name: Upload distributions\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  pypi-publish:\n    runs-on: ubuntu-latest\n\n    needs:\n      - release-build\n\n    permissions:\n      # IMPORTANT: this permission is mandatory for trusted publishing\n      id-token: write\n\n    # Dedicated environments with protections for publishing are strongly recommended.\n    environment:\n      name: pypi\n      # OPTIONAL: uncomment and update to include your PyPI project URL in the deployment status:\n      # url: https://pypi.org/p/YOURPROJECT\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@6f7e8d9c0b1a2c3d4e5f6a7b8c9d0e1f2a3b4c5d\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Python?\n\nAssistant: Here are the recommended best practices:\n\n• Use the `setup-python` action to ensure consistent behavior across different runners and versions of Python.\n• Familiarize yourself with YAML and GitHub Actions syntax before creating workflows.\n• Consider caching dependencies to speed up your workflow.\n• Use semantic versioning syntax for specifying Python versions.\n• Always test your workflows with multiple Python versions to ensure compatibility.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Running jobs in a container?\n\nAssistant: Use a container to run the steps in a job.\n\nHere's a detailed explanation:\n\n\n## Overview\nUse `jobs.<job_id>.container` to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.\n\nIf you do not set a `container`, all steps will run directly on the host specified by `runs-on` unless a step refers to an action configured to run in a container.\n\nNote\n\nThe default shell for `run` steps inside a container is `sh` instead of `bash`. This can be overridden with [`jobs.<job_id>.defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrun) or [`jobs.<job_id>.steps[*].shell`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell).\n\n## Example: Running a job within a container\n```hljs yaml\nname: CI\non:\n  push:\n    branches: [ main ]\njobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container:\n      image: node:18\n      env:\n        NODE_ENV: development\n      ports:\n        - 80\n      volumes:\n        - my_docker_volume:/volume_mount\n      options: --cpus 1\n    steps:\n      - name: Check for dockerenv file\n        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)\n```\n\nWhen you only specify a container image, you can omit the `image` keyword.\n\n```hljs yaml\njobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container: node:18\n```\n\n## Defining the container image\nUse `jobs.<job_id>.container.image` to define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.\n\n## Defining credentials for a container registry\nIf the image's container registry requires authentication to pull the image, you can use `jobs.<job_id>.container.credentials` to set a `map` of the `username` and `password`. The credentials are the same values that you would provide to the [`docker login`](https://docs.docker.com/engine/reference/commandline/login/) command.\n\n## Example: Defining credentials for a container registry\n```hljs yaml\ncontainer:\n  image: ghcr.io/owner/image\n  credentials:\n     username: ${{ github.actor }}\n     password: ${{ secrets.github_token }}\n```\n\n## Using environment variables with a container\nUse `jobs.<job_id>.container.env` to set a `map` of environment variables in the container.\n\n## Exposing network ports on a container\nUse `jobs.<job_id>.container.ports` to set an `array` of ports to expose on the container.\n\n## Mounting volumes in a container\nUse `jobs.<job_id>.container.volumes` to set an `array` of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.\n\nTo specify a volume, you specify the source and destination path:\n\n`<source>:<destinationPath>`.\n\nThe `<source>` is a volume name or an absolute path on the host machine, and `<destinationPath>` is an absolute path in the container.\n\n## Example: Mounting volumes in a container\n```hljs yaml\nvolumes:\n  - my_docker_volume:/volume_mount\n  - /data/my_data\n  - /source/directory:/destination/directory\n```\n\n## Setting container resource options\nUse `jobs.<job_id>.container.options` to configure additional Docker container resource options. For a list of options, see [`docker create` options](https://docs.docker.com/engine/reference/commandline/create/#options).\n\nWarning\n\nThe `--network` and `--entrypoint` options are not supported.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Running jobs in a container?\n\nAssistant: Here are some code examples:\n\n### Example: Running a job within a container\n```yaml\n```hljs yaml\nname: CI\non:\n  push:\n    branches: [ main ]\njobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container:\n      image: node:18\n      env:\n        NODE_ENV: development\n      ports:\n        - 80\n      volumes:\n        - my_docker_volume:/volume_mount\n      options: --cpus 1\n    steps:\n      - name: Check for dockerenv file\n        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)\n```\n```\n\n### Example: Defining credentials for a container registry\n```yaml\n```hljs yaml\ncontainer:\n  image: ghcr.io/owner/image\n  credentials:\n     username: ${{ github.actor }}\n     password: ${{ secrets.github_token }}\n```\n```\n\n### Example: Mounting volumes in a container\n```yaml\n```hljs yaml\nvolumes:\n  - my_docker_volume:/volume_mount\n  - /data/my_data\n  - /source/directory:/destination/directory\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Running jobs in a container?\n\nAssistant: Here are the recommended best practices:\n\n• The default shell for `run` steps inside a container is `sh` instead of `bash`. This can be overridden with `jobs.<job_id>.defaults.run` or `jobs.<job_id>.steps[*].shell`.\n• The `--network` and `--entrypoint` options are not supported.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Adding self-hosted runners?\n\nAssistant: You can add a self-hosted runner to a repository, an organization, or an enterprise.\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can add a self-hosted runner to a repository, an organization, or an enterprise.\n\nIf you are an organization or enterprise administrator, you might want to add your self-hosted runners at the organization or enterprise level. This approach makes the runner available to multiple repositories in your organization or enterprise, and also lets you to manage your runners in one place.\n\nFor information on supported operating systems for self-hosted runners, or using self-hosted runners with a proxy server, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\nWarning\n\nWe recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n\nFor more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#self-hosted-runner-security-with-public-repositories).\n\nYou can set up automation to scale the number of self-hosted runners. For more information, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners).\n\nYou can register ephemeral runners that perform a single job before the registration is cleaned up by using just-in-time runner registration. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-just-in-time-runners).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Adding self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Checking that your self-hosted runner was successfully added\n```yaml\n√ Connected to GitHub\n\n2019-10-24 05:45:56Z: Listening for Jobs\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Adding self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• We recommend that you only use self-hosted runners with private repositories.\n• On Windows, if you want to install the self-hosted runner application as a service, you must open a shell with administrator privileges.\n• We also recommend that you use `C:\\actions-runner` as the directory for the self-hosted runner application so that Windows system accounts can access the runner directory.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating workflow templates for your organization?\n\nAssistant: Learn how you can create workflow templates to help people in your team add new workflows more easily.\n\nHere's a detailed explanation:\n\n\n## Overview\nWorkflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization.\n\nGitHub provides ready-to-use workflow templates for the following high level categories:\n\n- **Deployment (CD)**. For more information, see [About continuous deployment with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/about-continuous-deployment).\n\n- **Security**. For more information, see [Configuring advanced setup for code scanning](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning#configuring-code-scanning-using-third-party-actions).\n\n- **Continuous Integration (CI)**. For more information, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).\n- **Automation**. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.\n\nNote\n\nBecause workflow templates require a public `.github` repository, they are not available for Enterprise Managed Users.\n\n## Creating a workflow template\nWorkflow templates can be created by users with write access to the organization's _public_ `.github` repository. These can then be used by organization members who have permission to create workflows.\n\nWorkflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see the [GitHub Enterprise Cloud documentation](https://docs.github.com/en/enterprise-cloud@latest/actions/using-workflows/creating-starter-workflows-for-your-organization).\n\nNote\n\nTo avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\nThis procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow.\n\n1. If it doesn't already exist, create a new _public_ repository named `.github` in your organization.\n\n2. Create a directory named `workflow-templates`.\n\n3. Create your new workflow file inside the `workflow-templates` directory.\n\nIf you need to refer to a repository's default branch, you can use the `$default-branch` placeholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch.\n\nFor example, this file named `octo-organization-ci.yml` demonstrates a basic workflow.\n\n## Next steps\nTo continue learning about GitHub Actions, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating workflow templates for your organization?\n\nAssistant: Here are some code examples:\n\n### Basic Workflow Example\n```yaml\n```yaml\nname: Octo Organization CI\n\non:\n     push:\n       branches: [ $default-branch ]\n     pull_request:\n       branches: [ $default-branch ]\n\njobs:\n     build:\n       runs-on: ubuntu-latest\n\n       steps:\n      - uses: actions/checkout@v4\n\n      - name: Run a one-line script\n        run: echo Hello from Octo Organization\n```\n```\n\n### Metadata File Example\n```yaml\n```json\n{\n       \"name\": \"Octo Organization Workflow\",\n       \"description\": \"Octo Organization CI workflow template.\",\n       \"iconName\": \"example-icon\",\n       \"categories\": [\n           \"Go\"\n       ],\n       \"filePatterns\": [\n           \"package.json$\",\n           \"^Dockerfile\",\n           \".*\\.md$\"\n       ]\n}\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating workflow templates for your organization?\n\nAssistant: Here are the recommended best practices:\n\n• To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Viewing deployment history?\n\nAssistant: View current and previous deployments for your repository.\n\nHere's a detailed explanation:\n\n\n## About deployment history\nYou can deliver deployments through GitHub Actions and environments or with the REST API and third party apps. For more information about using environments to deploy with GitHub Actions, see Managing environments for deployment. For more information about deployments with the REST API, see REST API endpoints for repositories.\n\nOn the deployments page of your repository, you can view the following aspects of your deployments.\n\n- Currently active deployments across various environments\n- Deployments filtered by environment\n- Your repository's full deployment history\n- Associated commits that triggered the deployment\n- Connected GitHub Actions workflow logs\n- The deployment URL (if one exists)\n- The source pull request and branch related to each deployment\n- Deployment statuses. For more information about deployment statuses, see REST API endpoints for deployments.\n\nBy default, the deployments page shows currently active deployments from select environments and a timeline of the latest deployments for all environments.\n\n## Viewing your repository's deployment history\n1. In the right-hand sidebar of the home page of your repository, click **Deployments**.\n2. Once you are on the \"Deployments\" page, you can view the following information about your deployment history.\n   - **To view recent deployments for a specific environment**, in the \"Environments\" section of the left sidebar, click an environment.\n   - **To pin an environment to the top of the deployment history list**, repository administrators can click  to the right of the environment. You can pin up to ten environments.\n   - **To view the commit that triggered a deployment**, in the deployment history list, click the commit message for the deployment you want to view.\n\n     Note\n\n     Deployments from commits that originate from a fork outside of the repository will not show links to the source pull request and branch related to each deployment. For more information about forks, see About forks.\n\n   - **To view the URL for a deployment**, to the right of the commit message in the deployment history list, click .\n   - **To navigate to the workflow run logs associated with a deployment**, to the right of the commit message in the deployment history list, click , then click **View logs**.\n3. Optionally, to filter the deployment history list, create a filter.\n1. Click on the **Filter** button.\n2. Click **Add a filter**.\n3. Choose a qualifier you would like to filter the deployment history by.\n4. Depending on the qualifier you chose, fill out information in the \"Operator\" and \"Value\" columns.\n5. Optionally, click **Add a filter** to add another filter.\n6. Click **Apply**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Viewing deployment history?\n\nAssistant: Here are the recommended best practices:\n\n• Deployments from commits that originate from a fork outside of the repository will not show links to the source pull request and branch related to each deployment.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing workflow runs?\n\nAssistant: You can manually interact with workflow runs to ensure they run effectively.\n\nHere's a detailed explanation:\n\n\n## Manually running a workflow\nWhen a workflow is configured to run on the `workflow_dispatch` event, you can run the workflow using the Actions tab on GitHub, GitHub CLI, or the REST API.\n\n## Re-running workflows and jobs\nYou can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.\n\n## Canceling a workflow\nYou can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.\n\n## Disabling and enabling a workflow\nYou can disable and re-enable a workflow using the GitHub UI, the REST API, or GitHub CLI.\n\n## Skipping workflow runs\nYou can skip workflow runs triggered by the `push` and `pull_request` events by including a command in your commit message.\n\n## Deleting a workflow run\nYou can delete a workflow run that has been completed, or is more than two weeks old.\n\n## Downloading workflow artifacts\nYou can download archived artifacts before they automatically expire.\n\n## Removing workflow artifacts\nYou can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.\n\n## Approving workflow runs from public forks\nWhen an outside contributor submits a pull request to a public repository, a maintainer with write access may need to approve some workflow runs.\n\n## Approving workflow runs from private forks\nWhen someone without write access submits a pull request to a private repository, a maintainer may need to approve any workflow runs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Security guides?\n\nAssistant: Security hardening and good practices for GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Security hardening for GitHub Actions\nGood security practices for using GitHub Actions features.\n\n## Using secrets in GitHub Actions\nSecrets allow you to store sensitive information in your organization, repository, or repository environments.\n\n## Automatic token authentication\nGitHub provides a token that you can use to authenticate on behalf of GitHub Actions.\n\n## Using GitHub's security features to secure your use of GitHub Actions\nGitHub has several security features that can enhance the security of the actions you consume and publish.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Choosing when your workflow runs?\n\nAssistant: You can configure workflows to run on a schedule or to run when certain events happen.\n\nHere's a detailed explanation:\n\n\n## Triggering a workflow\nHow to automatically trigger GitHub Actions workflows\n\n## Using conditions to control job execution\nPrevent a job from running unless your conditions are met.\n\n## Events that trigger workflows\nYou can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Sharing automations?\n\nAssistant: Create modular automations that you can share and reuse across GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## Avoiding duplication\nLearn how to avoid duplication in your workflows by sharing automations.\n\n## Creating actions\nExplore how to create custom actions that can be reused in workflows.\n\n## About custom actions\nUnderstand what custom actions are and how they can enhance your workflows.\n\n## Creating a Docker container action\nStep-by-step guide on creating a Docker container action.\n\n## Creating a JavaScript action\nInstructions for creating a JavaScript action.\n\n## Creating a composite action\nLearn how to create a composite action that combines multiple actions.\n\n## Metadata syntax for GitHub Actions\nDetails on the metadata syntax used in GitHub Actions.\n\n## Dockerfile support for GitHub Actions\nInformation on how Dockerfiles are supported in GitHub Actions.\n\n## Setting exit codes for actions\nGuidelines for setting exit codes in your actions.\n\n## Releasing and maintaining actions\nBest practices for releasing and maintaining your actions.\n\n## Publishing actions in GitHub Marketplace\nHow to publish your actions in the GitHub Marketplace.\n\n## Developing a third party CLI action\nInstructions for developing a third-party CLI action.\n\n## Reusing workflows\nLearn how to reuse workflows across different projects.\n\n## Creating workflow templates for your organization\nGuide on creating workflow templates tailored for your organization.\n\n## Sharing actions and workflows from your private repository\nHow to share actions and workflows from a private repository.\n\n## Sharing actions and workflows with your organization\nInstructions for sharing actions and workflows within your organization.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Administering GitHub Actions?\n\nAssistant: Manage GitHub Actions settings for your organization or enterprise.\n\nHere's a detailed explanation:\n\n\n## Usage limits, billing, and administration\nThere are usage limits for GitHub Actions workflows. Usage charges apply to repositories that go beyond the amount of free minutes and storage for a repository.\n\n## Viewing GitHub Actions metrics\nYou can view metrics to monitor where your organization or repositories use GitHub Actions and how they are performing.\n\n## Sharing workflows, secrets, and runners with your organization\nLearn how you can use organization features to collaborate with your team, by sharing workflow templates, secrets, variables, and self-hosted runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Setting exit codes for actions?\n\nAssistant: You can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.\n\nHere's a detailed explanation:\n\n\n## About exit codes\nGitHub uses the exit code to set the action's check run status, which can be `success` or `failure`.\n\n| Exit status | Check run status | Description |\n| --- | --- | --- |\n| `0` | `success` | The action completed successfully and other tasks that depend on it can begin. |\n| Nonzero value (any integer but 0) | `failure` | Any other exit code indicates the action failed. When an action fails, all concurrent actions are canceled and future actions are skipped. The check run and check suite both get a `failure` status.\n\n## Setting a failure exit code in a JavaScript action\nIf you are creating a JavaScript action, you can use the actions toolkit [`@actions/core`](https://github.com/actions/toolkit/tree/main/packages/core) package to log a message and set a failure exit code. For example:\n\n```hljs javascript\ntry {\n  // something\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n\nFor more information, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action).\n\n## Setting a failure exit code in a Docker container action\nIf you are creating a Docker container action, you can set a failure exit code in your `entrypoint.sh` script. For example:\n\n```hljs shell\nif <condition> ; then\n  echo \"Game over!\"\n  exit 1\nfi\n```\n\nFor more information, see [Creating a Docker container action](https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Setting exit codes for actions?\n\nAssistant: Here are some code examples:\n\n### Setting a failure exit code in a JavaScript action\n```yaml\ntry {\n  // something\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n\n### Setting a failure exit code in a Docker container action\n```yaml\nif <condition> ; then\n  echo \"Game over!\"\n  exit 1\nfi\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Supplemental arguments and settings?\n\nAssistant: GitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\n\nHere's a detailed explanation:\n\n\n## In this article\nThis article provides general information for configuring GitHub Actions Importer's supplemental arguments and settings, such as optional parameters, path arguments, and network settings.\n\n## Optional parameters\nGitHub Actions Importer has several optional parameters that you can use to customize the migration process.\n\n## Limiting allowed actions\nThe following options can be used to limit which actions are allowed in converted workflows. When used in combination, these options expand the list of allowed actions. If none of these options are supplied, then all actions are allowed.\n\n- `--allowed-actions` specifies a list of actions to allow in converted workflows. Wildcards are supported. Any other actions other than those provided will be disallowed.\n\nFor example:\n\n```hljs shell\n  --allowed-actions actions/checkout@v4 actions/upload-artifact@* my-org/*\n```\n\nYou can provide an empty list to disallow all actions. For example, `--allowed-actions=`.\n\n- `--allow-verified-actions` specifies that all actions from verified creators are allowed.\n\n- `--allow-github-created-actions` specifies that actions published from the `github` or `actions` organizations are allowed.\n\nFor example, such actions include `github/super-linter` and `actions/checkout`.\n\nThis option is equivalent to `--allowed-actions actions/* github/*`.\n\n## Using a credentials file for authentication\nThe `--credentials-file` parameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as `.travis.yml` or `jenkinsfile`) are stored in multiple GitHub Enterprise Server instances.\n\nA credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made.\n\nFor example:\n\n```hljs yaml\n- url: https://github.com\n  access_token: ghp_mygeneraltoken\n- url: https://github.com/specific_org/\n  access_token: ghp_myorgspecifictoken\n- url: https://jenkins.org\n  access_token: abc123\n  username: marty_mcfly\n```\n\nFor the above credentials file, GitHub Actions Importer uses the access token `ghp_mygeneraltoken` to authenticate all network requests to `https://github.com`, _unless_ the network request is for a repository in the `specific_org` organization. In that case, the `ghp_myorgspecifictoken` token is used to authenticate instead.\n\n## Alternative source code providers\nGitHub Actions Importer can automatically fetch source code from non-GitHub repositories. A credentials file can specify the `provider`, the provider URL, and the credentials needed to retrieve the source code.\n\nFor example:\n\n```hljs yaml\n- url: https://gitlab.com\n  access_token: super_secret_token\n  provider: gitlab\n```\n\nFor the above example, GitHub Actions Importer uses the token `super_secret_token` to retrieve any source code that is hosted on `https://gitlab.com`.\n\nSupported values for `provider` are:\n\n- `github` (default)\n- `gitlab`\n- `bitbucket_server`\n- `azure_devops`.\n\n## Controlling optional features\nYou can use the `--features` option to limit the features used in workflows that GitHub Actions Importer creates. This is useful for excluding newer GitHub Actions syntax from workflows when migrating to an older GitHub Enterprise Server instance. When using the `--features` option, you must specify the version of GitHub Enterprise Server that you are migrating to.\n\nFor example:\n\n```hljs shell\ngh actions-importer dry-run ... --features ghes-3.3\n```\n\nThe supported values for `--features` are:\n\n- `all` (default value)\n- `ghes-latest`\n- `ghes-<number>`, where `<number>` is the version of GitHub Enterprise Server, `3.0` or later. For example, `ghes-3.3`.\n\nYou can view the list of available feature flags by GitHub Actions Importer by running the `list-features` command. For example:\n\n```hljs shell\ngh actions-importer list-features\n```\n\nYou should see an output similar to the following.\n\n```hljs shell\nAvailable feature flags:\n\nactions/cache (disabled):\n        Control usage of actions/cache inside of workflows. Outputs a comment if not enabled.\n        GitHub Enterprise Server >= ghes-3.5 required.\n\ncomposite-actions (enabled):\n        Minimizes resulting workflow complexity through the use of composite actions. See https://docs.github.com/en/actions/creating-actions/creating-a-composite-action for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nreusable-workflows (disabled):\n        Avoid duplication by re-using existing workflows. See https://docs.github.com/en/actions/using-workflows/reusing-workflows for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nworkflow-concurrency-option-allowed (enabled):\n        Allows the use of the `concurrency` option in workflows. See https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency for more information.\n        GitHub Enterprise Server >= ghes-3.2 required.\n\nEnable features by passing --enable-features feature-1 feature-2\nDisable features by passing --disable-features feature-1 feature-2\n```\n\nTo toggle feature flags, you can use either of the following methods:\n\n- Use the `--enable-features` and `--disable-features` options when running a `gh actions-importer` command.\n- Use an environment variable for each feature flag.\n\nYou can use the `--enable-features` and `--disable-features` options to select specific features to enable or disable for the duration of the command.\nFor example, the following command disables use of `actions/cache` and `composite-actions`:\n\n```hljs shell\ngh actions-importer dry-run ... --disable-features=composite-actions actions/cache\n```\n\nYou can use the `configure --features` command to interactively configure feature flags and automatically write them to your environment:\n\n```hljs shell\n$ gh actions-importer configure --features\n\n✔ Which features would you like to configure?: actions/cache, reusable-workflows\n✔ actions/cache (disabled): Enable\n? reusable-workflows (disabled):\n› Enable\n  Disable\n```\n\n## Disabling network response caching\nBy default, GitHub Actions Importer caches responses from network requests to reduce network load and reduce run time. You can use the `--no-http-cache` option to disable the network cache. For example:\n\n```hljs shell\ngh actions-importer forecast ... --no-http-cache\n```\n\n## Path arguments\nWhen running GitHub Actions Importer, path arguments are relative to the container's disk, so absolute paths relative to the container's host machine are not supported. When GitHub Actions Importer is run, the container's `/data` directory is mounted to the directory where GitHub Actions Importer is run.\n\nFor example, the following command, when used in the `/Users/mona` directory, outputs the GitHub Actions Importer audit summary to the `/Users/mona/out` directory:\n\n```hljs shell\ngh actions-importer audit --output-dir /data/out\n```\n\n## Using a proxy\nTo access servers that are configured with a HTTP proxy, you must set the following environment variables with the proxy's URL:\n\n- `OCTOKIT_PROXY`: for any GitHub server.\n- `HTTP_PROXY` (or `HTTPS_PROXY`): for any other servers.\n\nFor example:\n\n```hljs shell\nexport OCTOKIT_PROXY=https://proxy.example.com:8443\nexport HTTPS_PROXY=$OCTOKIT_PROXY\n```\n\nIf the proxy requires authentication, a username and password must be included in the proxy URL. For example, `https://username:password@proxy.url:port`.\n\n## Disabling SSL certificate verification\nBy default, GitHub Actions Importer verifies SSL certificates when making network requests. You can disable SSL certificate verification with the `--no-ssl-verify` option. For example:\n\n```hljs shell\ngh actions-importer audit --output-dir ./output --no-ssl-verify\n```\n\n## Legal notice\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\naUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Supplemental arguments and settings?\n\nAssistant: Here are some code examples:\n\n### Limiting allowed actions example\n```yaml\n--allowed-actions actions/checkout@v4 actions/upload-artifact@* my-org/*\n```\n\n### Using a credentials file for authentication example\n```yaml\n- url: https://github.com\n  access_token: ghp_mygeneraltoken\n- url: https://github.com/specific_org/\n  access_token: ghp_myorgspecifictoken\n- url: https://jenkins.org\n  access_token: abc123\n  username: marty_mcfly\n```\n\n### Alternative source code providers example\n```yaml\n- url: https://gitlab.com\n  access_token: super_secret_token\n  provider: gitlab\n```\n\n### Controlling optional features example\n```yaml\ngh actions-importer dry-run ... --features ghes-3.3\n```\n\n### List available feature flags example\n```yaml\ngh actions-importer list-features\n```\n\n### Disabling network response caching example\n```yaml\ngh actions-importer forecast ... --no-http-cache\n```\n\n### Path arguments example\n```yaml\ngh actions-importer audit --output-dir /data/out\n```\n\n### Using a proxy example\n```yaml\nexport OCTOKIT_PROXY=https://proxy.example.com:8443\nexport HTTPS_PROXY=$OCTOKIT_PROXY\n```\n\n### Disabling SSL certificate verification example\n```yaml\ngh actions-importer audit --output-dir ./output --no-ssl-verify\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About packaging with GitHub Actions?\n\nAssistant: You can set up workflows in GitHub Actions to produce packages and upload them to GitHub Packages or another package hosting provider.\n\nHere's a detailed explanation:\n\n\n## Packaging in continuous integration workflows\nA packaging step is a common part of a continuous integration or continuous delivery workflow. Creating a package at the end of a continuous integration workflow can help during code reviews on a pull request.\n\nAfter building and testing your code, a packaging step can produce a runnable or deployable artifact. Depending on the kind of application you're building, this package can be downloaded locally for manual testing, made available for users to download, or deployed to a staging or production environment.\n\nFor example, a continuous integration workflow for a Java project may run `mvn package` to produce a JAR file. Or, a CI workflow for a Node.js application may create a Docker container.\n\nNow, when reviewing a pull request, you'll be able to look at the workflow run and download the artifact that was produced.\n\n![Screenshot of the \"Artifacts\" section of a workflow run. The name of the artifact generated by the run, \"artifact,\" is outlined in orange.](https://docs.github.com/assets/cb-13990/images/help/repository/artifact-drop-down-updated.png)\nThis will let you run the code in the pull request on your machine, which can help with debugging or testing the pull request.\n\n## Workflows for publishing packages\nIn addition to uploading packaging artifacts for testing in a continuous integration workflow, you can create workflows that build your project and publish packages to a package registry.\n\n- **Publish packages to GitHub Packages**\nGitHub Packages can act as a package hosting service for many types of packages. You can choose to share your packages with all of GitHub, or private packages to share with collaborators or an organization. For more information, see [Introduction to GitHub Packages](https://docs.github.com/en/packages/learn-github-packages/introduction-to-github-packages).\n\nYou may want to publish packages to GitHub Packages on every push into the default branch. This will allow developers on your project to always be able to run and test the latest build from the default branch easily, by installing it from GitHub Packages.\n\n- **Publish packages to a package registry:**\nFor many projects, publishing to a package registry is performed whenever a new version of a project is released. For example, a project that produces a JAR file may upload new releases to the Maven Central repository. Or, a .NET project may produce a nuget package and upload it to the NuGet Gallery.\n\nYou can automate this by creating a workflow that publishes packages to a package registry on every release creation. For more information, see [Managing releases in a repository](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository).\n\n## Further reading\n- [Publishing Node.js packages](https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About continuous deployment with GitHub Actions?\n\nAssistant: You can create custom continuous deployment (CD) workflows directly in your GitHub repository with GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About continuous deployment\n_Continuous deployment_ (CD) is the practice of using automation to publish and deploy software updates. As part of the typical CD process, the code is automatically built and tested before deployment.\n\nContinuous deployment is often coupled with continuous integration. For more information about continuous integration, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).\n\n## About continuous deployment using GitHub Actions\nYou can set up a GitHub Actions workflow to deploy your software product. To verify that your product works as expected, your workflow can build the code in your repository and run your tests before deploying.\n\nYou can configure your CD workflow to run when an event occurs (for example, when new code is pushed to the default branch of your repository), on a set schedule, manually, or when an external event occurs using the repository dispatch webhook. For more information about when your workflow can run, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).\n\nGitHub Actions provides features that give you more control over deployments. For example, you can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, or limit access to secrets. You can use concurrency to limit your CD pipeline to a maximum of one in-progress deployment and one pending deployment. For more information about these features, see [Deploying with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions) and [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\n## Using OpenID Connect to access cloud resources\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n## Workflow templates and third party actions\nGitHub offers deployment workflow templates for several popular services, such as Azure Web App. To learn how to get started using a workflow template, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows) or [browse the full list of deployment workflow templates](https://github.com/actions/starter-workflows/tree/main/deployments). You can also check out our more detailed guides for specific deployment workflows, such as [Deploying Node.js to Azure App Service](https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-azure/deploying-nodejs-to-azure-app-service).\n\nMany service providers also offer actions on GitHub Marketplace for deploying to their service. For the full list, see [GitHub Marketplace](https://github.com/marketplace?category=deployment&type=actions).\n\n## Further reading\n- [Deploying](https://docs.github.com/en/actions/use-cases-and-examples/deploying)\n- [Deploying with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions)\n- [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment)\n- [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deleting a workflow run?\n\nAssistant: You can delete a workflow run that has been completed, or is more than two weeks old. Write access to the repository is required to perform these steps.\n\nHere's a detailed explanation:\n\n\n## Steps to Delete a Workflow Run\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. To delete a workflow run, select , then click **Delete workflow run**.\n\n5. Review the confirmation prompt and click **Yes, permanently delete this workflow run**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deleting a workflow run?\n\nAssistant: Here are the recommended best practices:\n\n• Write access to the repository is required to perform these steps.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Quickstart for Actions Runner Controller?\n\nAssistant: Try out Actions Runner Controller in 5 minutes.\n\nHere's a detailed explanation:\n\n\n## Introduction\nActions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see [Operator pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) in the Kubernetes documentation.\n\nWith ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners).\n\nYou can set up ARC on Kubernetes using Helm, then create and run a workflow that uses runner scale sets. For more information about runner scale sets, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#runner-scale-set).\n\n## Prerequisites\nIn order to use ARC, ensure you have the following.\n\n- A Kubernetes cluster\n  - For a managed cloud environment, you can use AKS. For more information, see [Azure Kubernetes Service](https://azure.microsoft.com/en-us/products/kubernetes-service) in the Azure documentation.\n  - For a local setup, you can use minikube or kind. For more information, see [minikube start](https://minikube.sigs.k8s.io/docs/start/) in the minikube documentation and [kind](https://kind.sigs.k8s.io/) in the kind documentation.\n\n    Note\n\n    OpenShift clusters are currently unsupported.\n- Helm 3\n  - For more information, see [Installing Helm](https://helm.sh/docs/intro/install/) in the Helm documentation.\n- While it is not required for ARC to be deployed, we recommend ensuring you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners before deploying ARC in production workflows.\n\n## Installing Actions Runner Controller\n1. To install the operator and the custom resource definitions (CRDs) in your cluster, do the following.\n\n1. In your Helm chart, update the `NAMESPACE` value to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.\n2. Install the Helm chart.\n\nThe following example installs the latest version of the chart. To install a specific version, you can pass the `--version` argument along with the version of the chart you wish to install. You can find the list of releases in the [GitHub Container Registry](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set-controller).\n\n```hljs bash\nNAMESPACE=\"arc-systems\"\nhelm install arc \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set-controller/values.yaml) in the ARC documentation.\n\n2. To enable ARC to authenticate to GitHub, generate a personal access token (classic). For more information, see [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api#deploying-using-personal-access-token-classic-authentication).\n\n## Configuring a runner scale set\n1. To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.\n\nWhen you run the command, keep the following in mind.\n   - Update the `INSTALLATION_NAME` value carefully. You will use the installation name as the value of `runs-on` in your workflows. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on).\n   - Update the `NAMESPACE` value to the location you want the runner pods to be created.\n   - Set `GITHUB_CONFIG_URL` to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.\n   - This example command installs the latest version of the Helm chart. To install a specific version, you can pass the `--version` argument with the version of the chart you wish to install. You can find the list of releases in the [GitHub Container Registry](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set).\n\n     Note\n\n- As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\n- As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n\n```hljs bash\nINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n```\n\nFor additional Helm configuration options, see [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) in the ARC documentation.\n2. From your terminal, run the following command to check your installation.\n\n```hljs bash\nhelm list -A\n```\n\nYou should see an output similar to the following.\n\n```hljs bash\nNAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION\narc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0\narc-runner-set  arc-runners     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0\n```\n\n3. To check the manager pod, run the following command in your terminal.\n\n```hljs bash\nkubectl get pods -n arc-systems\n```\n\nIf everything was installed successfully, the status of the pods shows as **Running**.\n\n```hljs bash\nNAME                                                   READY   STATUS    RESTARTS   AGE\narc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s\narc-runner-set-754b578d-listener                       1/1     Running   0          12s\n```\n\nIf your installation was not successful, see [Troubleshooting Actions Runner Controller errors](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors) for troubleshooting information.\n\n## Using runner scale sets\nNow you will create and run a simple test workflow that uses the runner scale set runners.\n\n1. In a repository, create a workflow similar to the following example. The `runs-on` value should match the Helm installation name you used when you installed the autoscaling runner set.\n\nFor more information on adding workflows to a repository, see [Quickstart for GitHub Actions](https://docs.github.com/en/actions/quickstart#creating-your-first-workflow).\n\n```hljs yaml\nname: Actions Runner Controller Demo\non:\n     workflow_dispatch:\n\njobs:\n     Explore-GitHub-Actions:\n       # You need to use the INSTALLATION_NAME from the previous step\n       runs-on: arc-runner-set\n       steps:\n    - run: echo \"🎉 This job uses runner scale set runners!\"\n```\n\n2. Once you've added the workflow to your repository, manually trigger the workflow. For more information, see [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).\n\n3. To view the runner pods being created while the workflow is running, run the following command from your terminal.\n\n```hljs bash\nkubectl get pods -n arc-runners\n```\n\nA successful output will look similar to the following.\n\n```hljs bash\nNAMESPACE     NAME                                                  READY   STATUS    RESTARTS      AGE\narc-runners   arc-runner-set-rmrgw-runner-p9p5n                     1/1     Running   0             21s\n```\n\n## Next steps\nActions Runner Controller can help you efficiently manage your GitHub Actions runners. Ready to get started? Here are some helpful resources for taking your next steps with ARC:\n\n- For detailed authentication information, see [Authenticating to the GitHub API](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api).\n- For help using ARC runners in your workflows, see [Using Actions Runner Controller runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow).\n- For deployment information, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Quickstart for Actions Runner Controller?\n\nAssistant: Here are some code examples:\n\n### Installing Actions Runner Controller\n```yaml\nNAMESPACE=\"arc-systems\"\nhelm install arc \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controller\n```\n\n### Configuring a runner scale set\n```yaml\nINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n```\n\n### Checking installation\n```yaml\nhelm list -A\n```\n\n### Checking manager pod\n```yaml\nkubectl get pods -n arc-systems\n```\n\n### Creating a test workflow\n```yaml\nname: Actions Runner Controller Demo\non:\n     workflow_dispatch:\n\njobs:\n     Explore-GitHub-Actions:\n       # You need to use the INSTALLATION_NAME from the previous step\n       runs-on: arc-runner-set\n       steps:\n    - run: echo \"🎉 This job uses runner scale set runners!\"\n```\n\n### Viewing runner pods\n```yaml\nkubectl get pods -n arc-runners\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Quickstart for Actions Runner Controller?\n\nAssistant: Here are the recommended best practices:\n\n• As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.\n• As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Authenticating to the GitHub API?\n\nAssistant: Learn how to authenticate to the GitHub API to use Actions Runner Controller with GitHub.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can authenticate Actions Runner Controller (ARC) to the GitHub API by using a GitHub App or by using a personal access token (classic).\n\nNote\n\nYou cannot authenticate using a GitHub App for runners at the enterprise level. For more information, see Managing access to self-hosted runners using groups.\n\n## Authenticating ARC with a GitHub App\n1. Create a GitHub App that is owned by an organization. For more information, see Registering a GitHub App. Configure the GitHub App as follows.\n1. For \"Homepage URL,\" enter `https://github.com/actions/actions-runner-controller`.\n\n2. Under \"Permissions,\" click **Repository permissions**. Then use the dropdown menus to select the following access permissions.\n      - **Administration:** Read and write\n\n        Note\n\n        `Administration: Read and write` is only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope.\n\n      - **Metadata:** Read-only\n3. Under \"Permissions,\" click **Organization permissions**. Then use the dropdown menus to select the following access permissions.\n      - **Self-hosted runners:** Read and write\n2. After creating the GitHub App, on the GitHub App's page, note the value for \"App ID\". You will use this value later.\n\n3. Under \"Private keys\", click **Generate a private key**, and save the `.pem` file. You will use this key later.\n\n4. In the menu at the top-left corner of the page, click **Install app**, and next to your organization, click **Install** to install the app on your organization.\n\n5. After confirming the installation permissions on your organization, note the app installation ID. You will use it later. You can find the app installation ID on the app installation page, which has the following URL format:\n\n`https://github.com/organizations/ORGANIZATION/settings/installations/INSTALLATION_ID`\n\n6. Register the app ID, installation ID, and the downloaded `.pem` private key file from the previous steps to Kubernetes as a secret.\n\nTo create a Kubernetes secret with the values of your GitHub App, run the following command.\n\nNote\n\nCreate the secret in the same namespace where the `gha-runner-scale-set` chart is installed. In this example, the namespace is `arc-runners` to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.\n\n## Authenticating ARC with a personal access token (classic)\nARC can use personal access tokens (classic) to register self-hosted runners.\n\n1. Create a personal access token (classic) with the required scopes. The required scopes are different depending on whether you are registering runners at the repository or organization level. For more information on how to create a personal access token (classic), see Managing your personal access tokens.\n\nThe following is the list of required personal access token scopes for ARC runners.\n   - Repository runners: `repo`\n   - Organization runners: `admin:org`\n2. To create a Kubernetes secret with the value of your personal access token (classic), use the following command.\n\nNote\n\nCreate the secret in the same namespace where the `gha-runner-scale-set` chart is installed. In this example, the namespace is `arc-runners` to match the quickstart documentation. For more information, see Quickstart for Actions Runner Controller.\n\n## Legal notice\nPortions have been adapted from https://github.com/actions/actions-runner-controller/ under the Apache-2.0 license:\n\nCopyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Authenticating to the GitHub API?\n\nAssistant: Here are some code examples:\n\n### Create a Kubernetes secret for GitHub App\n```yaml\nkubectl create secret generic pre-defined-secret \\\n      --namespace=arc-runners \\\n      --from-literal=github_app_id=123456 \\\n      --from-literal=github_app_installation_id=654321 \\\n      --from-literal=github_app_private_key='-----BEGIN RSA PRIVATE KEY-----********'\n```\n\n### Create a Kubernetes secret for personal access token\n```yaml\nkubectl create secret generic pre-defined-secret \\\n      --namespace=arc-runners \\\n      --from-literal=github_token='YOUR-PAT'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Authenticating to the GitHub API?\n\nAssistant: Here are the recommended best practices:\n\n• Create the secret in the same namespace where the `gha-runner-scale-set` chart is installed. In this example, the namespace is `arc-runners` to match the quickstart documentation.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Autoscaling with self-hosted runners?\n\nAssistant: You can automatically scale your self-hosted runners in response to webhook events.\n\nHere's a detailed explanation:\n\n\n## About autoscaling\nYou can automatically increase or decrease the number of self-hosted runners in your environment in response to the webhook events you receive with a particular label. For example, you can create automation that adds a new self-hosted runner each time you receive a `workflow_job` webhook event with the `queued` activity, which notifies you that a new job is ready for processing. The webhook payload includes label data, so you can identify the type of runner the job is requesting. Once the job has finished, you can then create automation that removes the runner in response to the `workflow_job` `completed` activity.\n\n## Supported autoscaling solutions\nGitHub-hosted runners inherently autoscale based on your needs. GitHub-hosted runners can be a low-maintenance and cost-effective alternative to developing or implementing autoscaling solutions. For more information, see About GitHub-hosted runners. The actions/actions-runner-controller (ARC) project is a Kubernetes-based runner autoscaler. GitHub recommends ARC if the team deploying it has expert Kubernetes knowledge and experience. For more information, see About Actions Runner Controller and About support for Actions Runner Controller.\n\n## Using ephemeral runners for autoscaling\nGitHub recommends implementing autoscaling with ephemeral self-hosted runners; autoscaling with persistent self-hosted runners is not recommended. In certain cases, GitHub cannot guarantee that jobs are not assigned to persistent runners while they are shut down. With ephemeral runners, this can be guaranteed because GitHub only assigns one job to a runner. This approach allows you to manage your runners as ephemeral systems, since you can use automation to provide a clean environment for each job. This helps limit the exposure of any sensitive resources from previous jobs, and also helps mitigate the risk of a compromised runner receiving new jobs. Warning: The runner application log files for ephemeral runners must be forwarded to an external log storage solution for troubleshooting and diagnostic purposes. While it is not required for ephemeral runners to be deployed, GitHub recommends ensuring runner logs are forwarded and preserved externally before deploying an ephemeral runner autoscaling solution in a production environment. For more information, see Monitoring and troubleshooting self-hosted runners. To add an ephemeral runner to your environment, include the `--ephemeral` parameter when registering your runner using `config.sh`. For example:\n\n```hljs shell\n./config.sh --url https://github.com/octo-org --token example-token --ephemeral\n```\n\nThe GitHub Actions service will then automatically de-register the runner after it has processed one job. You can then create your own automation that wipes the runner after it has been de-registered. Note: If a job is labeled for a certain type of runner, but none matching that type are available, the job does not immediately fail at the time of queueing. Instead, the job will remain queued until the 24 hour timeout period expires. Alternatively, you can create ephemeral, just-in-time runners using the REST API. For more information, see REST API endpoints for self-hosted runners.\n\n## Controlling runner software updates on self-hosted runners\nBy default, self-hosted runners will automatically perform a software update whenever a new version of the runner software is available. If you use ephemeral runners in containers then this can lead to repeated software updates when a new runner version is released. Turning off automatic updates allows you to update the runner version on the container image directly on your own schedule. To turn off automatic software updates and install software updates yourself, specify the `--disableupdate` flag when registering your runner using `config.sh`. For example:\n\n```hljs shell\n./config.sh --url https://github.com/YOUR-ORGANIZATION --token EXAMPLE-TOKEN --disableupdate\n```\n\nIf you disable automatic updates, you must still update your runner version regularly. New functionality in GitHub Actions requires changes in both the GitHub Actions service and the runner software. The runner may not be able to correctly process jobs that take advantage of new features in GitHub Actions without a software update. If you disable automatic updates, you will be required to update your runner version within 30 days of a new version being made available. You may want to subscribe to notifications for releases in the actions/runner repository. For more information, see Configuring notifications. Warning: Any updates released for the software, including major, minor or patch releases, are considered as an available update. If you do not perform a software update within 30 days, the GitHub Actions service will not queue jobs to your runner. In addition, if a critical security update is required, the GitHub Actions service will not queue jobs to your runner until it has been updated.\n\n## Using webhooks for autoscaling\nYou can create your own autoscaling environment by using payloads received from the `workflow_job` webhook. This webhook is available at the repository, organization, and enterprise levels, and the payload for this event contains an `action` key that corresponds to the stages of a workflow job's life-cycle; for example when jobs are `queued`, `in_progress`, and `completed`. You must then create your own scaling automation in response to these webhook payloads. For more information about the `workflow_job` webhook, see Webhook events and payloads. To learn how to work with webhooks, see Webhooks documentation.\n\n## Authentication requirements\nYou can register and delete repository and organization self-hosted runners using the API. To authenticate to the API, your autoscaling implementation can use an access token or a GitHub app. Your access token will require the following scope: For private repositories, use an access token with the `repo` scope. For public repositories, use an access token with the `public_repo` scope. For organizations, use an access token with the `admin:org` scope. To authenticate using a GitHub App, it must be assigned the following permissions: For repositories, assign the `administration` permission. For organizations, assign the `organization_self_hosted_runners` permission. You can register and delete enterprise self-hosted runners using the API. To authenticate to the API, your autoscaling implementation can use an access token. Your access token will require the `manage_runners:enterprise` scope.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Autoscaling with self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Registering an ephemeral runner\n```yaml\n./config.sh --url https://github.com/octo-org --token example-token --ephemeral\n```\n\n### Disabling automatic updates\n```yaml\n./config.sh --url https://github.com/YOUR-ORGANIZATION --token EXAMPLE-TOKEN --disableupdate\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Autoscaling with self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• Forward runner application log files for ephemeral runners to an external log storage solution for troubleshooting and diagnostic purposes.\n• Ensure runner logs are forwarded and preserved externally before deploying an ephemeral runner autoscaling solution in a production environment.\n• Subscribe to notifications for releases in the actions/runner repository if you disable automatic updates.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Troubleshooting Actions Runner Controller errors?\n\nAssistant: Learn how to troubleshoot Actions Runner Controller errors.\n\nHere's a detailed explanation:\n\n\n## Logging\nThe Actions Runner Controller (ARC) resources, which include the controller, listener, and runners, write logs to standard output ( `stdout`). We recommend you implement a logging solution to collect and store these logs. Having logs available can help you or GitHub support with troubleshooting and debugging. For more information, see [Logging Architecture](https://kubernetes.io/docs/concepts/cluster-administration/logging/) in the Kubernetes documentation.\n\n## Resources labels\nLabels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting.\n\n## Controller pod\nThe following labels are applied to the controller pod.\n\n## Listener pod\nThe following labels are applied to listener pods.\n\n## Runner pod\nThe following labels are applied to runner pods.\n\n## Checking the logs of the controller and runner set listener\nTo check the logs of the controller pod, you can use the following command.\n\nTo check the logs of the runner set listener, you can use the following command.\n\n## Using the charts from the `master` branch\nWe recommend you use the charts from the latest release instead of the `master` branch. The `master` branch is highly unstable, and we cannot guarantee that the charts in the `master` branch will work at any given time.\n\n## Troubleshooting the listener pod\nIf the controller pod is running, but the listener pod is not, inspect the logs of the controller first and see if there are any errors. If there are no errors and the runner set listener pod is still not running, ensure the controller pod has access to the Kubernetes API server in your cluster.\n\n## Runner pods are recreated after a canceled workflow run\nOnce a workflow run is canceled, the following events happen.\n\n## Error: `Name must have up to n characters`\nARC uses the generated names of certain resources as labels for other resources. Because of this requirement, ARC limits resource names to 63 characters.\n\n## Error: `Access to the path /home/runner/_work/_tool is denied`\nYou may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume.\n\n## Legal notice\nPortions have been adapted from [https://github.com/actions/actions-runner-controller/](https://github.com/actions/actions-runner-controller/) under the Apache-2.0 license.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Troubleshooting Actions Runner Controller errors?\n\nAssistant: Here are some code examples:\n\n### Controller pod labels\n```yaml\napp.kubernetes.io/component=controller-manager\napp.kubernetes.io/instance=<controller installation name>\napp.kubernetes.io/name=gha-runner-scale-set-controller\napp.kubernetes.io/part-of=gha-runner-scale-set-controller\napp.kubernetes.io/version=<chart version>\n```\n\n### Listener pod labels\n```yaml\nactions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner-scale-set-listener\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version\n```\n\n### Runner pod labels\n```yaml\nactions-ephemeral-runner= # True | False\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version\n```\n\n### Check logs of the controller pod\n```yaml\nkubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller\n```\n\n### Check logs of the runner set listener\n```yaml\nkubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set\n```\n\n### Error: INSTALLATION FAILED\n```yaml\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:5:5): Name must have up to 45 characters\n\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:8:5): Namespace must have up to 63 characters\n```\n\n### Fix for path access denied error\n```yaml\nspec:\n      securityContext:\n          fsGroup: 123\n      containers:\n    - name: runner\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"/home/runner/run.sh\"]\n```\n\n### Init container workaround\n```yaml\ntemplate:\nspec:\n      initContainers:\n    - name: kube-init\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"sudo\", \"chown\", \"-R\", \"1001:123\", \"/home/runner/_work\"]\n    volumeMounts:\n        - name: work\n        mountPath: /home/runner/_work\n    containers:\n    - name: runner\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"/home/runner/run.sh\"]\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Troubleshooting Actions Runner Controller errors?\n\nAssistant: Here are the recommended best practices:\n\n• Implement a logging solution to collect and store logs from ARC resources.\n• Use the latest release charts instead of the master branch for stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing self-hosted runners with Actions Runner Controller?\n\nAssistant: You can host your own runners to run workflows in a highly customizable environment.\n\nHere's a detailed explanation:\n\n\n## About Actions Runner Controller\nYou can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.\n\n## Quickstart for Actions Runner Controller\nTry out Actions Runner Controller in 5 minutes.\n\n## Authenticating to the GitHub API\nLearn how to authenticate to the GitHub API to use Actions Runner Controller with GitHub.\n\n## Deploying runner scale sets with Actions Runner Controller\nLearn how to deploy runner scale sets with Actions Runner Controller, and use advanced configuration options to tailor Actions Runner Controller to your needs.\n\n## Using Actions Runner Controller runners in a workflow\nYou can use Actions Runner Controller runners in a workflow file.\n\n## Troubleshooting Actions Runner Controller errors\nLearn how to troubleshoot Actions Runner Controller errors.\n\n## About support for Actions Runner Controller\nWhat to know before you contact GitHub Support for assistance with Actions Runner Controller.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Troubleshooting workflows?\n\nAssistant: You can troubleshoot GitHub Actions workflows by using tools like debug logging.\n\nHere's a detailed explanation:\n\n\n## About troubleshooting workflows\nYou can use the tools in GitHub Actions to debug your workflows.\n\n## Using Copilot to troubleshoot workflows\nYou can use GitHub Copilot to help resolve failed workflow runs.\n\n## Enabling debug logging\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.\n\n## Working with Support for GitHub Actions\nLearn how GitHub Support can assist with GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Viewing GitHub Actions metrics?\n\nAssistant: You can view metrics to monitor where your organization or repositories use GitHub Actions and how they are performing.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nOrganization owners and users with the \"View organization Actions metrics\" permission can view organization-level metrics.\n\nUsers with the base repository role can view repository-level metrics.\n\n## About GitHub Actions metrics\nGitHub Actions metrics provide insights into how your workflows and jobs are performing at the organization and repository levels. There are two types of metrics to help you analyze different aspects of your workflows:\n\n- **GitHub Actions usage metrics:** Usage metrics help you track how many minutes your workflows and jobs consume. You can use this data to understand the cost of running Actions and ensure you're staying within your plan limits. This is especially useful for identifying high-usage workflows or repositories.\n- **GitHub Actions performance metrics:** Performance metrics focus on the efficiency and reliability of your workflows and jobs. With performance metrics, you can monitor key indicators like job run times, queue times, and failure rates to identify bottlenecks, slow-running jobs, or frequently failing workflows.\n\n## Enabling access to GitHub Actions metrics\nOrganization owners can create custom organization roles to allow people to view GitHub Actions usage metrics for their organization. To provide users with access, select the \"View organization Actions metrics\" role when creating a custom organization role. For more information, see [About custom organization roles](https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/about-custom-organization-roles).\n\n## About GitHub Actions usage metrics\nGitHub Actions usage metrics enable you to analyze how your organization is using Actions minutes. You can view usage information related to:\n\n- **Workflows**. View usage data for each workflow in your organization, and use this information to identify opportunities for optimization, such as refactoring a workflow or using a larger runner.\n- **Jobs**. See which jobs are the most resource-intensive and where they are running.\n- **Repositories**. Get a high-level snapshot of each repository in your organization and their volume of Actions minutes usage.\n- **Runtime OS**. Understand how runners for each operating system are using Actions minutes and what types of operating systems your workflows are running on most often.\n- **Runner type**. Compare how your self-hosted runners and GitHub-hosted runners use Actions minutes and the volume of workflow runs for each type of runner.\n\n## About GitHub Actions performance metrics\nNote\n\nGitHub Actions performance metrics is currently in public preview and subject to change.\n\nGitHub Actions performance metrics enables you to analyze the efficiency and reliability of your workflows. You can view performance information such as average run times, average queue times, and failure rates, related to:\n\n- **Workflows**. View performance data for each workflow in your organization, including average run time and job failures. Use this information to identify inefficient workflows and run stability.\n- **Jobs**. View performance data for each individual job to, including average run time, average queue time, and job failures. Use this information to identify inefficient jobs.\n- **Repositories**. Get a high-level snapshot of each repository in your organization and their average performance metrics.\n- **Runtime OS**. Understand how runners for each operating system are performing.\n- **Runner type**. Compare the performance of self-hosted runners and GitHub-hosted runners, to make decisions about runner types.\n\n## Understanding GitHub Actions metrics aggregation\nThe time period selection feature allows you to view GitHub Actions metrics over predefined periods, as detailed in the following table. These metrics include skipped runs and those that use zero minutes. Data is presented using Coordinated Universal Time (UTC) days.\n\n| Period | Description |\n| --- | --- |\n| Current week (Mon-Sun) | Data from Monday through the current day when the page is viewed. |\n| Current month | Data from the first of the month to the current day when the page is viewed. |\n| Last month | Data from the first day to the last day of the previous month. |\n| Last 30 days | Data from the last 30 days to when the page is viewed. |\n| Last 90 days | Data from the last 90 days to when the page is viewed. |\n| Last year | Data aggregated for the last 12 months. |\n| Custom | Data from a custom date range. The range can be up to 100 days including the start and end dates and go back as far as one year.\n\n## Viewing GitHub Actions metrics for your organization\nNote\n\nThere may be a discrepancy between the **Workflows** tab's job count and the **Jobs** tab's count due to differences in how unique jobs are identified. This does not affect the total minutes calculated.\n\n1. In the upper-right corner of GitHub, select your profile photo, then click **Your organizations**.\n\n2. Click the name of your organization.\n\n3. Under your organization name, click **Insights**.\n\n![Screenshot of the horizontal navigation bar for an organization. A tab, labeled with a graph icon and \"Insights,\" is outlined in dark orange.](https://docs.github.com/assets/cb-25805/images/help/organizations/org-nav-insights-tab.png)\n\n4. In the \"Insights\" navigation menu, click **Actions Usage Metrics** or click **Actions Performance Metrics**.\n\n5. Optionally, to select a time period to view usage metrics for, choose an option from the **Period** drop down menu at the top right of the page. For more information, see [Understanding GitHub Actions metrics aggregation](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#understanding-github-actions-metrics-aggregation).\n\n6. Click on the tab that contains the metrics you would like to view. For more information, see [About GitHub Actions usage metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#about-github-actions-usage-metrics) or [About GitHub Actions performance metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#about-github-actions-performance-metrics).\n\n7. Optionally, to filter the data displayed in a tab, create a filter.\n1. Click on the **Filter** button.\n2. Click **Add a filter**.\n3. Choose a metric you would like to filter results by.\n4. Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.\n5. Optionally, click **Add a filter** to add another filter.\n6. Click **Apply**.\n8. Optionally, to download usage metrics to a CSV file, click .\n\n## Viewing GitHub Actions metrics for your repository\nNote\n\nRepository-level metrics for GitHub Actions is in public preview and subject to change.\n\nNote\n\nThere may be a discrepancy between the **Workflows** tab's job count and the **Jobs** tab's count due to differences in how unique jobs are identified. This does not affect the total minutes calculated.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click the **Insights** tab.\n3. In the \"Insights\" navigation menu, click **Actions Usage Metrics** or click **Actions Performance Metrics**.\n4. Optionally, to select a time period to view usage metrics for, choose an option from the **Period** drop down menu at the top right of the page. For more information, see [Understanding GitHub Actions metrics aggregation](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#understanding-github-actions-metrics-aggregation).\n5. Click on the tab that contains the metrics you would like to view. For more information, see [About GitHub Actions usage metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#about-github-actions-usage-metrics) or [About GitHub Actions performance metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics#about-github-actions-performance-metrics).\n6. Optionally, to filter the data displayed in a tab, create a filter.\n1. Click on the **Filter** button.\n2. Click **Add a filter**.\n3. Choose a metric you would like to filter results by.\n4. Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.\n5. Optionally, click **Add a filter** to add another filter.\n6. Click **Apply**.\n7. Optionally, to download usage metrics to a CSV file, click .\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Viewing GitHub Actions metrics?\n\nAssistant: Here are the recommended best practices:\n\n• Organization owners and users with the \"View organization Actions metrics\" permission can view organization-level metrics.\n• Users with the base repository role can view repository-level metrics.\n• To provide users with access to GitHub Actions usage metrics, select the \"View organization Actions metrics\" role when creating a custom organization role.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using GitHub-hosted runners?\n\nAssistant: You can use GitHub's runners to execute your GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## Using GitHub-hosted runners\nYou can use GitHub's runners to execute your GitHub Actions workflows.\n\n## Using larger runners\nLarger runners can be used for more resource-intensive workflows.\n\n## Connecting to a private network with GitHub-hosted runners\nGitHub-hosted runners can connect to private networks for secure operations.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Approving workflow runs from public forks?\n\nAssistant: When an outside contributor submits a pull request to a public repository, a maintainer with write access may need to approve some workflow runs.\n\nHere's a detailed explanation:\n\n\n## About workflow runs from public forks\nAnyone can fork a public repository, and then submit a pull request that proposes changes to the repository's GitHub Actions workflows. Although workflows from forks do not have access to sensitive data such as secrets, they can be an annoyance for maintainers if they are modified for abusive purposes.\n\nTo help prevent this, workflows on pull requests to public repositories from some outside contributors will not run automatically, and might need to be approved first. Depending on the \"Approval for running fork pull request workflows from contributors\" setting, workflows on pull requests to public repositories will not run automatically and may need approval if:\n\n- The pull request is **created by** a user that requires approvals based on the selected policy.\n- The pull request event is **triggered by** a user that requires approvals based on the selected policy.\n\nBy default, all first-time contributors require approval to run workflows.\n\nWorkflows triggered by `pull_request_target` events are run in the context of the base branch. Since the base branch is considered trusted, workflows triggered by these events will always run, regardless of approval settings. For more information about the `pull_request_target` event, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target).\n\nWarning\n\nThese workflow approval policies are intended to restrict the set of users that can execute workflows in GitHub Actions runners that could lead to unexpected resource and compute consumption when using GitHub-hosted runners. If you are using self-hosted runners, potentially malicious user-controlled workflow code will execute automatically if the user is allowed to bypass approval in the set approval policy or if the pull request is approved. You must consider the risk of executing this code in your infrastructure and should review and follow the self-hosted runner security recommendations regardless of the approval settings utilized. See [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions#hardening-for-self-hosted-runners).\n\nYou can configure workflow approval requirements for a [repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-required-approval-for-workflows-from-public-forks), [organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#configuring-required-approval-for-workflows-from-public-forks), or [enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-fork-pull-requests-in-your-enterprise).\n\nWorkflow runs that have been awaiting approval for more than 30 days are automatically deleted.\n\n## Approving workflow runs on a pull request from a public fork\nMaintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval.\n\n1. Under your repository name, click **Pull requests**.\n\n\n![Screenshot of the main page of a repository. In the horizontal navigation bar, a tab, labeled \"Pull requests,\" is outlined in dark orange.](https://docs.github.com/assets/cb-51156/images/help/repository/repo-tabs-pull-requests-global-nav-update.png)\n\n2. In the list of pull requests, click the pull request you'd like to review.\n\n3. On the pull request, click **Files changed**.\n\n\n![Screenshot of the tabs for a pull request. The \"Files changed\" tab is outlined in dark orange.](https://docs.github.com/assets/cb-23571/images/help/pull_requests/pull-request-tabs-changed-files.png)\n\n4. Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the `.github/workflows/` directory that affect workflow files.\n\n5. If you are comfortable with running workflows on the pull request branch, return to the **Conversation** tab, and under \"Workflow(s) awaiting approval\", click **Approve and run**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Approving workflow runs from public forks?\n\nAssistant: Here are the recommended best practices:\n\n• Workflows triggered by `pull_request_target` events are run in the context of the base branch.\n• Review and follow the self-hosted runner security recommendations regardless of the approval settings utilized.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Notifications for workflow runs?\n\nAssistant: You can subscribe to notifications about workflow runs that you trigger.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can subscribe to notifications about workflow runs that you trigger.\n\n## Notification Types\nIf you enable email or web notifications for GitHub Actions, you'll receive a notification when any workflow runs that you've triggered have completed. The notification will include the workflow run's status (including successful, failed, neutral, and canceled runs). You can also choose to receive a notification only when a workflow run has failed.\n\n## Scheduled Workflows Notifications\nNotifications for scheduled workflows are sent to the user who initially created the workflow. If a different user updates the cron syntax in the workflow file, subsequent notifications will be sent to that user instead. If a scheduled workflow is disabled and then re-enabled, notifications will be sent to the user who re-enabled the workflow rather than the user who last modified the cron syntax.\n\n## Viewing Workflow Run Status\nYou can also see the status of workflow runs on a repository's Actions tab.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Notifications for workflow runs?\n\nAssistant: Here are the recommended best practices:\n\n• For more information about enabling or disabling notifications, see About notifications.\n• For more information, see Managing workflow runs and deployments.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About workflows?\n\nAssistant: Get a high-level overview of GitHub Actions workflows, including triggers, syntax, and advanced features.\n\nHere's a detailed explanation:\n\n\n## About workflows\nA **workflow** is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.\n\nWorkflows are defined in the `.github/workflows` directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:\n\n- Building and testing pull requests\n- Deploying your application every time a release is created\n- Adding a label whenever a new issue is opened\n\n## Workflow basics\nA workflow must contain the following basic components:\n\n1. One or more _events_ that will trigger the workflow.\n2. One or more _jobs_, each of which will execute on a _runner_ machine and run a series of one or more _steps_.\n3. Each step can either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.\n\nFor more information on these basic components, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#the-components-of-github-actions).\n\n## Triggering a workflow\nWorkflow triggers are events that cause a workflow to run. These events can be:\n\n- Events that occur in your workflow's repository\n- Events that occur outside of GitHub and trigger a `repository_dispatch` event on GitHub\n- Scheduled times\n- Manual\n\nFor example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened.\n\nFor more information, see [Triggering a workflow](https://docs.github.com/en/actions/using-workflows/triggering-a-workflow), and for a full list of events, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).\n\n## Workflow syntax\nWorkflows are defined using YAML. For the full reference of the YAML syntax for authoring workflows, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows).\n\nFor more on managing workflow runs, such as re-running, cancelling, or deleting a workflow run, see [Managing workflow runs and deployments](https://docs.github.com/en/actions/managing-workflow-runs).\n\n## Using workflow templates\nGitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects.\n\nThese workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:\n\n- CI: [Continuous Integration workflows](https://github.com/actions/starter-workflows/tree/main/ci)\n- Deployments: [Deployment workflows](https://github.com/actions/starter-workflows/tree/main/deployments)\n- Automation: [Automating workflows](https://github.com/actions/starter-workflows/tree/main/automation)\n- Code Scanning: [Code Scanning workflows](https://github.com/actions/starter-workflows/tree/main/code-scanning)\n- Pages: [Pages workflows](https://github.com/actions/starter-workflows/tree/main/pages)\n\nUse these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the [actions/starter-workflows](https://github.com/actions/starter-workflows) repository. For more information, see [Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-starter-workflows).\n\n## Advanced workflow features\nThis section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows.\n\n## Storing secrets\nIf your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub as _secrets_ and then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source.\n\n## Creating dependent jobs\nBy default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use the `needs` keyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using the `if` conditional statement.\n\n## Using a matrix\nA matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems.\n\n## Caching dependencies\nIf your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository.\n\n## Using databases and service containers\nIf your job requires a database or cache service, you can use the `services` keyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed.\n\n## Using labels to route workflows\nIf you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label of `self-hosted`. Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way.\n\n## Reusing workflows\nYou can call one workflow from within another workflow. This allows you to reuse workflows, avoiding duplication and making your workflows easier to maintain.\n\n## Security hardening for workflows\nGitHub provides security features that you can use to increase the security of your workflows. You can use GitHub's built-in features to ensure you are notified about vulnerabilities in the actions you consume, or to automate the process of keeping the actions in your workflows up to date.\n\n## Using environments\nYou can configure environments with protection rules and secrets to control the execution of jobs in a workflow. Each job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About workflows?\n\nAssistant: Here are some code examples:\n\n### Storing secrets example\n```yaml\njobs:\n  example-job:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Retrieve secret\n        env:\n          super_secret: ${{ secrets.SUPERSECRET }}\n        run: |\n          example-command \"$super_secret\"\n```\n\n### Creating dependent jobs example\n```yaml\njobs:\n  setup:\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./setup_server.sh\n  build:\n    needs: setup\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./build_server.sh\n  test:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./test_server.sh\n```\n\n### Using a matrix example\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node: [14, 16]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n```\n\n### Caching dependencies example\n```yaml\njobs:\n  example-job:\n    steps:\n      - name: Cache node modules\n        uses: actions/cache@v4\n        env:\n          cache-name: cache-node-modules\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-\n```\n\n### Using databases and service containers example\n```yaml\njobs:\n  container-job:\n    runs-on: ubuntu-latest\n    container: node:20-bookworm-slim\n    services:\n      postgres:\n        image: postgres\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install dependencies\n        run: npm ci\n      - name: Connect to PostgreSQL\n        run: node client.js\n        env:\n          POSTGRES_HOST: postgres\n          POSTGRES_PORT: 5432\n```\n\n### Using labels to route workflows example\n```yaml\njobs:\n  example-job:\n    runs-on: [self-hosted, linux, x64, gpu]\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About workflows?\n\nAssistant: Here are the recommended best practices:\n\n• Use workflow templates to get started quickly and customize them as needed.\n• Consider caching dependencies to improve performance.\n• Use secrets to manage sensitive data securely in workflows.\n• Utilize the `needs` keyword to create job dependencies when necessary.\n• Implement matrix strategies to run jobs across multiple environments efficiently.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Rust?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your Rust project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to build, test, and publish a Rust package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Rust. For a full list of up-to-date software and the preinstalled versions of Rust, see About GitHub-hosted runners.\n\n## Prerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\n\nWe recommend that you have a basic understanding of the Rust language. For more information, see Getting started with Rust.\n\n## Using a Rust workflow template\nTo get started quickly, add a workflow template to the .github/workflows directory of your repository.\n\nGitHub provides a Rust workflow template that should work for most basic Rust projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click Actions.\n\n3. If you already have a workflow in your repository, click New workflow.\n\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Rust\".\n\n5. Filter the selection of workflows by clicking Continuous integration.\n\n6. On the \"Rust - by GitHub Actions\" workflow, click Configure.\n\n7. Edit the workflow as required. For example, change the version of Rust.\n\n8. Click Commit changes.\n\nThe rust.yml workflow file is added to the .github/workflows directory of your repository.\n\n## Specifying a Rust version\nGitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, see The rustup book.\n\n## Caching dependencies\nYou can cache and restore dependencies using the Cache action. This example assumes that your repository contains a Cargo.lock file.\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code.\n\n## Publishing your package or library to crates.io\nOnce you have setup your workflow to build and test your code, you can use a secret to login to crates.io and publish your package.\n\n## Packaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Rust?\n\nAssistant: Here are some code examples:\n\n### Specifying a Rust version\n```yaml\n      - name: Temporarily modify the rust toolchain version\n        run: rustup override set nightly\n      - name: Output rust version for educational purposes\n        run: rustup --version\n\n```\n\n### Caching dependencies\n```yaml\n      - name: Cache\n      - uses: actions/cache@v4\n        with:\n          path: |\n            ~/.cargo/registry\n            ~/.cargo/git\n            target\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n```\n\n### Building and testing your code\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        BUILD_TARGET: [release] # refers to a cargo profile\n    outputs:\n      release_built: ${{ steps.set-output.outputs.release_built }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build binaries in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo build --profile ${{ matrix.BUILD_TARGET }}\n      - name: Run tests in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo test --profile ${{ matrix.BUILD_TARGET }}\n\n```\n\n### Publishing your package or library to crates.io\n```yaml\n      - name: Login into crates.io\n        run: cargo login ${{ secrets.CRATES_IO }}\n      - name: Build binaries in \"release\" mode\n        run: cargo build -r\n      - name: \"Package for crates.io\"\n        run: cargo package # publishes a package as a tarball\n      - name: \"Publish to crates.io\"\n        run: cargo publish # publishes your crate as a library that can be added as a dependency\n\n```\n\n### Packaging workflow data as artifacts\n```yaml\n      - name: Upload release artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: <my-app>\n          path: target/${{ matrix.BUILD_TARGET }}/<my-app>\n      - uses: actions/checkout@v4\n      - name: Download release artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: <my-app>\n          path: ./<my-app>\n      - name: Publish built binary to GitHub releases\n      - run: |\n          gh release create --generate-notes ./<my-app>/<my-project>#<my-app>\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Rust?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure you have a basic understanding of the Rust language before starting.\n• Use the provided Rust workflow template for quick setup.\n• Customize the workflow template as needed for your project.\n• Check the metadata in your manifest if there are errors when publishing to crates.io.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Disabling and enabling a workflow?\n\nAssistant: You can disable and re-enable a workflow using the GitHub UI, the REST API, or GitHub CLI.\n\nHere's a detailed explanation:\n\n\n## Tool navigation\n\n\n## In this article\nDisabling a workflow allows you to stop a workflow from being triggered without having to delete the file from the repo. You can easily re-enable the workflow again on GitHub.\n\nTemporarily disabling a workflow can be useful in many scenarios. These are a few examples where disabling a workflow might be helpful:\n\n- A workflow error that produces too many or wrong requests, impacting external services negatively.\n- A workflow that is not critical and is consuming too many minutes on your account.\n- A workflow that sends requests to a service that is down.\n- Workflows on a forked repository that aren't needed (for example, scheduled workflows).\n\nWarning\n\nTo prevent unnecessary workflow runs, scheduled workflows may be disabled automatically. When a public repository is forked, scheduled workflows are disabled by default. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days.\n\n## Disabling a workflow\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to disable.\n\n4. Click  to display a dropdown menu and click **Disable workflow**.\n\n## Enabling a workflow\nYou can re-enable a workflow that was previously disabled.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to enable.\n\n4. Click **Enable workflow**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Disabling and enabling a workflow?\n\nAssistant: Here are some code examples:\n\n### Disable a workflow using GitHub CLI\n```yaml\ngh workflow disable WORKFLOW\n```\n\n### Enable a workflow using GitHub CLI\n```yaml\ngh workflow enable WORKFLOW\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Disabling and enabling a workflow?\n\nAssistant: Here are the recommended best practices:\n\n• Temporarily disabling a workflow can be useful in many scenarios.\n• Scheduled workflows may be disabled automatically to prevent unnecessary workflow runs.\n• In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Adding labels to issues?\n\nAssistant: You can use GitHub Actions to automatically label issues.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis tutorial demonstrates how to use the GitHub CLI in a workflow to label newly opened or reopened issues. For example, you can add the `triage` label every time an issue is opened or reopened. Then, you can see all issues that need to be triaged by filtering for issues with the `triage` label.\n\nThe GitHub CLI allows you to easily use the GitHub API in a workflow.\n\nIn the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs.\n\n## Creating the workflow\n1. Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n\n2. In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n3. Copy the following YAML contents into your workflow file.\n\n```hljs yaml\nname: Label issues\non:\n     issues:\n       types:\n      - reopened\n      - opened\njobs:\nlabel_issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - run: gh issue edit \"$NUMBER\" --add-label \"$LABELS\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          LABELS: triage\n```\n\n4. Customize the `env` values in your workflow file:\n   - The `GH_TOKEN`, `GH_REPO`, and `NUMBER` values are automatically set using the `github` and `secrets` contexts. You do not need to change these.\n   - Change the value for `LABELS` to the list of labels that you want to add to the issue. The label(s) must exist for your repository. Separate multiple labels with commas. For example, `help wanted,good first issue`. For more information about labels, see [Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels#applying-labels-to-issues-and-pull-requests).\n5. Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n## Testing the workflow\nEvery time an issue in your repository is opened or reopened, this workflow will add the labels that you specified to the issue.\n\nTest out your workflow by creating an issue in your repository.\n\n1. Create an issue in your repository. For more information, see [Creating an issue](https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue).\n2. To see the workflow run that was triggered by creating the issue, view the history of your workflow runs. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n3. When the workflow completes, the issue that you created should have the specified labels added.\n\n## Next steps\n- To learn more about additional things you can do with the GitHub CLI, see the [GitHub CLI manual](https://cli.github.com/manual/).\n- To learn more about different events that can trigger your workflow, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#issues).\n- [Search GitHub](https://github.com/search?q=path%3A.github%2Fworkflows+gh+issue+edit&type=code) for examples of workflows using `gh issue edit`.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Adding labels to issues?\n\nAssistant: Here are some code examples:\n\n### Label issues workflow\n```yaml\nname: Label issues\non:\n     issues:\n       types:\n      - reopened\n      - opened\njobs:\nlabel_issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - run: gh issue edit \"$NUMBER\" --add-label \"$LABELS\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          LABELS: triage\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Adding labels to issues?\n\nAssistant: Here are the recommended best practices:\n\n• Customize the `LABELS` value to the list of labels you want to add to the issue, ensuring they exist in your repository.\n• Separate multiple labels with commas when specifying them in the `LABELS` environment variable.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About security hardening with OpenID Connect?\n\nAssistant: OpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\n\nHere's a detailed explanation:\n\n\n## Overview of OpenID Connect\nGitHub Actions workflows are often designed to access a cloud provider (such as AWS, Azure, GCP, or HashiCorp Vault) in order to deploy software or use the cloud's services. Before the workflow can access these resources, it will supply credentials, such as a password or token, to the cloud provider. These credentials are usually stored as a secret in GitHub, and the workflow presents this secret to the cloud provider every time it runs.\n\nHowever, using hardcoded secrets requires you to create credentials in the cloud provider and then duplicate them in GitHub as a secret.\n\nWith OpenID Connect (OIDC), you can take a different approach by configuring your workflow to request a short-lived access token directly from the cloud provider. Your cloud provider also needs to support OIDC on their end, and you must configure a trust relationship that controls which workflows are able to request the access tokens. Providers that currently support OIDC include Amazon Web Services, Azure, Google Cloud Platform, and HashiCorp Vault, among others.\n\n## Benefits of using OIDC\nBy updating your workflows to use OIDC tokens, you can adopt the following good security practices:\n\n- **No cloud secrets:** You won't need to duplicate your cloud credentials as long-lived GitHub secrets. Instead, you can configure the OIDC trust on your cloud provider, and then update your workflows to request a short-lived access token from the cloud provider through OIDC.\n- **Authentication and authorization management:** You have more granular control over how workflows can use credentials, using your cloud provider's authentication (authN) and authorization (authZ) tools to control access to cloud resources.\n- **Rotating credentials:** With OIDC, your cloud provider issues a short-lived access token that is only valid for a single job, and then automatically expires.\n\n## Getting started with OIDC\nThe following diagram gives an overview of how GitHub's OIDC provider integrates with your workflows and cloud provider:\n\n1. In your cloud provider, create an OIDC trust between your cloud role and your GitHub workflow(s) that need access to the cloud.\n2. Every time your job runs, GitHub's OIDC Provider auto-generates an OIDC token. This token contains multiple claims to establish a security-hardened and verifiable identity about the specific workflow that is trying to authenticate.\n3. You could include a step or action in your job to request this token from GitHub's OIDC provider, and present it to the cloud provider.\n4. Once the cloud provider successfully validates the claims presented in the token, it then provides a short-lived cloud access token that is available only for the duration of the job.\n\n## Configuring the OIDC trust with the cloud\nWhen you configure your cloud to trust GitHub's OIDC provider, you **must** add conditions that filter incoming requests, so that untrusted repositories or workflows can’t request access tokens for your cloud resources:\n\n- Before granting an access token, your cloud provider checks that the [`subject`](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) and other claims used to set conditions in its trust settings match those in the request's JSON Web Token (JWT). As a result, you must take care to correctly define the _subject_ and other conditions in your cloud provider.\n- The OIDC trust configuration steps and the syntax to set conditions for cloud roles (using _Subject_ and other claims) will vary depending on which cloud provider you're using. For some examples, see [Example subject claims](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#example-subject-claims).\n\n## Understanding the OIDC token\nEach job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition.\n\nThe following example OIDC token uses a subject ( `sub`) that references a job environment named `prod` in the `octo-org/octo-repo` repository.\n\n```hljs yaml\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"environment\": \"prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_visibility\": \"private\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"runner_environment\": \"github-hosted\"\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n\n```\n\nTo see all the claims supported by GitHub's OIDC provider, review the `claims_supported` entries at\n[https://token.actions.githubusercontent.com/.well-known/openid-configuration](https://token.actions.githubusercontent.com/.well-known/openid-configuration).\n\nThe token includes the standard audience, issuer, and subject claims.\n\n## Defining trust conditions on cloud roles using OIDC claims\nWith OIDC, a GitHub Actions workflow requires a token in order to access resources in your cloud provider. The workflow requests an access token from your cloud provider, which checks the details presented by the JWT. If the trust configuration in the JWT is a match, your cloud provider responds by issuing a temporary token to the workflow, which can then be used to access resources in your cloud provider. You can configure your cloud provider to only respond to requests that originate from a specific organization's repository. You can also specify additional conditions, described below.\n\nAudience and Subject claims are typically used in combination while setting conditions on the cloud role/resources to scope its access to the GitHub workflows.\n\n- **Audience:** By default, this value uses the URL of the organization or repository owner. This can be used to set a condition that only the workflows in the specific organization can access the cloud role.\n- **Subject:** By default, has a predefined format and is a concatenation of some of the key metadata about the workflow, such as the GitHub organization, repository, branch, or associated [`job`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenvironment) environment. See [Example subject claims](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#example-subject-claims) to see how the subject claim is assembled from concatenated metadata.\n\nIf you need more granular trust conditions, you can customize the subject ( `sub`) claim that's included with the JWT. For more information, see [Customizing the token claims](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-token-claims).\n\n## Example subject claims\nThe following examples demonstrate how to use \"Subject\" as a condition, and explain how the \"Subject\" is assembled from concatenated metadata. The [subject](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) uses information from the [`job` context](https://docs.github.com/en/actions/learn-github-actions/contexts#job-context), and instructs your cloud provider that access token requests may only be granted for requests from workflows running in specific branches, environments. The following sections describe some common subjects you can use.\n\n## Filtering for a specific environment\nThe subject claim includes the environment name when the job references an environment.\n\nYou can configure a subject that filters for a specific [environment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment) name. In this example, the workflow run must have originated from a job that has an environment named `Production`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n- Syntax: `repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME`\n- Example: `repo:octo-org/octo-repo:environment:Production`\n\n## Filtering for `pull_request` events\nThe subject claim includes the `pull_request` string when the workflow is triggered by a pull request event, but only if the job doesn't reference an environment.\n\nYou can configure a subject that filters for the [`pull_request`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request) event. In this example, the workflow run must have been triggered by a `pull_request` event in a repository named `octo-repo` that is owned by the `octo-org` organization:\n- Syntax: `repo:ORG-NAME/REPO-NAME:pull_request`\n- Example: `repo:octo-org/octo-repo:pull_request`\n\n## Filtering for a specific branch\nThe subject claim includes the branch name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\n\nYou can configure a subject that filters for a specific branch name. In this example, the workflow run must have originated from a branch named `demo-branch`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n- Syntax: `repo:ORG-NAME/REPO-NAME:ref:refs/heads/BRANCH-NAME`\n- Example: `repo:octo-org/octo-repo:ref:refs/heads/demo-branch`\n\n## Filtering for a specific tag\nThe subject claim includes the tag name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event.\n\nYou can create a subject that filters for specific tag. In this example, the workflow run must have originated with a tag named `demo-tag`, in a repository named `octo-repo` that is owned by the `octo-org` organization:\n- Syntax: `repo:ORG-NAME/REPO-NAME:ref:refs/tags/TAG-NAME`\n- Example: `repo:octo-org/octo-repo:ref:refs/tags/demo-tag`\n\n## Configuring the subject in your cloud provider\nTo configure the subject in your cloud provider's trust relationship, you must add the subject string to its trust configuration. The following examples demonstrate how various cloud providers can accept the same `repo:octo-org/octo-repo:ref:refs/heads/demo-branch` subject in different ways:\n\n| Cloud provider | Example |\n| --- | --- |\n| Amazon Web Services | `\"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"` |\n| Azure | `repo:octo-org/octo-repo:ref:refs/heads/demo-branch` |\n| Google Cloud Platform | `(assertion.sub=='repo:octo-org/octo-repo:ref:refs/heads/demo-branch')` |\n| HashiCorp Vault | `bound_subject=\"repo:octo-org/octo-repo:ref:refs/heads/demo-branch\"` |\n\nFor more information, see the guides listed in [Enabling OpenID Connect for your cloud provider](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#enabling-openid-connect-for-your-cloud-provider).\n\n## Updating your actions for OIDC\nTo update your custom actions to authenticate using OIDC, you can use `getIDToken()` from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see \"OIDC Token\" in the [npm package documentation](https://www.npmjs.com/package/@actions/core/v/1.6.0).\n\nYou could also use a `curl` command to request the JWT, using the following environment variables.\n\n| Variable | Description |\n| --- | --- |\n| `ACTIONS_ID_TOKEN_REQUEST_URL` | The URL for GitHub's OIDC provider. |\n| `ACTIONS_ID_TOKEN_REQUEST_TOKEN` | Bearer token for the request to the OIDC provider. |\n\nFor example:\n\n```hljs shell\ncurl -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange\"\n\n```\n\n## Adding permissions settings\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n- Using environment variables on the runner ( `ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n- Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n\n```\n\n## Customizing the token claims\nYou can security harden your OIDC configuration by customizing the claims that are included with the JWT. These customizations allow you to define more granular trust conditions on your cloud roles when allowing your workflows to access resources hosted in the cloud:\n- You can customize values for `audience` claims. See [Customizing the `audience` value](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-audience-value).\n- You can customize the format of your OIDC configuration by setting conditions on the subject ( `sub`) claim that require JWT tokens to originate from a specific repository, reusable workflow, or other source.\n- You can define granular OIDC policies by using additional OIDC token claims, such as `repository_id` and `repository_visibility`. See [Understanding the OIDC token](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#understanding-the-oidc-token).\n\n## Customizing the `audience` value\nWhen you use custom actions in your workflows, those actions may use the GitHub Actions Toolkit to enable you to supply a custom value for the `audience` claim. Some cloud providers also use this in their official login actions to enforce a default value for the `audience` claim. For example, the [GitHub Action for Azure Login](https://github.com/Azure/login/blob/master/action.yml) provides a default `aud` value of `api://AzureADTokenExchange`, or it allows you to set a custom `aud` value in your workflows. For more information on the GitHub Actions Toolkit, see the [OIDC token](https://github.com/actions/toolkit/tree/main/packages/core#oidc-token) section in the documentation.\n\n## Customizing the subject claims for an organization or repository\nTo help improve security, compliance, and standardization, you can customize the standard claims to suit your required access conditions. If your cloud provider supports conditions on subject claims, you can create a condition that checks whether the `sub` value matches the path of the reusable workflow, such as `\"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"`. The exact format will vary depending on your cloud provider's OIDC configuration. To configure the matching condition on GitHub, you can use the REST API to require that the `sub` claim must always include a specific custom claim, such as `job_workflow_ref`. You can use the REST API to apply a customization template for the OIDC subject claim; for example, you can require that the `sub` claim within the OIDC token must always include a specific custom claim, such as `job_workflow_ref`. For more information, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc).\n\n## Resetting organization template customizations\nThis example template resets the subject claims to the default format. This template effectively opts out of any organization-level customization policy.\n\nTo apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, see [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-an-organization).\n\n## Resetting repository template customizations\nAll repositories in an organization have the ability to opt in or opt out of (organization and repository-level) customized `sub` claim templates.\n\nTo opt out a repository and reset back to the default `sub` claim format, a repository administrator must use the REST API endpoint at [REST API endpoints for GitHub Actions OIDC](https://docs.github.com/en/rest/actions/oidc#set-the-customization-template-for-an-oidc-subject-claim-for-a-repository).\n\n## Example: Configuring a repository to use an organization template\nOnce an organization has created a customized `sub` claim template, the REST API can be used to programmatically apply the template to repositories within the organization. A repository administrator can configure their repository to use the template created by the administrator of their organization.\n\n## Updating your workflows for OIDC\nYou can now update your YAML workflows to use OIDC access tokens instead of secrets. Popular cloud providers have published their official login actions that make it easy for you to get started with OIDC. For more information about updating your workflows, see the cloud-specific guides listed below in [Enabling OpenID Connect for your cloud provider](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#enabling-openid-connect-for-your-cloud-provider).\n\n## Enabling OpenID Connect for Python package publishing\nYou can use a GitHub Actions workflow in a repository as a trusted publisher for a PyPI project. Using a workflow as a trusted publisher allows OIDC access tokens to be exchanged for temporary PyPI API tokens. For more information, see [Configuring OpenID Connect in PyPI](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-pypi) and [Publishing to PyPI with a Trusted Publisher](https://docs.pypi.org/trusted-publishers/) in the PyPI documentation.\n\n## Enabling OpenID Connect for your cloud provider\nTo enable and configure OIDC for your specific cloud provider, see the following guides:\n- [Configuring OpenID Connect in Amazon Web Services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)\n- [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure)\n- [Configuring OpenID Connect in Google Cloud Platform](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform)\n- [Configuring OpenID Connect in HashiCorp Vault](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault)\n\nTo enable and configure OIDC for another cloud provider, see the following guide:\n- [Configuring OpenID Connect in cloud providers](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About security hardening with OpenID Connect?\n\nAssistant: Here are some code examples:\n\n### Example OIDC token\n```yaml\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"environment\": \"prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_visibility\": \"private\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"runner_environment\": \"github-hosted\"\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About security hardening with OpenID Connect?\n\nAssistant: Here are the recommended best practices:\n\n• You must define at least one condition in your cloud provider to control how access tokens are issued, so that untrusted repositories can’t request access tokens for your cloud resources.\n• The `id-token: write` setting is required for requesting the JWT from GitHub's OIDC provider.\n• You can customize the claims included with the JWT to define more granular trust conditions on your cloud roles.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About custom actions?\n\nAssistant: Actions are individual tasks that you can combine to create jobs and customize your workflow. You can create your own actions, or use and customize actions shared by the GitHub community.\n\nHere's a detailed explanation:\n\n\n## About custom actions\nYou can create actions by writing custom code that interacts with your repository in any way you'd like, including integrating with GitHub's APIs and any publicly available third-party API. For example, an action can publish npm modules, send SMS alerts when urgent issues are created, or deploy production-ready code.\n\nYou can write your own actions to use in your workflow or share the actions you build with the GitHub community. To share actions you've built with everyone, your repository must be public.\n\nActions can run directly on a machine or in a Docker container. You can define an action's inputs, outputs, and environment variables.\n\n## Types of actions\nYou can build Docker container, JavaScript, and composite actions. Actions require a metadata file to define the inputs, outputs and main entrypoint for your action. The metadata filename must be `action.yml`. For more information, see [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions).\n\n| Type | Linux | macOS | Windows |\n| --- | --- | --- | --- |\n| Docker container |  |  |  |\n| JavaScript |  |  |  |\n| Composite Actions |  |  |  |\n\n## Docker container actions\nDocker containers package the environment with the GitHub Actions code. This creates a more consistent and reliable unit of work because the consumer of the action does not need to worry about the tools or dependencies.\n\nA Docker container allows you to use specific versions of an operating system, dependencies, tools, and code. For actions that must run in a specific environment configuration, Docker is an ideal option because you can customize the operating system and tools. Because of the latency to build and retrieve the container, Docker container actions are slower than JavaScript actions.\n\nDocker container actions can only execute on runners with a Linux operating system. Self-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#requirements-for-self-hosted-runner-machines).\n\n## JavaScript actions\nJavaScript actions can run directly on a runner machine, and separate the action code from the environment used to run the code. Using a JavaScript action simplifies the action code and executes faster than a Docker container action.\n\nTo ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image.\n\nIf you're developing a Node.js project, the GitHub Actions Toolkit provides packages that you can use in your project to speed up development. For more information, see the [actions/toolkit](https://github.com/actions/toolkit) repository.\n\n## Composite Actions\nA _composite_ action allows you to combine multiple workflow steps within one action. For example, you can use this feature to bundle together multiple run commands into an action, and then have a workflow that executes the bundled commands as a single step using that action. To see an example, check out [Creating a composite action](https://docs.github.com/en/actions/creating-actions/creating-a-composite-action).\n\n## Choosing a location for your action\nIf you're developing an action for other people to use, we recommend keeping the action in its own repository instead of bundling it with other application code. This allows you to version, track, and release the action just like any other software.\n\nStoring an action in its own repository makes it easier for the GitHub community to discover the action, narrows the scope of the code base for developers fixing issues and extending the action, and decouples the action's versioning from the versioning of other application code.\n\nIf you're building an action that you don't plan to make available to others, you can store the action's files in any location in your repository. If you plan to combine action, workflow, and application code in a single repository, we recommend storing actions in the `.github` directory. For example, `.github/actions/action-a` and `.github/actions/action-b`.\n\n## Ensuring compatibility with other platforms\nMany people access GitHub at a domain other than GitHub.com, such as GHE.com or a custom domain for GitHub Enterprise Server.\n\nTo ensure that your action is compatible with other platforms, do not use any hard-coded references to API URLs such as `https://api.github.com`. Instead, you can:\n\n- Use environment variables (see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables)):\n  - For the REST API, use the `GITHUB_API_URL` environment variable.\n  - For GraphQL, use the `GITHUB_GRAPHQL_URL` environment variable.\n- Use a toolkit such as [`@actions/github`](https://github.com/actions/toolkit/tree/main/packages/github), which can automatically set the correct URLs.\n\n## Using release management for actions\nThis section explains how you can use release management to distribute updates to your actions in a predictable way.\n\n## Good practices for release management\nIf you're developing an action for other people to use, we recommend using release management to control how you distribute updates. Users can expect an action's patch version to include necessary critical fixes and security patches, while still remaining compatible with their existing workflows. You should consider releasing a new major version whenever your changes affect compatibility.\n\nUnder this release management approach, users should not be referencing an action's default branch, as it's likely to contain the latest code and consequently might be unstable. Instead, you can recommend that your users specify a major version when using your action, and only direct them to a more specific version if they encounter issues.\n\nTo use a specific action version, users can configure their GitHub Actions workflow to target a tag, a commit's SHA, or a branch named for a release.\n\n## Using tags for release management\nWe recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions:\n\n- Create and validate a release on a release branch (such as `release/v1`) before creating the release tag (for example, `v1.0.2`).\n- Create a release using semantic versioning. For more information, see [Managing releases in a repository](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository).\n- Move the major version tag (such as `v1`, `v2`) to point to the Git ref of the current release. For more information, see [Git basics - tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging).\n- Introduce a new major version tag ( `v2`) for changes that will break existing workflows. For example, changing an action's inputs would be a breaking change.\n- Major versions can be initially released with a `beta` tag to indicate their status, for example, `v2-beta`. The `-beta` tag can then be removed when ready.\n\n## Using branches for release management\nIf you prefer to use branch names for release management, this example demonstrates how to reference a named branch:\n\n```hljs yaml\nsteps:\n    - uses: actions/javascript-action@v1-beta\n```\n\n## Using a commit's SHA for release management\nEach Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value.\n\n```hljs yaml\nsteps:\n    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f\n```\n\n## Creating a README file for your action\nWe recommend creating a README file to help people learn how to use your action. You can include this information in your `README.md`:\n\n- A detailed description of what the action does\n- Required input and output arguments\n- Optional input and output arguments\n- Secrets the action uses\n- Environment variables the action uses\n- An example of how to use your action in a workflow\n\n## Comparing GitHub Actions to GitHub Apps\nGitHub Marketplace offers tools to improve your workflow. Understanding the differences and the benefits of each tool will allow you to select the best tool for your job. For more information about building apps, see [About creating GitHub Apps](https://docs.github.com/en/apps/creating-github-apps/setting-up-a-github-app/about-creating-github-apps).\n\n## Strengths of GitHub Actions and GitHub Apps\nWhile both GitHub Actions and GitHub Apps provide ways to build automation and workflow tools, they each have strengths that make them useful in different ways.\n\nGitHub Apps:\n\n- Run persistently and can react to events quickly.\n- Work great when persistent data is needed.\n- Work best with API requests that aren't time consuming.\n- Run on a server or compute infrastructure that you provide.\n\nGitHub Actions:\n\n- Provide automation that can perform continuous integration and continuous deployment.\n- Can run directly on runner machines or in Docker containers.\n- Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code.\n- Don't require you to deploy code or serve an app.\n- Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action.\n\n## Further reading\n- [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About custom actions?\n\nAssistant: Here are some code examples:\n\n### Using a major release tag\n```yaml\nsteps:\n    - uses: actions/javascript-action@v1\n\n```\n\n### Using a specific patch release tag\n```yaml\nsteps:\n    - uses: actions/javascript-action@v1.0.1\n\n```\n\n### Using a named branch for release management\n```yaml\nsteps:\n    - uses: actions/javascript-action@v1-beta\n\n```\n\n### Using a commit's SHA for release management\n```yaml\nsteps:\n    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About custom actions?\n\nAssistant: Here are the recommended best practices:\n\n• Keep actions in their own repository for easier versioning and discovery.\n• Use semantic versioning for releases to help users manage updates.\n• Avoid hard-coded API URLs to ensure compatibility with different GitHub platforms.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Re-running workflows and jobs?\n\nAssistant: You can re-run a workflow run, all failed jobs in a workflow run, or specific jobs in a workflow run up to 30 days after its initial run.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nPeople with write permissions to a repository can re-run workflows in the repository.\n\n## About re-running workflows and jobs\nRe-running a workflow or jobs in a workflow uses the same `GITHUB_SHA` (commit SHA) and `GITHUB_REF` (Git ref) of the original event that triggered the workflow run. The workflow will use the privileges of the actor who initially triggered the workflow, not the privileges of the actor who initiated the re-run. You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run. You cannot re-run jobs in a workflow once its logs have passed their retention limits. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy). When you re-run a workflow or jobs in a workflow, you can enable debug logging for the re-run. This will enable runner diagnostic logging and step debug logging for the re-run. For more information about debug logging, see [Enabling debug logging](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/enabling-debug-logging).\n\n## Re-running all the jobs in a workflow\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. In the upper-right corner of the workflow, re-run jobs.\n   - If any jobs failed, select the **Re-run jobs** dropdown menu and click **Re-run all jobs**.\n   - If no jobs failed, click **Re-run all jobs**.\n6. Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select **Enable debug logging**.\n7. Click **Re-run jobs**.\n\n## Re-running failed jobs in a workflow\nIf any jobs in a workflow run failed, you can re-run just the jobs that failed. When you re-run failed jobs in a workflow, a new workflow run will start for all failed jobs and their dependents. Any outputs for any successful jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. In the upper-right corner of the workflow, select the **Re-run jobs** dropdown menu, and click **Re-run failed jobs**.\n\n6. Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select **Enable debug logging**.\n\n7. Click **Re-run jobs**.\n\n## Re-running a specific job in a workflow\nWhen you re-run a specific job in a workflow, a new workflow run will start for the job and any dependents. Any outputs for any other jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under the \"Jobs\" section of the left sidebar, next to the job that you want to re-run, click .\n\n6. Optionally, to enable runner diagnostic logging and step debug logging for the re-run, select **Enable debug logging**.\n\n7. Click **Re-run jobs**.\n\n## Re-running workflows and jobs with reusable workflows\nReusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow).\n\nWhen you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:\n\n- Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-all-the-jobs-in-a-workflow).\n- Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-failed-jobs-in-a-workflow). For more information about re-running a specific job in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-a-specific-job-in-a-workflow).\n\n## Reviewing previous workflow runs\nYou can view the results from your previous attempts at running a workflow. You can also view previous workflow runs using the API. For more information, see [REST API endpoints for workflow runs](https://docs.github.com/en/rest/actions/workflow-runs#get-a-workflow-run).\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. To the right of the run name, select the **Latest** dropdown menu and click a previous run attempt.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Re-running workflows and jobs?\n\nAssistant: Here are some code examples:\n\n### Re-running a failed workflow run\n```yaml\ngh run rerun RUN_ID\n```\n\n### Enabling debug logging for a re-run\n```yaml\ngh run rerun RUN_ID --debug\n```\n\n### Viewing the progress of the workflow run\n```yaml\ngh run watch\n```\n\n### Re-running failed jobs in a workflow run\n```yaml\ngh run rerun RUN_ID --failed\n```\n\n### Enabling debug logging for re-running failed jobs\n```yaml\ngh run rerun RUN_ID --failed --debug\n```\n\n### Re-running a specific job in a workflow run\n```yaml\ngh run rerun --job JOB_ID\n```\n\n### Enabling debug logging for re-running a specific job\n```yaml\ngh run rerun --job JOB_ID --debug\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Re-running workflows and jobs?\n\nAssistant: Here are the recommended best practices:\n\n• You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run.\n• You cannot re-run jobs in a workflow once its logs have passed their retention limits.\n• When re-running workflows, the same commit SHA and Git ref are used as the original run.\n• Enable debug logging for more detailed output during re-runs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About self-hosted runners?\n\nAssistant: You can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## About self-hosted runners\nA self-hosted runner is a system that you deploy and manage to execute jobs from GitHub Actions on GitHub. For more information about GitHub Actions, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\nSelf-hosted runners offer more control of hardware, operating system, and software tools than GitHub-hosted runners provide. With self-hosted runners, you can create custom hardware configurations that meet your needs with processing power or memory to run larger jobs, install software available on your local network, and choose an operating system not offered by GitHub-hosted runners. Self-hosted runners can be physical, virtual, in a container, on-premises, or in a cloud.\n\nYou can add self-hosted runners at various levels in the management hierarchy:\n\n- Repository-level runners are dedicated to a single repository.\n- Organization-level runners can process jobs for multiple repositories in an organization.\n- Enterprise-level runners can be assigned to multiple organizations in an enterprise account.\n\nYour runner machine connects to GitHub using the GitHub Actions self-hosted runner application. The GitHub Actions runner application is open source. You can contribute and file issues in the [runner](https://github.com/actions/runner) repository. When a new version is released, the runner application automatically updates itself when a job is assigned to the runner, or within a week of release if the runner hasn't been assigned any jobs.\n\nA self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.\n\nFor more information about installing and using self-hosted runners, see [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners) and [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow).\n\n## Differences between GitHub-hosted and self-hosted runners\nGitHub-hosted runners offer a quicker, simpler way to run your workflows, while self-hosted runners are a highly configurable way to run workflows in your own custom environment.\n\n**GitHub-hosted runners:**\n\n- Receive automatic updates for the operating system, preinstalled packages and tools, and the self-hosted runner application.\n- Are managed and maintained by GitHub.\n- Provide a clean instance for every job execution.\n- Use free minutes on your GitHub plan, with per-minute rates applied after surpassing the free minutes.\n\n**Self-hosted runners:**\n\n- Receive automatic updates for the self-hosted runner application only, though you may disable automatic updates of the runner. For more information about controlling runner software updates on self-hosted runners, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners#controlling-runner-software-updates-on-self-hosted-runners). You are responsible for updating the operating system and all other software.\n- Can use cloud services or local machines that you already pay for.\n- Are customizable to your hardware, operating system, software, and security requirements.\n- Don't need to have a clean instance for every job execution.\n- Are free to use with GitHub Actions, but you are responsible for the cost of maintaining your runner machines.\n\n## Requirements for self-hosted runner machines\nYou can use any machine as a self-hosted runner as long at it meets these requirements:\n\n- You can install and run the self-hosted runner application on the machine. For more information, see [Supported architectures and operating systems for self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#supported-architectures-and-operating-systems-for-self-hosted-runners).\n- The machine can communicate with GitHub Actions. For more information, see [Communication between self-hosted runners and GitHub](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github).\n- The machine has enough hardware resources for the type of workflows you plan to run. The self-hosted runner application itself only requires minimal resources.\n- If you want to run workflows that use Docker container actions or service containers, you must use a Linux machine and Docker must be installed.\n\n## Autoscaling your self-hosted runners\nYou can automatically increase or decrease the number of self-hosted runners in your environment in response to the webhook events you receive. For more information, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners).\n\n## Usage limits\nThere are some limits on GitHub Actions usage when using self-hosted runners. These limits are subject to change.\n\n- **Job execution time** - Each job in a workflow can run for up to 5 days of execution time. If a job reaches this limit, the job is terminated and fails to complete.\n- **Workflow run time** - Each workflow run is limited to 35 days. If a workflow run reaches this limit, the workflow run is cancelled. This period includes execution duration, and time spent on waiting and approval.\n- **Job queue time** - Each job for self-hosted runners that has been queued for at least 24 hours will be canceled. The actual time in queue can reach up to 48 hours before cancellation occurs. If a self-hosted runner does not start executing the job within this limit, the job is terminated and fails to complete.\n- **API requests** - You can execute up to 1,000 requests to the GitHub API in an hour across all actions within a repository. If requests are exceeded, additional API calls will fail which might cause jobs to fail.\n- **Job matrix** - A job matrix can generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.\n- **Workflow run queue** - No more than 500 workflow runs can be queued in a 10 second interval per repository. If a workflow run reaches this limit, the workflow run is terminated and fails to complete.\n- **Registering self-hosted runners** - You can have a maximum of 10,000 self-hosted runners in one runner group. If this limit is reached, adding a new runner will not be possible.\n\n## Workflow continuity for self-hosted runners\nIf GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed.\n\n## Supported architectures and operating systems for self-hosted runners\nThe following operating systems are supported for the self-hosted runner application.\n\n### Linux\n- Red Hat Enterprise Linux 8 or later\n- CentOS 8 or later\n- Oracle Linux 8 or later\n- Fedora 29 or later\n- Debian 10 or later\n- Ubuntu 20.04 or later\n- Linux Mint 20 or later\n- openSUSE 15.2 or later\n- SUSE Enterprise Linux (SLES) 15 SP2 or later\n\n### Windows\n- Windows 10 64-bit\n- Windows 11 64-bit\n- Windows Server 2016 64-bit\n- Windows Server 2019 64-bit\n- Windows Server 2022 64-bit\n\n### macOS\n- macOS 11.0 (Big Sur) or later\n\n### Architectures\nThe following processor architectures are supported for the self-hosted runner application.\n- `x64` - Linux, macOS, Windows.\n- `ARM64` - Linux, macOS, Windows (currently in public preview).\n- `ARM32` - Linux.\n\n## Communication between self-hosted runners and GitHub\nThe self-hosted runner connects to GitHub to receive job assignments and to download new versions of the runner application. The self-hosted runner uses an HTTPS long poll that opens a connection to GitHub for 50 seconds, and if no response is received, it then times out and creates a new long poll. The application must be running on the machine to accept and run GitHub Actions jobs.\n\nThe connection between self-hosted runners and GitHub is over HTTPS (port 443).\n\nSince the self-hosted runner opens a connection to GitHub, you do not need to allow GitHub to make inbound connections to your self-hosted runner.\n\nYou must ensure that the machine has the appropriate network access with at least 70 kilobits per second upload and download speed to communicate with the GitHub hosts listed below. Some hosts are required for essential runner operations, while other hosts are only required for certain functionality.\n\nYou can use the REST API to get meta information about GitHub, including the IP addresses of GitHub services. For more information about the domains and IP addresses used, see [REST API endpoints for meta data](https://docs.github.com/en/rest/meta/meta).\n\nNote\nSome of the domains listed are configured using CNAME records. Some firewalls might require you to add rules recursively for all CNAME records. Note that the CNAME records might change in the future, and that only the domains listed will remain constant.\n\n**Needed for essential operations:**\n```shell\ngithub.com\napi.github.com\n*.actions.githubusercontent.com\n```\n\n**Needed for downloading actions:**\n```shell\ncodeload.github.com\npkg.actions.githubusercontent.com\n```\n\n**Needed for publishing immutable actions:**\n```shell\nghcr.io\n```\n\n**Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:**\n```shell\nresults-receiver.actions.githubusercontent.com\n*.blob.core.windows.net\n```\n\n**Needed for runner version updates:**\n```shell\nobjects.githubusercontent.com\nobjects-origin.githubusercontent.com\ngithub-releases.githubusercontent.com\ngithub-registry-files.githubusercontent.com\n```\n\n**Needed for retrieving OIDC tokens:**\n```shell\n*.actions.githubusercontent.com\n```\n\n**Needed for downloading or publishing packages or containers to GitHub Packages:**\n```shell\n*.pkg.github.com\npkg-containers.githubusercontent.com\nghcr.io\n```\n\n**Needed for Git Large File Storage**\n```shell\ngithub-cloud.githubusercontent.com\ngithub-cloud.s3.amazonaws.com\n```\n\n**Needed for jobs for Dependabot updates**\n```shell\ndependabot-actions.githubapp.com\n```\n\nIn addition, your workflow may require access to other network resources.\n\nIf you use an IP address allow list for your GitHub organization or enterprise account, you must add your self-hosted runner's IP address to the allow list. For more information, see [Managing allowed IP addresses for your organization](https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-allowed-ip-addresses-for-your-organization#using-github-actions-with-an-ip-allow-list) or [Enforcing policies for security settings in your enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-security-settings-in-your-enterprise) in the GitHub Enterprise Cloud documentation.\n\nYou can also use self-hosted runners with a proxy server. For more information, see [Using a proxy server with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-a-proxy-server-with-self-hosted-runners).\n\nFor more information about troubleshooting common network connectivity issues, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners#troubleshooting-network-connectivity).\n\n## Self-hosted runner security\nWe recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n\nThis is not an issue with GitHub-hosted runners because each GitHub-hosted runner is always a clean isolated virtual machine, and it is destroyed at the end of the job execution.\n\nUntrusted workflows running on your self-hosted runner pose significant security risks for your machine and network environment, especially if your machine persists its environment between jobs. Some of the risks include:\n\n- Malicious programs running on the machine.\n- Escaping the machine's runner sandbox.\n- Exposing access to the machine's network environment.\n- Persisting unwanted or dangerous data on the machine.\n\nFor more information about security hardening for self-hosted runners, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#hardening-for-self-hosted-runners).\n\n## Restricting the use of self-hosted runners\nOrganization owners can choose which repositories are allowed to create repository-level self-hosted runners.\n\nFor more information, see [Disabling or limiting GitHub Actions for your organization](https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#limiting-the-use-of-self-hosted-runners).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About self-hosted runners?\n\nAssistant: Here are some code examples:\n\n### Needed for essential operations\n```yaml\n```shell\ngithub.com\napi.github.com\n*.actions.githubusercontent.com\n```\n```\n\n### Needed for downloading actions\n```yaml\n```shell\ncodeload.github.com\npkg.actions.githubusercontent.com\n```\n```\n\n### Needed for publishing immutable actions\n```yaml\n```shell\nghcr.io\n```\n```\n\n### Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches\n```yaml\n```shell\nresults-receiver.actions.githubusercontent.com\n*.blob.core.windows.net\n```\n```\n\n### Needed for runner version updates\n```yaml\n```shell\nobjects.githubusercontent.com\nobjects-origin.githubusercontent.com\ngithub-releases.githubusercontent.com\ngithub-registry-files.githubusercontent.com\n```\n```\n\n### Needed for retrieving OIDC tokens\n```yaml\n```shell\n*.actions.githubusercontent.com\n```\n```\n\n### Needed for downloading or publishing packages or containers to GitHub Packages\n```yaml\n```shell\n*.pkg.github.com\npkg-containers.githubusercontent.com\nghcr.io\n```\n```\n\n### Needed for Git Large File Storage\n```yaml\n```shell\ngithub-cloud.githubusercontent.com\ngithub-cloud.s3.amazonaws.com\n```\n```\n\n### Needed for jobs for Dependabot updates\n```yaml\n```shell\ndependabot-actions.githubapp.com\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About self-hosted runners?\n\nAssistant: Here are the recommended best practices:\n\n• We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n• If you use an IP address allow list for your GitHub organization or enterprise account, you must add your self-hosted runner's IP address to the allow list.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using GitHub Actions Importer to automate migrations?\n\nAssistant: Learn how to use GitHub Actions Importer to migrate your CI/CD workflows to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Automating migration with GitHub Actions Importer\nUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.\n\n## Extending GitHub Actions Importer with custom transformers\nGitHub Actions Importer offers the ability to extend its built-in mapping.\n\n## Supplemental arguments and settings\nGitHub Actions Importer has several supplemental arguments and settings to tailor the migration process to your needs.\n\n## Migrating from Azure DevOps with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Azure DevOps pipelines to GitHub Actions.\n\n## Migrating from Bamboo with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Bamboo pipelines to GitHub Actions.\n\n## Migrating from Bitbucket Pipelines with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Bitbucket pipelines to GitHub Actions.\n\n## Migrating from CircleCI with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your CircleCI pipelines to GitHub Actions.\n\n## Migrating from GitLab with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your GitLab pipelines to GitHub Actions.\n\n## Migrating from Jenkins with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Jenkins pipelines to GitHub Actions.\n\n## Migrating from Travis CI with GitHub Actions Importer\nLearn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Releasing and maintaining actions?\n\nAssistant: You can leverage automation and open source best practices to release and maintain actions.\n\nHere's a detailed explanation:\n\n\n## Introduction\nAfter you create an action, you'll want to continue releasing new features while working with community contributions. This tutorial describes an example process you can follow to release and maintain actions in open source. The example:\n\n- Leverages GitHub Actions for continuous integration, dependency updates, release management, and task automation.\n- Provides confidence through automated tests and build badges.\n- Indicates how the action can be used, ideally as part of a broader workflow.\n- Signal what type of community contributions you welcome. (For example, issues, pull requests, or vulnerability reports.)\n\nFor an applied example of this process, see actions/javascript-action.\n\n## Developing and releasing actions\nIn this section, we discuss an example process for developing and releasing actions and show how to use GitHub Actions to automate the process.\n\n## About JavaScript actions\nJavaScript actions are Node.js repositories with metadata. However, JavaScript actions have additional properties compared to traditional Node.js projects:\n\n- Dependent packages are committed alongside the code, typically in a compiled and minified form. This means that automated builds and secure community contributions are important.\n\n- Tagged releases can be published directly to GitHub Marketplace and consumed by workflows across GitHub.\n\n- Many actions make use of GitHub's APIs and third party APIs, so we encourage robust end-to-end testing.\n\n## Setting up GitHub Actions workflows\nTo support the developer process in the next section, add two GitHub Actions workflows to your repository:\n\n1. Add a workflow that triggers when a commit is pushed to a feature branch or to `main` or when a pull request is created. Configure the workflow to run your unit and integration tests. For an example, see this workflow.\n2. Add a workflow that triggers when a release is published or edited. Configure the workflow to ensure semantic tags are in place. You can use an action like JasonEtco/build-and-tag-action to compile and bundle the JavaScript and metadata file and force push semantic major, minor, and patch tags. For more information about semantic tags, see About semantic versioning.\n\n## Example developer process\nHere is an example process that you can follow to automatically run tests, create a release and publish to GitHub Marketplace, and publish your action.\n\n1. Do feature work in branches per GitHub flow. For more information, see GitHub flow.\n   - Whenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.\n2. Create pull requests to the `main` branch to initiate discussion and review, merging when ready.\n   - When a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.\n\n   - **Note:** for security reasons, workflows triggered by `pull_request` from forks have restricted `GITHUB_TOKEN` permissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like a manual trigger or a `pull_request_target`. For more information, see Events that trigger workflows.\n3. Create a semantically tagged release. You may also publish to GitHub Marketplace with a simple checkbox. For more information, see Managing releases in a repository and Publishing actions in GitHub Marketplace.\n   - When a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.\n\n   - We recommend creating releases using semantically versioned tags – for example, `v1.1.3` – and keeping major ( `v1`) and minor ( `v1.1`) tags current to the latest appropriate commit. For more information, see About custom actions and About semantic versioning.\n\n## Results\nUnlike some other automated release management strategies, this process intentionally does not commit dependencies to the `main` branch, only to the tagged release commits. By doing so, you encourage users of your action to reference named tags or `sha` s, and you help ensure the security of third party pull requests by doing the build yourself during a release.\n\nUsing semantic releases means that the users of your actions can pin their workflows to a version and know that they might continue to receive the latest stable, non-breaking features, depending on their comfort level.\n\n## Working with the community\nGitHub provides tools and guides to help you work with the open source community. Here are a few tools we recommend setting up for healthy bidirectional communication. By providing the following signals to the community, you encourage others to use, modify, and contribute to your action:\n\n- Maintain a `README` with plenty of usage examples and guidance. For more information, see About READMEs.\n- Include a workflow status badge in your `README` file. For more information, see Adding a workflow status badge. Also visit shields.io to learn about other badges that you can add.\n- Add community health files like `CODE_OF_CONDUCT`, `CONTRIBUTING`, and `SECURITY`. For more information, see Creating a default community health file.\n- Keep issues current by utilizing actions like actions/stale.\n- Use GitHub's security features to communicate about vulnerabilities and how to fix them.\n\n## Further reading\nExamples where similar patterns are employed include:\n\n- github/super-linter\n- octokit/request-action\n- actions/javascript-action.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Releasing and maintaining actions?\n\nAssistant: Here are some code examples:\n\n### GitHub Actions workflow example\n```yaml\n# This is an example workflow file\nname: CI\n\non:\n  push:\n    branches:\n      - main\n      - feature/*\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n      - name: Run tests\n        run: npm test\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Releasing and maintaining actions?\n\nAssistant: Here are the recommended best practices:\n\n• Maintain a `README` with plenty of usage examples and guidance.\n• Include a workflow status badge in your `README` file.\n• Add community health files like `CODE_OF_CONDUCT`, `CONTRIBUTING`, and `SECURITY`.\n• Keep issues current by utilizing actions like actions/stale.\n• Use GitHub's security features to communicate about vulnerabilities and how to fix them.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Publishing packages?\n\nAssistant: You can automatically publish packages using GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About packaging with GitHub Actions\nYou can set up workflows in GitHub Actions to produce packages and upload them to GitHub Packages or another package hosting provider.\n\n## Publishing Docker images\nYou can publish Docker images to a registry, such as Docker Hub or GitHub Packages, as part of your continuous integration (CI) workflow.\n\n## Publishing Java packages with Gradle\nYou can use Gradle to publish Java packages to a registry as part of your continuous integration (CI) workflow.\n\n## Publishing Java packages with Maven\nYou can use Maven to publish Java packages to a registry as part of your continuous integration (CI) workflow.\n\n## Publishing Node.js packages\nYou can publish Node.js packages to a registry as part of your continuous integration (CI) workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying to Google Kubernetes Engine?\n\nAssistant: You can deploy to Google Kubernetes Engine as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build a containerized application, push it to Google Container Registry (GCR), and deploy it to Google Kubernetes Engine (GKE) when there is a push to the `main` branch.\n\nGKE is a managed Kubernetes cluster service from Google Cloud that can host your containerized workloads in the cloud or in your own datacenter. For more information, see [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine).\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n## Prerequisites\nBefore you proceed with creating the workflow, you will need to complete the following steps for your Kubernetes project. This guide assumes the root of your project already has a `Dockerfile` and a Kubernetes Deployment configuration file.\n\n## Creating a GKE cluster\nTo create the GKE cluster, you will first need to authenticate using the `gcloud` CLI. For more information on this step, see the following articles:\n\n- [`gcloud auth login`](https://cloud.google.com/sdk/gcloud/reference/auth/login)\n- [`gcloud` CLI](https://cloud.google.com/sdk/gcloud/reference)\n- [`gcloud` CLI and Cloud SDK](https://cloud.google.com/sdk/gcloud#the_gcloud_cli_and_cloud_sdk)\n\nFor example:\n\n```hljs shell\n$ gcloud container clusters create $GKE_CLUSTER \\\n\\t--project=$GKE_PROJECT \\\n\\t--zone=$GKE_ZONE\n```\n\n## Enabling the APIs\nEnable the Kubernetes Engine and Container Registry APIs. For example:\n\n```hljs shell\n$ gcloud services enable \\\ncontainerregistry.googleapis.com \\\ncontainer.googleapis.com\n```\n\n## Configuring a service account and storing its credentials\nThis procedure demonstrates how to create the service account for your GKE integration. It explains how to create the account, add roles to it, retrieve its keys, and store them as a base64-encoded encrypted repository secret named `GKE_SA_KEY`.\n\n1. Create a new service account:\n\n```hljs shell\ngcloud iam service-accounts create $SA_NAME\n```\n\n2. Retrieve the email address of the service account you just created:\n\n```hljs shell\ngcloud iam service-accounts list\n```\n\n3. Add roles to the service account.\n\nNote\n\nApply more restrictive roles to suit your requirements.\n\n```hljs shell\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/container.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/storage.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/container.clusterViewer\n```\n\n4. Download the JSON keyfile for the service account:\n\n```hljs shell\ngcloud iam service-accounts keys create key.json --iam-account=$SA_EMAIL\n```\n\n5. Store the service account key as a secret named `GKE_SA_KEY`:\n\n```hljs shell\nexport GKE_SA_KEY=$(cat key.json | base64)\n```\n\nFor more information about how to store a secret, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\n## Storing your project name\nStore the name of your project as a secret named `GKE_PROJECT`. For more information about how to store a secret, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\n## (Optional) Configuring kustomize\nKustomize is an optional tool used for managing YAML specs. After creating a `kustomization` file, the workflow below can be used to dynamically set fields of the image and pipe in the result to `kubectl`. For more information, see [kustomize usage](https://github.com/kubernetes-sigs/kustomize#usage).\n\n## (Optional) Configure a deployment environment\nEnvironments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build a container image and push it to GCR. It then uses the Kubernetes tools (such as `kubectl` and `kustomize`) to pull the image into the cluster deployment.\n\nUnder the `env` key, change the value of `GKE_CLUSTER` to the name of your cluster, `GKE_ZONE` to your cluster zone, `DEPLOYMENT_NAME` to the name of your deployment, and `IMAGE` to the name of your image.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and Deploy to GKE\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  PROJECT_ID: ${{ secrets.GKE_PROJECT }}\n  GKE_CLUSTER: cluster-1    # Add your cluster name here.\n  GKE_ZONE: us-central1-c   # Add your cluster zone here.\n  DEPLOYMENT_NAME: gke-test # Add your deployment name here.\n  IMAGE: static-site\n\njobs:\n  setup-build-publish-deploy:\n    name: Setup, Build, Publish, and Deploy\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    # Setup gcloud CLI\n    - uses: google-github-actions/setup-gcloud@1bee7de035d65ec5da40a31f8589e240eba8fde5\n      with:\n        service_account_key: ${{ secrets.GKE_SA_KEY }}\n        project_id: ${{ secrets.GKE_PROJECT }}\n\n    # Configure Docker to use the gcloud command-line tool as a credential\n    # helper for authentication\n    - run: |-\n        gcloud --quiet auth configure-docker\n\n    # Get the GKE credentials so we can deploy to the cluster\n    - uses: google-github-actions/get-gke-credentials@db150f2cc60d1716e61922b832eae71d2a45938f\n      with:\n        cluster_name: ${{ env.GKE_CLUSTER }}\n        location: ${{ env.GKE_ZONE }}\n        credentials: ${{ secrets.GKE_SA_KEY }}\n\n    # Build the Docker image\n    - name: Build\n      run: |-\n        docker build \\\n          --tag \"gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\" \\\n          --build-arg GITHUB_SHA=\"$GITHUB_SHA\" \\\n          --build-arg GITHUB_REF=\"$GITHUB_REF\" \\\n          .\n\n    # Push the Docker image to Google Container Registry\n    - name: Publish\n      run: |-\n        docker push \"gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\"\n\n    # Set up kustomize\n    - name: Set up Kustomize\n      run: |-\n        curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64\n        chmod u+x ./kustomize\n\n    # Deploy the Docker image to the GKE cluster\n    - name: Deploy\n      run: |-\n        ./kustomize edit set image gcr.io/PROJECT_ID/IMAGE:TAG=gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\n        ./kustomize build . | kubectl apply -f -\n        kubectl rollout status deployment/$DEPLOYMENT_NAME\n        kubectl get services -o wide\n```\n\n## Additional resources\nFor more information on the tools used in these examples, see the following documentation:\n\n- For the full workflow template, see the [\"Build and Deploy to GKE\" workflow](https://github.com/actions/starter-workflows/blob/main/deployments/google.yml).\n- The Kubernetes YAML customization engine: [Kustomize](https://kustomize.io/).\n- [Deploying a containerized web application](https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app) in the Google Kubernetes Engine documentation.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying to Google Kubernetes Engine?\n\nAssistant: Here are some code examples:\n\n### Creating a GKE cluster\n```yaml\n$ gcloud container clusters create $GKE_CLUSTER \\\n\\t--project=$GKE_PROJECT \\\n\\t--zone=$GKE_ZONE\n```\n\n### Enabling the APIs\n```yaml\n$ gcloud services enable \\\ncontainerregistry.googleapis.com \\\ncontainer.googleapis.com\n```\n\n### Creating a service account\n```yaml\ngcloud iam service-accounts create $SA_NAME\n```\n\n### Retrieving service account email\n```yaml\ngcloud iam service-accounts list\n```\n\n### Adding roles to the service account\n```yaml\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/container.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/storage.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n     --member=serviceAccount:$SA_EMAIL \\\n     --role=roles/container.clusterViewer\n```\n\n### Downloading the JSON keyfile\n```yaml\ngcloud iam service-accounts keys create key.json --iam-account=$SA_EMAIL\n```\n\n### Storing the service account key as a secret\n```yaml\nexport GKE_SA_KEY=$(cat key.json | base64)\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying to Google Kubernetes Engine?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider.\n• GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\n• Apply more restrictive roles to suit your requirements.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Scheduling issue creation?\n\nAssistant: You can use GitHub Actions to create an issue on a regular basis for things like daily meetings or quarterly reviews.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis tutorial demonstrates how to use the GitHub CLI to create an issue on a regular basis. For example, you can create an issue each week to use as the agenda for a team meeting. For more information about GitHub CLI, see [Using GitHub CLI in workflows](https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows). In the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs.\n\n## Creating the workflow\n1. Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n\n2. In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n3. Copy the following YAML contents into your workflow file.\n\n```hljs yaml\nname: Weekly Team Sync\non:\n     schedule:\n    - cron: 20 07 * * 1\n\njobs:\ncreate_issue:\n    name: Create team sync issue\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Create team sync issue\n        run: |\n          if [[ $CLOSE_PREVIOUS == true ]]; then\n            previous_issue_number=$(gh issue list \\\n              --label \"$LABELS\" \\\n              --json number \\\n              --jq '.[0].number')\n            if [[ -n $previous_issue_number ]]; then\n              gh issue close \"$previous_issue_number\"\n              gh issue unpin \"$previous_issue_number\"\n            fi\n          fi\n          new_issue_url=$(gh issue create \\\n            --title \"$TITLE\" \\\n            --assignee \"$ASSIGNEES\" \\\n            --label \"$LABELS\" \\\n            --body \"$BODY\")\n          if [[ $PINNED == true ]]; then\n            gh issue pin \"$new_issue_url\"\n          fi\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          TITLE: Team sync\n          ASSIGNEES: monalisa,doctocat,hubot\n          LABELS: weekly sync,docs-team\n          BODY: |\n            ### Agenda\n\n            - [ ] Start the recording\n            - [ ] Check-ins\n            - [ ] Discussion points\n            - [ ] Post the recording\n\n            ### Discussion Points\n            Add things to discuss below\n\n            - [Work this week](https://github.com/orgs/github/projects/3)\n          PINNED: false\n          CLOSE_PREVIOUS: false\n```\n\n4. Customize the parameters in your workflow file:\n   - Change the value for `on.schedule` to dictate when you want this workflow to run. In the example above, the workflow will run every Monday at 7:20 UTC. For more information about scheduled workflows, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#scheduled-events).\n   - Change the value for `ASSIGNEES` to the list of GitHub usernames that you want to assign to the issue.\n   - Change the value for `LABELS` to the list of labels that you want to apply to the issue.\n   - Change the value for `TITLE` to the title that you want the issue to have.\n   - Change the value for `BODY` to the text that you want in the issue body. The `|` character allows you to use a multi-line value for this parameter.\n   - If you want to pin this issue in your repository, set `PINNED` to `true`. For more information about pinned issues, see [Pinning an issue to your repository](https://docs.github.com/en/issues/tracking-your-work-with-issues/pinning-an-issue-to-your-repository).\n   - If you want to close the previous issue generated by this workflow each time a new issue is created, set `CLOSE_PREVIOUS` to `true`. The workflow will close the most recent issue that has the labels defined in the `labels` field. To avoid closing the wrong issue, use a unique label or combination of labels.\n5. Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n## Expected results\nBased on the `schedule` parameter (for example, every Monday at 7:20 UTC), your workflow will create a new issue with the assignees, labels, title, and body that you specified. If you set `PINNED` to `true`, the workflow will pin the issue to your repository. If you set `CLOSE_PREVIOUS` to true, the workflow will close the most recent issue with matching labels.\n\nNote\n\nThe `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\n## Next steps\n- To learn more about additional things you can do with the GitHub CLI, like using an issue template, see the [`gh issue create` documentation](https://cli.github.com/manual/gh_issue_create).\n- [Search GitHub Marketplace](https://github.com/marketplace?category=&type=actions&verification=&query=schedule+issue) for actions related to scheduled issues.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Scheduling issue creation?\n\nAssistant: Here are some code examples:\n\n### Weekly Team Sync Workflow\n```yaml\nname: Weekly Team Sync\non:\n     schedule:\n    - cron: 20 07 * * 1\n\njobs:\ncreate_issue:\n    name: Create team sync issue\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Create team sync issue\n        run: |\n          if [[ $CLOSE_PREVIOUS == true ]]; then\n            previous_issue_number=$(gh issue list \\\n              --label \"$LABELS\" \\\n              --json number \\\n              --jq '.[0].number')\n            if [[ -n $previous_issue_number ]]; then\n              gh issue close \"$previous_issue_number\"\n              gh issue unpin \"$previous_issue_number\"\n            fi\n          fi\n          new_issue_url=$(gh issue create \\\n            --title \"$TITLE\" \\\n            --assignee \"$ASSIGNEES\" \\\n            --label \"$LABELS\" \\\n            --body \"$BODY\")\n          if [[ $PINNED == true ]]; then\n            gh issue pin \"$new_issue_url\"\n          fi\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          TITLE: Team sync\n          ASSIGNEES: monalisa,doctocat,hubot\n          LABELS: weekly sync,docs-team\n          BODY: |\n            ### Agenda\n\n            - [ ] Start the recording\n            - [ ] Check-ins\n            - [ ] Discussion points\n            - [ ] Post the recording\n\n            ### Discussion Points\n            Add things to discuss below\n\n            - [Work this week](https://github.com/orgs/github/projects/3)\n          PINNED: false\n          CLOSE_PREVIOUS: false\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Scheduling issue creation?\n\nAssistant: Here are the recommended best practices:\n\n• The `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Sharing actions and workflows with your organization?\n\nAssistant: You can share an action or reusable workflow with your organization without publishing the action or workflow publicly.\n\nHere's a detailed explanation:\n\n\n## About GitHub Actions access to private repositories\nYou can share actions and reusable workflows within your organization, without publishing them publicly, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow.\n\nAny actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization. Actions and reusable workflows stored in private repositories cannot be used in public repositories.\n\nWarning\n\n- If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.\n- To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour.\n\n## Sharing actions and workflows with your organization\n1. Store the action or reusable workflow in a private repository. For more information, see [About repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories#about-repository-visibility).\n2. Configure the repository to allow access to workflows in other private repositories. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository).\n\n## Further reading\n- [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying to Azure Static Web App?\n\nAssistant: You can deploy your web app to Azure Static Web App as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a web app to Azure Static Web Apps.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Azure.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create an Azure Static Web App using the 'Other' option for deployment source. For more information, see Quickstart: Building your first static site in the Azure portal in the Azure documentation.\n\n2. Create a secret called `AZURE_STATIC_WEB_APPS_API_TOKEN` with the value of your static web app deployment token. For more information about how to find your deployment token, see Reset deployment tokens in Azure Static Web Apps in the Azure documentation.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy an Azure static web app when there is a push to the `main` branch or when a pull request targeting `main` is opened, synchronized, or reopened. The workflow also tears down the corresponding pre-production deployment when a pull request targeting `main` is closed.\n\nUnder the workflow `env` key, change the following values:\n\n- `APP_LOCATION` to the location of your client code\n- `API_LOCATION` to the location of your API source code. If `API_LOCATION` is not relevant, you can delete the variable and the lines where it is used.\n- `OUTPUT_LOCATION` to the location of your client code build output\n\nFor more information about these values, see Build configuration for Azure Static Web Apps in the Azure documentation.\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-staticwebapp.yml` in the GitHub Actions starter-workflows repository.\n- The action used to deploy the web app is the official Azure `Azure/static-web-apps-deploy` action.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying to Azure Static Web App?\n\nAssistant: Here are some code examples:\n\n### Deploy web app to Azure Static Web Apps\n```yaml\nname: Deploy web app to Azure Static Web Apps\n\nenv:\n  APP_LOCATION: \"/\" # location of your client code\n  API_LOCATION: \"api\" # location of your api source code - optional\n  OUTPUT_LOCATION: \"build\" # location of client code build output\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, synchronize, reopened, closed]\n    branches:\n      - main\n\npermissions:\n  issues: write\n  contents: read\n  pull-requests: write\n\njobs:\n  build_and_deploy:\n    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')\n    runs-on: ubuntu-latest\n    name: Build and Deploy\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          submodules: true\n      - name: Build And Deploy\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          action: \"upload\"\n          app_location: ${{ env.APP_LOCATION }}\n          api_location: ${{ env.API_LOCATION }}\n          output_location: ${{ env.OUTPUT_LOCATION }}\n\n  close_pull_request:\n    if: github.event_name == 'pull_request' && github.event.action == 'closed'\n    runs-on: ubuntu-latest\n    name: Close Pull Request\n    steps:\n      - name: Close Pull Request\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          action: \"close\"\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying to Azure Static Web App?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Controlling access to larger runners?\n\nAssistant: You can use policies to limit access to larger runners that have been added to an organization or enterprise.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\n## In this article\nNote\nThe information and instructions in this article only apply to larger runners with Linux and Windows operating systems.\n\n## About runner groups\nTo control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them.\n\nWhen you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group.\n\nWhen new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, see Moving a runner to a group.\n\nFor information on how to route jobs to runners in a specific group, see Choosing the runner for a job.\n\n## Managing access to your runners\nNote\nBefore your workflows can send jobs to larger runners, you must first configure permissions for the runner group. See the following sections for more information.\n\nRunner groups are used to control which repositories can run jobs on your larger runners. You must manage access to the group from each level of the management hierarchy, depending on where you've defined the larger runner:\n\n- Runners at the enterprise level: By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.\n- Runners at the organization level: By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.\n\nFor example, the following diagram has a runner group named grp-ubuntu-20.04-16core at the enterprise level. Before the repository named octo-repo can use the runners in the group, you must first configure the group at the enterprise level to allow access to the octo-org organization. You must then configure the group at the organization level to allow access to octo-repo.\n\n## Creating a runner group for an organization\nWarning\nIf you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\n\nNote\nWhen creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, see Enforcing policies for GitHub Actions in your enterprise.\n\nAll organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups.\n\nIf no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, see Moving a runner to a group.\n\nFor information about how to create a runner group with the REST API, see REST API endpoints for GitHub Actions.\n\n## Changing which repositories can access a runner group\nWarning\nIf you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\n\nFor runner groups in an organization, you can change what repositories in the organization can access a runner group.\n\n## Configuring private network access for larger runners\nYou can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners.\n\n## Changing the name of a runner group\n1. Navigate to the main page of the organization where your runner groups are located.\n2. Click Settings.\n3. In the left sidebar, click Actions, then click Runner groups.\n4. In the list of groups, click the runner group you'd like to configure.\n5. Enter the new runner group name in the text field under \"Group name.\"\n6. Click Save.\n\n## Moving a runner to a group\nIf you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group.\n\n## Removing a runner group\nIn order to remove a runner group, you must first move or remove all of the runners from the group.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Controlling access to larger runners?\n\nAssistant: Here are the recommended best practices:\n\n• Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n• The information and instructions in this article only apply to larger runners with Linux and Windows operating systems.\n• If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Removing workflow artifacts?\n\nAssistant: You can reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub.\n\nHere's a detailed explanation:\n\n\n## Deleting an artifact\nWarning\n\nOnce you delete an artifact, it cannot be restored.\n\nWrite access to the repository is required to perform these steps.\n\nBy default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy).\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under **Artifacts**, click  next to the artifact you want to remove.\n\n## Setting the retention period for an artifact\nRetention periods for artifacts and logs can be configured at the repository, organization, and enterprise level. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy).\n\nYou can also define a custom retention period for individual artifacts using the `actions/upload-artifact` action in a workflow. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts#configuring-a-custom-artifact-retention-period).\n\n## Finding the expiration date of an artifact\nYou can use the API to confirm the date that an artifact is scheduled to be deleted. For more information, see the `expires_at` value returned by the REST API. For more information, see [REST API endpoints for GitHub Actions artifacts](https://docs.github.com/en/rest/actions/artifacts).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Removing workflow artifacts?\n\nAssistant: Here are the recommended best practices:\n\n• Once you delete an artifact, it cannot be restored.\n• Write access to the repository is required to perform these steps.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About troubleshooting workflows?\n\nAssistant: You can use the tools in GitHub Actions to debug your workflows.\n\nHere's a detailed explanation:\n\n\n## Troubleshooting your workflows\nThere are several ways you can troubleshoot failed workflow runs.\n\n## Using GitHub Copilot\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error. See Using Copilot to troubleshoot workflows.\n\n## Using workflow run logs\nEach workflow run generates activity logs that you can view, search, and download. For more information, see Using workflow run logs.\n\n## Enabling debug logging\nIf the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging. For more information, see Enabling debug logging.\n\n## Canceling a workflow\nIf you attempt to cancel a workflow and the cancellation doesn't succeed, make sure you aren't using the `always` expression. The `always` expression causes a workflow step to run even when the workflow is canceled, which results in a hanging cancellation. For more information, see Evaluate expressions in workflows and actions.\n\n## Troubleshooting GitHub Actions inefficiencies\nTo analyze the inefficiencies and reliability of your workflows using metrics, see Viewing GitHub Actions metrics.\n\n## Troubleshooting self-hosted runners\nIf you use self-hosted runners, you can view their activity and diagnose common issues. For more information, see Monitoring and troubleshooting self-hosted runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About troubleshooting workflows?\n\nAssistant: Here are the recommended best practices:\n\n• Make sure you aren't using the `always` expression when attempting to cancel a workflow to avoid hanging cancellations.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Caching dependencies to speed up workflows?\n\nAssistant: To make your workflows faster and more efficient, you can create and use caches for dependencies and other commonly reused files.\n\nHere's a detailed explanation:\n\n\n## About caching workflow dependencies\nWorkflow runs often reuse the same outputs or downloaded dependencies from one run to another. For example, package and dependency management tools such as Maven, Gradle, npm, and Yarn keep a local cache of downloaded dependencies.\n\nJobs on GitHub-hosted runners start in a clean runner image and must download dependencies each time, causing increased network utilization, longer runtime, and increased cost. To help speed up the time it takes to recreate files like dependencies, GitHub can cache files you frequently use in workflows.\n\nTo cache dependencies for a job, you can use GitHub's [`cache` action](https://github.com/actions/cache). The action creates and restores a cache identified by a unique key. Alternatively, if you are caching the package managers listed below, using their respective setup-* actions requires minimal configuration and will create and restore dependency caches for you.\n\n| Package managers | setup-* action for caching |\n| --- | --- |\n| npm, Yarn, pnpm | [setup-node](https://github.com/actions/setup-node#caching-global-packages-data) |\n| pip, pipenv, Poetry | [setup-python](https://github.com/actions/setup-python#caching-packages-dependencies) |\n| Gradle, Maven | [setup-java](https://github.com/actions/setup-java#caching-packages-dependencies) |\n| RubyGems | [setup-ruby](https://github.com/ruby/setup-ruby#caching-bundle-install-automatically) |\n| Go `go.sum` | [setup-go](https://github.com/actions/setup-go#caching-dependency-files-and-build-outputs) |\n| .NET NuGet | [setup-dotnet](https://github.com/actions/setup-dotnet?tab=readme-ov-file#caching-nuget-packages) |\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Caching dependencies to speed up workflows?\n\nAssistant: Here are some code examples:\n\n### Example using the `cache` action\n```yaml\n```hljs yaml\nname: Caching with npm\non: push\njobs:\nbuild:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Cache node modules\n        id: cache-npm\n        uses: actions/cache@v4\n        env:\n          cache-name: cache-node-modules\n        with:\n          # npm cache files are stored in `~/.npm` on Linux/macOS\n          path: ~/.npm\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-\n            ${{ runner.os }}-build-\n            ${{ runner.os }}-\n\n      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}\n        name: List the state of node modules\n        continue-on-error: true\n        run: npm list\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build\n        run: npm run build\n\n      - name: Test\n        run: npm test\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Caching dependencies to speed up workflows?\n\nAssistant: Here are the recommended best practices:\n\n• We recommend that you don't store any sensitive information in the cache.\n• When using self-hosted runners, caches from workflow runs are stored on GitHub-owned cloud storage. A customer-owned storage solution is only available with GitHub Enterprise Server.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using WireGuard to create a network overlay?\n\nAssistant: You can create an overlay network between your runner and a service in your private network.\n\nHere's a detailed explanation:\n\n\n## Using WireGuard to create a network overlay\nIf you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places.\n\nThere are various disadvantages to this approach:\n\n- To reach WireGuard running on your private service, you will need a well-known IP address and port that your workflow can reference: this can either be a public IP address and port, a port mapping on a network gateway, or a service that dynamically updates DNS.\n- WireGuard doesn't handle NAT traversal out of the box, so you'll need to identify a way to provide this service.\n- This connection is one-to-one, so if you need high availability or high throughput you'll need to build that on top of WireGuard.\n- You'll need to generate and securely store keys for both the runner and your private service. WireGuard uses UDP, so your network must support UDP traffic.\n\nThere are some advantages too, as you can run WireGuard on an existing server so you don't have to maintain separate infrastructure, and it's well supported on GitHub-hosted runners.\n\n## Example: Configuring WireGuard\nThis example workflow configures WireGuard to connect to a private service.\n\nFor this example, the WireGuard instance running in the private network has this configuration:\n\n- Overlay network IP address of `192.168.1.1`\n- Public IP address and port of `1.2.3.4:56789`\n- Public key `examplepubkey1234...`\n\nThe WireGuard instance in the GitHub Actions runner has this configuration:\n\n- Overlay network IP address of `192.168.1.2`\n- Private key stores as an GitHub Actions secret under `WIREGUARD_PRIVATE_KEY`\n\n```hljs yaml\nname: WireGuard example\n\non:\n  workflow_dispatch:\n\njobs:\n  wireguard_example:\n    runs-on: ubuntu-latest\n    steps:\n      - run: sudo apt install wireguard\n\n      - run: echo \"${{ secrets.WIREGUARD_PRIVATE_KEY }}\" > privatekey\n\n      - run: sudo ip link add dev wg0 type wireguard\n\n      - run: sudo ip address add dev wg0 192.168.1.2 peer 192.168.1.1\n\n      - run: sudo wg set wg0 listen-port 48123 private-key privatekey peer examplepubkey1234... allowed-ips 0.0.0.0/0 endpoint 1.2.3.4:56789\n\n      - run: sudo ip link set up dev wg0\n\n      - run: curl -vvv http://192.168.1.1\n```\n\nFor more information, see [WireGuard's Quick Start](https://www.wireguard.com/quickstart/), as well as [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) for how to securely store keys.\n\n## Using Tailscale to create a network overlay\nTailscale is a commercial product built on top of WireGuard. This option is very similar to WireGuard, except Tailscale is more of a complete product experience instead of an open source component.\n\nIts disadvantages are similar to WireGuard: The connection is one-to-one, so you might need to do additional work for high availability or high throughput. You still need to generate and securely store keys. The protocol is still UDP, so your network must support UDP traffic.\n\nHowever, there are some advantages over WireGuard: NAT traversal is built-in, so you don't need to expose a port to the public internet. It is by far the quickest of these options to get up and running, since Tailscale provides an GitHub Actions workflow with a single step to connect to the overlay network.\n\nFor more information, see the [Tailscale GitHub Action](https://github.com/tailscale/github-action), as well as [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) for how to securely store keys.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using WireGuard to create a network overlay?\n\nAssistant: Here are some code examples:\n\n### WireGuard example\n```yaml\nname: WireGuard example\n\non:\n  workflow_dispatch:\n\njobs:\n  wireguard_example:\n    runs-on: ubuntu-latest\n    steps:\n      - run: sudo apt install wireguard\n\n      - run: echo \"${{ secrets.WIREGUARD_PRIVATE_KEY }}\" > privatekey\n\n      - run: sudo ip link add dev wg0 type wireguard\n\n      - run: sudo ip address add dev wg0 192.168.1.2 peer 192.168.1.1\n\n      - run: sudo wg set wg0 listen-port 48123 private-key privatekey peer examplepubkey1234... allowed-ips 0.0.0.0/0 endpoint 1.2.3.4:56789\n\n      - run: sudo ip link set up dev wg0\n\n      - run: curl -vvv http://192.168.1.1\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using WireGuard to create a network overlay?\n\nAssistant: Here are the recommended best practices:\n\n• To reach WireGuard running on your private service, you will need a well-known IP address and port that your workflow can reference.\n• WireGuard doesn't handle NAT traversal out of the box, so you'll need to identify a way to provide this service.\n• This connection is one-to-one, so if you need high availability or high throughput you'll need to build that on top of WireGuard.\n• You'll need to generate and securely store keys for both the runner and your private service.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using artifact attestations to establish provenance for builds?\n\nAssistant: Artifact attestations enable you to increase the supply chain security of your builds by establishing where and how your software was built.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nArtifact attestations are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, artifact attestations are only available for public repositories. To use artifact attestations in private or internal repositories, you must be on a GitHub Enterprise Cloud plan.\n\n## About artifact attestations\nArtifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\n\nWhen you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:\n\n- A link to the workflow associated with the artifact.\n- The repository, organization, environment, commit SHA, and triggering event for the artifact.\n- Other information from the OIDC token used to establish provenance. For more information, see About security hardening with OpenID Connect.\n\nYou can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.\n\n## About SLSA levels for artifact attestations\nThe SLSA framework is an industry standard used to evaluate supply chain security. It is organized into levels. Each level represents an increasing degree of security and trustworthiness for a software supply chain. Artifact attestations by itself provides SLSA v1.0 Build Level 2.\n\nThis provides a link between your artifact and its build instructions, but you can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3. For more information, see Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3.\n\nFor more information on SLSA levels, see SLSA Security Levels.\n\n## About using Sigstore for artifact attestations\nTo generate artifact attestations, GitHub uses Sigstore, which is an open source project that offers a comprehensive solution for signing and verifying software artifacts via attestations.\n\nPublic repositories that generate artifact attestations use the Sigstore Public Good Instance. A copy of the generated Sigstore bundle is stored with GitHub and is also written to an immutable transparency log that is publicly readable on the internet.\n\nPrivate repositories that generate artifact attestations use GitHub's Sigstore instance. GitHub's Sigstore instance uses the same codebase as the Sigstore Public Good Instance, but it does not have a transparency log and only federates with GitHub Actions.\n\n## What to attest\nGenerating attestations alone doesn't provide any security benefit, the attestations must be verified for the benefit to be realized. Here are some guidelines for how to think about what to sign and how often:\n\nYou should sign:\n\n- Software you are releasing that you expect people to run `gh attestation verify ...` on.\n- Binaries people will run, packages people will download, or manifests that include hashes of detailed contents.\n\nYou should **not** sign:\n\n- Frequent builds that are just for automated testing.\n- Individual files like source code, documentation files, or embedded images.\n\n## About verifying artifact attestations\nIf you consume software that publishes artifact attestations, you can use the GitHub CLI to verify those attestations. Because the attestations give you information about where and how software was built, you can use that information to create and enforce security policies that elevate your supply chain security. For more information, see Verifying artifact attestations with the GitHub CLI.\n\nWarning\n\nIt is important to remember that artifact attestations are _not_ a guarantee that an artifact is secure. Instead, artifact attestations link you to the source code and the build instructions that produced them. It is up to you to define your policy criteria, evaluate that policy by evaluating the content, and make an informed risk decision when you are consuming software.\n\n## Generating artifact attestations for your builds\nYou can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images.\n\nTo generate an artifact attestation, you must:\n\n- Ensure you have the appropriate permissions configured in your workflow.\n- Include a step in your workflow that uses the `attest-build-provenance` action.\n\nWhen you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository's **Actions** tab. For more information, see the `attest-build-provenance` repository.\n\n## Generating build provenance for binaries\n1. In the workflow that builds the binary you would like to attest, add the following permissions.\n\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n```\n\n2. After the step where the binary has been built, add the following step.\n\n```yaml\n- name: Generate artifact attestation\n  uses: actions/attest-build-provenance@v2\n  with:\n      subject-path: 'PATH/TO/ARTIFACT'\n```\n\nThe value of the `subject-path` parameter should be set to the path to the binary you want to attest.\n\n## Generating build provenance for container images\n1. In the workflow that builds the container image you would like to attest, add the following permissions.\n\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n     packages: write\n```\n\n2. After the step where the image has been built, add the following step.\n\n```yaml\n- name: Generate artifact attestation\n  uses: actions/attest-build-provenance@v2\n  with:\n      subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n      subject-digest: 'sha256:fedcba0...'\n      push-to-registry: true\n```\n\nThe value of the `subject-name` parameter should specify the fully-qualified image name. For example, `ghcr.io/user/app` or `acme.azurecr.io/user/app`. Do not include a tag as part of the image name.\n\nThe value of the `subject-digest` parameter should be set to the SHA256 digest of the subject for the attestation, in the form `sha256:HEX_DIGEST`. If your workflow uses `docker/build-push-action`, you can use the `digest` output from that step to supply the value. For more information on using outputs, see Workflow syntax for GitHub Actions.\n\n## Generating an attestation for a software bill of materials (SBOM)\nYou can generate signed SBOM attestations for workflow artifacts.\n\nTo generate an attestation for an SBOM, you must:\n\n- Ensure you have the appropriate permissions configured in your workflow.\n- Create an SBOM for your artifact. For more information, see `anchore-sbom-action` in the GitHub Marketplace.\n- Include a step in your workflow that uses the `attest-sbom` action.\n\nWhen you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository's **Actions** tab. For more information, see the `attest-sbom` action repository.\n\n## Generating an SBOM attestation for binaries\n1. In the workflow that builds the binary you would like to attest, add the following permissions.\n\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n```\n\n2. After the step where the binary has been built, add the following step.\n\n```yaml\n- name: Generate SBOM attestation\n  uses: actions/attest-sbom@v1\n  with:\n      subject-path: 'PATH/TO/ARTIFACT'\n      sbom-path: 'PATH/TO/SBOM'\n```\n\nThe value of the `subject-path` parameter should be set to the path of the binary the SBOM describes. The value of the `sbom-path` parameter should be set to the path of the SBOM file you generated.\n\n## Generating an SBOM attestation for container images\n1. In the workflow that builds the container image you would like to attest, add the following permissions.\n\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n     packages: write\n```\n\n2. After the step where the image has been built, add the following step.\n\n```yaml\n- name: Generate SBOM attestation\n  uses: actions/attest-sbom@v1\n  with:\n      subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE\n      subject-digest: 'sha256:fedcba0...'\n      sbom-path: 'sbom.json'\n      push-to-registry: true\n```\n\nThe value of the `subject-name` parameter should specify the fully-qualified image name. For example, `ghcr.io/user/app` or `acme.azurecr.io/user/app`. Do not include a tag as part of the image name.\n\nThe value of the `subject-digest` parameter should be set to the SHA256 digest of the subject for the attestation, in the form `sha256:HEX_DIGEST`. If your workflow uses `docker/build-push-action`, you can use the `digest` output from that step to supply the value. For more information on using outputs, see Workflow syntax for GitHub Actions.\n\nThe value of the `sbom-path` parameter should be set to the path to the JSON-formatted SBOM file you want to attest.\n\n## Verifying artifact attestations with the GitHub CLI\nTo verify artifact attestations for binaries, use the following GitHub CLI command.\n\n```bash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\nTo verify artifact attestations for container images, you must provide the image's FQDN prefixed with `oci://` instead of the path to a binary. You can use the following GitHub CLI command.\n\n```bash\ndocker login ghcr.io\n\ngh attestation verify oci://ghcr.io/ORGANIZATION_NAME/IMAGE_NAME:test -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\nNote\n\nThese commands assume you are in an online environment. If you are in an offline or air-gapped environment, see Verifying attestations offline.\n\nFor more information, see the attestation section of the GitHub CLI manual.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using artifact attestations to establish provenance for builds?\n\nAssistant: Here are some code examples:\n\n### Generating build provenance for binaries\n```yaml\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n```\n\n```yaml\n- name: Generate artifact attestation\n  uses: actions/attest-build-provenance@v2\n  with:\n      subject-path: 'PATH/TO/ARTIFACT'\n```\n```\n\n### Generating build provenance for container images\n```yaml\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n     packages: write\n```\n\n```yaml\n- name: Generate artifact attestation\n  uses: actions/attest-build-provenance@v2\n  with:\n      subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n      subject-digest: 'sha256:fedcba0...'\n      push-to-registry: true\n```\n```\n\n### Generating an SBOM attestation for binaries\n```yaml\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n```\n\n```yaml\n- name: Generate SBOM attestation\n  uses: actions/attest-sbom@v1\n  with:\n      subject-path: 'PATH/TO/ARTIFACT'\n      sbom-path: 'PATH/TO/SBOM'\n```\n```\n\n### Generating an SBOM attestation for container images\n```yaml\n```yaml\npermissions:\n     id-token: write\n     contents: read\n     attestations: write\n     packages: write\n```\n\n```yaml\n- name: Generate SBOM attestation\n  uses: actions/attest-sbom@v1\n  with:\n      subject-name: ${{ env.REGISTRY }}/PATH/TO/IMAGE\n      subject-digest: 'sha256:fedcba0...'\n      sbom-path: 'sbom.json'\n      push-to-registry: true\n```\n```\n\n### Verifying artifact attestations with the GitHub CLI for binaries\n```yaml\n```bash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n```\n\n### Verifying artifact attestations with the GitHub CLI for container images\n```yaml\n```bash\ndocker login ghcr.io\n\ngh attestation verify oci://ghcr.io/ORGANIZATION_NAME/IMAGE_NAME:test -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using artifact attestations to establish provenance for builds?\n\nAssistant: Here are the recommended best practices:\n\n• Artifact attestations are not a guarantee that an artifact is secure; they link you to the source code and build instructions that produced them.\n• Define your policy criteria and evaluate the content to make informed risk decisions when consuming software.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Downloading workflow artifacts?\n\nAssistant: You can download archived artifacts before they automatically expire.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nPeople who are signed into GitHub and have read access to a repository can download workflow artifacts.\n\n## Tool navigation\nBy default, GitHub stores build logs and artifacts for 90 days, and you can customize this retention period, depending on the type of repository. For more information, see Managing GitHub Actions settings for a repository. Read access to the repository is required to perform these steps.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. In the left sidebar, click the workflow you want to see.\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n5. In the \"Artifacts\" section, click the artifact you want to download.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Downloading workflow artifacts?\n\nAssistant: Here are some code examples:\n\n### Download all artifacts from a workflow run\n```yaml\ngh run download RUN_ID\n```\n\n### Download a specific artifact from a run\n```yaml\ngh run download RUN_ID -n ARTIFACT_NAME\n```\n\n### Download multiple specific artifacts from a run\n```yaml\ngh run download RUN_ID -n ARTIFACT_NAME-1 -n ARTIFACT_NAME-2\n```\n\n### Download specific artifacts across all runs in a repository\n```yaml\ngh run download -n ARTIFACT_NAME-1 ARTIFACT_NAME-2\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Downloading workflow artifacts?\n\nAssistant: Here are the recommended best practices:\n\n• Read access to the repository is required to perform these steps.\n• GitHub CLI will download each artifact into separate directories based on the artifact name. If only a single artifact is specified, it will be extracted into the current directory.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Extending GitHub Actions Importer with custom transformers?\n\nAssistant: GitHub Actions Importer offers the ability to extend its built-in mapping.\n\nHere's a detailed explanation:\n\n\n## About custom transformers\nGitHub Actions Importer offers the ability to extend its built-in mapping by creating custom transformers. Custom transformers can be used to:\n\n- Convert items that GitHub Actions Importer does not automatically convert, or modify how items are converted. For more information, see Creating custom transformers for items.\n- Convert references to runners to use different runner labels. For more information, see Creating custom transformers for runners.\n- Convert environment variable values from your existing pipelines to GitHub Actions workflows. For more information, see Creating custom transformers for environment variables.\n\n## Using custom transformers with GitHub Actions Importer\nA custom transformer contains mapping logic that GitHub Actions Importer can use to transform your plugins, tasks, runner labels, or environment variables to work with GitHub Actions. Custom transformers are written with a domain-specific language (DSL) built on top of Ruby, and are defined within a file with the .rb file extension.\n\nYou can use the --custom-transformers CLI option to specify which custom transformer files to use with the audit, dry-run, and migrate commands.\n\nFor example, if custom transformers are defined in a file named transformers.rb, you can use the following command to use them with GitHub Actions Importer:\n\n```hljs shell\ngh actions-importer ... --custom-transformers transformers.rb\n```\n\nAlternatively, you can use the glob pattern syntax to specify multiple custom transformer files. For example, if multiple custom transformer files are within a directory named transformers, you can provide them all to GitHub Actions Importer with the following command:\n\n```hljs shell\ngh actions-importer ... --custom-transformers transformers/*.rb\n```\n\nNote\n\nWhen you use custom transformers, the custom transformer files must reside in the same directory, or in subdirectories, from where the gh actions-importer command is run.\n\n## Creating custom transformers for items\nYou can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when:\n\n- GitHub Actions Importer doesn't automatically convert an item.\n- You want to change how an item is converted by GitHub Actions Importer.\n- Your existing pipelines use custom or proprietary extensions, such as shared libraries in Jenkins, and you need to define how these steps should function in GitHub Actions.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers:\n\n- Each custom transformer file must contain at least one transform method.\n- Each transform method must return a Hash, an array of Hash's, or nil. This returned value will correspond to an action defined in YAML. For more information about actions, see Understanding GitHub Actions.\n\n## Example custom transformer for a build step\nThe following example converts a build step that uses the \"buildJavaScriptApp\" identifier to run various npm commands:\n\n```hljs ruby\ntransform \"buildJavaScriptApp\" do |item|\n  command = [\"build\", \"package\", \"deploy\"].map do |script|\n    \"npm run \\\\#{script}\"\n  end\n\n  {\n    name: \"build javascript app\",\n    run: command.join(\"\\n\")\n  }\nend\n```\n\nThe above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had a buildJavaScriptApp identifier:\n\n```hljs yaml\n- name: build javascript app\n  run: |\n    npm run build\n    npm run package\n    npm run deploy\n```\n\nThe transform method uses the identifier of the build step from your source CI/CD instance in an argument. In this example, the identifier is buildJavaScriptLibrary. You can also use comma-separated values to pass multiple identifiers to the transform method. For example, transform \"buildJavaScriptApp\", \"buildTypeScriptApp\" { |item| ... }.\n\n## Creating custom transformers for runners\nYou can customize the mapping between runners in your source CI/CD instance and their equivalent GitHub Actions runners.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for runners:\n\n- The custom transformer file must have at least one runner method.\n- The runner method accepts two parameters. The first parameter is the source CI/CD instance's runner label, and the second parameter is the corresponding GitHub Actions runner label. For more information on GitHub Actions runners, see Using GitHub-hosted runners.\n\n## Example custom transformers for runners\nThe following example shows a runner method that converts one runner label to one GitHub Actions runner label in the resulting workflow.\n\n```hljs ruby\nrunner \"linux\", \"ubuntu-latest\"\n```\n\nYou can also use the runner method to convert one runner label to multiple GitHub Actions runner labels in the resulting workflow.\n\n```hljs ruby\nrunner \"big-agent\", [\"self-hosted\", \"xl\", \"linux\"]\n```\n\nGitHub Actions Importer attempts to map the runner label as best it can. In cases where it cannot do this, the ubuntu-latest runner label is used as a default. You can use a special keyword with the runner method to control this default value. For example, the following custom transformer instructs GitHub Actions Importer to use macos-latest as the default runner instead of ubuntu-latest.\n\n```hljs ruby\nrunner :default, \"macos-latest\"\n```\n\n## Creating custom transformers for environment variables\nYou can customize the mapping between environment variables in your source CI/CD pipelines to their values in GitHub Actions.\n\nGitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for environment variables:\n\n- The custom transformer file must have at least one env method.\n- The env method accepts two parameters. The first parameter is the name of the environment variable in the original pipeline, and the second parameter is the updated value for the environment variable for GitHub Actions. For more information about GitHub Actions environment variables, see Store information in variables.\n\n## Example custom transformers for environment variables\nThere are several ways you can set up custom transformers to map your environment variables.\n\n- The following example sets the value of any existing environment variables named OCTO, to CAT when transforming a pipeline.\n\n```hljs ruby\nenv \"OCTO\", \"CAT\"\n```\n\nYou can also remove all instances of a specific environment variable so they are not transformed to an GitHub Actions workflow. The following example removes all environment variables with the name MONA_LISA.\n\n```hljs ruby\nenv \"MONA_LISA\", nil\n```\n\n- You can also map your existing environment variables to secrets. For example, the following env method maps an environment variable named MONALISA to a secret named OCTOCAT.\n\n```hljs ruby\nenv \"MONALISA\", secret(\"OCTOCAT\")\n```\n\nThis will set up a reference to a secret named OCTOCAT in the transformed workflow. For the secret to work, you will need to create the secret in your GitHub repository. For more information, see Using secrets in GitHub Actions.\n\n- You can also use regular expressions to update the values of multiple environment variables at once. For example, the following custom transformer removes all environment variables from the converted workflow:\n\n```hljs ruby\nenv /.*/, nil\n```\n\nThe following example uses a regular expression match group to transform environment variable values to dynamically generated secrets.\n\n```hljs ruby\nenv /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY\")\n```\n\nNote\n\nThe order in which env methods are defined matters when using regular expressions. The first env transformer that matches an environment variable name takes precedence over subsequent env methods. You should define your most specific environment variable transformers first.\n\n## Legal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\naUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Extending GitHub Actions Importer with custom transformers?\n\nAssistant: Here are some code examples:\n\n### Using custom transformers with GitHub Actions Importer\n```yaml\ngh actions-importer ... --custom-transformers transformers.rb\n```\n\n### Using glob pattern syntax for custom transformers\n```yaml\ngh actions-importer ... --custom-transformers transformers/*.rb\n```\n\n### Example custom transformer for a build step\n```yaml\ntransform \"buildJavaScriptApp\" do |item|\n  command = [\"build\", \"package\", \"deploy\"].map do |script|\n    \"npm run \\\\#{script}\"\n  end\n\n  {\n    name: \"build javascript app\",\n    run: command.join(\"\\n\")\n  }\nend\n```\n\n### Example custom transformers for runners\n```yaml\nrunner \"linux\", \"ubuntu-latest\"\n```\n\n### Example custom transformers for environment variables\n```yaml\nenv \"OCTO\", \"CAT\"\n```\n\n### Remove environment variable\n```yaml\nenv \"MONA_LISA\", nil\n```\n\n### Map environment variable to secret\n```yaml\nenv \"MONALISA\", secret(\"OCTOCAT\")\n```\n\n### Remove all environment variables\n```yaml\nenv /.*/, nil\n```\n\n### Transform environment variable values to secrets\n```yaml\nenv /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY\")\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Extending GitHub Actions Importer with custom transformers?\n\nAssistant: Here are the recommended best practices:\n\n• When using custom transformers, the custom transformer files must reside in the same directory, or in subdirectories, from where the gh actions-importer command is run.\n• The order in which env methods are defined matters when using regular expressions. The first env transformer that matches an environment variable name takes precedence over subsequent env methods. You should define your most specific environment variable transformers first.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating custom deployment protection rules?\n\nAssistant: Use GitHub Apps to automate protecting deployments with third-party systems.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.\n\n## About custom deployment protection rules\nYou can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub.\n\nCustom deployment protection rules are powered by GitHub Apps and run based on webhooks and callbacks. Approval or rejection of a workflow job is based on consumption of the `deployment_protection_rule` webhook. For more information, see Webhook events and payloads and Approving or rejecting deployments.\n\nOnce you have created a custom deployment protection rule and installed it on your repository, the custom deployment protection rule will automatically be available for all environments in the repository.\n\n## Using custom deployment protection rules to approve or reject deployments\nDeployments to an environment can be approved or rejected based on the conditions defined in any external service like an approved ticket in an IT Service Management (ITSM) system, vulnerable scan result on dependencies, or stable health metrics of a cloud resource. The decision to approve or reject deployments is at the discretion of the integrating third-party application and the gating conditions you define in them. The following are a few use cases for which you can create a deployment protection rule.\n\n- ITSM & Security Operations: you can check for service readiness by validating quality, security, and compliance processes that verify deployment readiness.\n- Observability systems: you can consult monitoring or observability systems (Asset Performance Management Systems and logging aggregators, cloud resource health verification systems, etc.) for verifying the safety and deployment readiness.\n- Code quality & testing tools: you can check for automated tests on CI builds which need to be deployed to an environment.\n\nAlternatively, you can write your own protection rules for any of the above use cases or you can define any custom logic to safely approve or reject deployments from pre-production to production environments.\n\n## Creating a custom deployment protection rule with GitHub Apps\n1. Create a GitHub App. For more information, see Registering a GitHub App. Configure the GitHub App as follows.\n1. Optionally, in the **Callback URL** text field under \"Identifying and authorizing users,\" enter the callback URL. For more information, see About the user authorization callback URL.\n2. Under \"Permissions,\" select **Repository permissions**.\n3. To the right of \"Actions,\" click the drop down menu and select **Access: Read-only**.\n\n      ![Screenshot of the \"Repository permissions\" section for a new GitHub App. The Actions permission shows \"Read-only\" and is outlined in orange.](https://docs.github.com/assets/cb-24396/images/help/actions/actions-repo-permissions-read-only.png)\n\n4. To the right of \"Deployments,\" click the drop down menu and select **Access: Read and write**.\n\n      ![Screenshot of the \"Repository permissions\" section for a new GitHub App. The Deployments permission shows \"Read and write\" and is outlined in orange.](https://docs.github.com/assets/cb-34606/images/help/actions/actions-deployments-repo-permissions-read-and-write.png)\n\n5. Under \"Subscribe to events,\" select **Deployment protection rule**.\n\n      ![Screenshot of the \"Subscribe to events section\" section for a new GitHub App. The checkbox for the Deployment protection rule is outlined in orange.](https://docs.github.com/assets/cb-49663/images/help/actions/actions-subscribe-to-events-deployment-protection-rules.png)\n2. Install the custom deployment protection rule in your repositories and enable it for use. For more information, see Configuring custom deployment protection rules.\n\n## Approving or rejecting deployments\nOnce a workflow reaches a job that references an environment that has the custom deployment protection rule enabled, GitHub sends a `POST` request to a URL you configure containing the `deployment_protection_rule` payload. You can write your deployment protection rule to automatically send REST API requests that approve or reject the deployment based on the `deployment_protection_rule` payload. Configure your REST API requests as follows.\n\n1. Validate the incoming `POST` request. For more information, see Validating webhook deliveries.\n\n2. Use a JSON Web Token to authenticate as a GitHub App. For more information, see Authenticating as a GitHub App.\n\n3. Using the installation ID from the `deployment_protection_rule` webhook payload, generate an install token. For more information, see About authentication with a GitHub App.\n\n```hljs shell\ncurl --request POST \\\n   --url \"https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS\" \\\n   --header \"Accept: application/vnd.github+json\" \\\n   --header \"Authorization: Bearer {jwt}\" \\\n   --header \"Content-Type: application/json\" \\\n   --data \\\n'{ \\\n      \"repository_ids\": [321], \\\n      \"permissions\": { \\\n         \"deployments\": \"write\" \\\n      } \\\n}'\n```\n\n4. Optionally, to add a status report without taking any other action to GitHub, send a `POST` request to `/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule`. In the request body, omit the `state`. For more information, see REST API endpoints for workflow runs. You can post a status report on the same deployment up to 10 times. Status reports support Markdown formatting and can be up to 1024 characters long.\n\n5. To approve or reject a request, send a `POST` request to `/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule`. In the request body, set the `state` property to either `approved` or `rejected`. For more information, see REST API endpoints for workflow runs.\n\n6. Optionally, request the status of an approval for a workflow run by sending a `GET` request to `/repos/OWNER/REPOSITORY_ID/actions/runs/RUN_ID/approvals`. For more information, see REST API endpoints for workflow runs.\n\n7. Optionally, review the deployment on GitHub. For more information, see Reviewing deployments.\n\n## Publishing custom deployment protection rules in the GitHub Marketplace\nYou can publish your GitHub App to the GitHub Marketplace to allow developers to discover suitable protection rules and install it across their GitHub repositories. Or you can browse existing custom deployment protection rules to suit your needs. For more information, see About GitHub Marketplace for apps and Listing an app on GitHub Marketplace.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating custom deployment protection rules?\n\nAssistant: Here are some code examples:\n\n### Generating an install token for a GitHub App\n```yaml\ncurl --request POST \\\n   --url \"https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS\" \\\n   --header \"Accept: application/vnd.github+json\" \\\n   --header \"Authorization: Bearer {jwt}\" \\\n   --header \"Content-Type: application/json\" \\\n   --data \\\n'{ \\\n      \"repository_ids\": [321], \\\n      \"permissions\": { \\\n         \"deployments\": \"write\" \\\n      } \\\n}'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating custom deployment protection rules?\n\nAssistant: Here are the recommended best practices:\n\n• Custom deployment protection rules are currently in public preview and subject to change.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using workflow run logs?\n\nAssistant: You can view, search, and download the logs for each job in a workflow run.\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can see whether a workflow run is in progress or complete from the workflow run page. You must be logged in to a GitHub account to view workflow run information, including for public repositories. For more information, see [Access permissions on GitHub](https://docs.github.com/en/get-started/learning-about-github/access-permissions-on-github).\n\nIf the run is complete, you can see whether the result was a success, failure, canceled, or neutral. If the run failed, you can view and search the build logs to diagnose the failure and re-run the workflow. You can also view billable job execution minutes, or download logs and build artifacts.\n\nGitHub Actions use the Checks API to output statuses, results, and logs for a workflow. GitHub creates a new check suite for each workflow run. The check suite contains a check run for each job in the workflow, and each job includes steps. GitHub Actions are run as a step in a workflow. For more information about the Checks API, see [REST API endpoints for checks](https://docs.github.com/en/rest/checks).\n\nNote\n\nEnsure that you only commit valid workflow files to your repository. If `.github/workflows` contains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit.\n\n## Viewing logs to diagnose failures\nIf your workflow run fails, you can see which step caused the failure and review the failed step's build logs to troubleshoot. You can see the time it took for each step to run. You can also copy a permalink to a specific line in the log file to share with your team. Read access to the repository is required to perform these steps.\n\nIn addition to the steps configured in the workflow file, GitHub adds two additional steps to each job to set up and complete the job's execution. These steps are logged in the workflow run with the names \"Set up job\" and \"Complete job\".\n\nFor jobs run on GitHub-hosted runners, \"Set up job\" records details of the runner image, and includes a link to the list of preinstalled tools that were present on the runner machine.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under **Jobs** or in the visualization graph, click the job you want to see.\n\n6. Any failed steps are automatically expanded to display the results.\n\n7. Optionally, to get a link to a specific line in the logs, click on the step's line number. You can then copy the link from the address bar of your web browser.\n\n## Searching logs\nYou can search the build logs for a particular step. When you search logs, only expanded steps are included in the results. Read access to the repository is required to perform these steps.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under **Jobs** or in the visualization graph, click the job you want to see.\n\n6. In the upper-right corner of the log output, in the **Search logs** search box, type a search query.\n\n## Downloading logs\nYou can download the log files from your workflow run. You can also download a workflow's artifacts. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts). Read access to the repository is required to perform these steps.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under **Jobs** or in the visualization graph, click the job you want to see.\n\n6. In the upper right corner of the log, select the dropdown menu, then click **Download log archive**.\n\nNote\n\nWhen you download the log archive for a workflow that was partially re-run, the archive only includes the jobs that were re-run. To get a complete set of logs for jobs that were run from a workflow, you must download the log archives for the previous run attempts that ran the other jobs.\n\n## Deleting logs\nYou can delete the log files from your workflow runs through the GitHub web interface or programmatically. Write access to the repository is required to perform these steps.\n\n## Deleting logs via the GitHub web interface\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. In the upper-right corner, select the dropdown menu, then click **Delete all logs**.\n\n6. Review the confirmation prompt.\n\nAfter deleting logs, the **Delete all logs** button is removed to indicate that no log files remain in the workflow run.\n\n## Deleting logs programmatically\nYou can use the following script to automatically delete all logs for a workflow. This can be a useful way to clean up logs for multiple workflow runs.\n\nTo run the example script below:\n\n1. Copy the code example and save it to a file called `delete-logs.sh`.\n\n2. Grant it the execute permission with `chmod +x delete-logs.sh`.\n\n3. Run the following command, where `REPOSITORY_NAME` is the name of your repository and `WORKFLOW_NAME` is the file name of your workflow.\n\n## Viewing logs with GitHub CLI\nNote\n\nTo learn more about GitHub CLI, see [About GitHub CLI](https://docs.github.com/en/github-cli/github-cli/about-github-cli).\n\nTo view the log for a specific job, use the `run view` subcommand. Replace `run-id` with the ID of run that you want to view logs for. GitHub CLI returns an interactive menu for you to choose a job from the run. If you don't specify `run-id`, GitHub CLI returns an interactive menu for you to choose a recent run, and then returns another interactive menu for you to choose a job from the run.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using workflow run logs?\n\nAssistant: Here are some code examples:\n\n### Delete logs script\n```yaml\n#!/usr/bin/env bash\n\n# Delete all logs for a given workflow\n# Usage: delete-logs.sh <repository> <workflow-name>\n\nset -oe pipefail\n\nREPOSITORY=$1\nWORKFLOW_NAME=$2\n\n# Validate arguments\nif [[ -z \"$REPOSITORY\" ]]; then\n  echo \"Repository is required\"\n  exit 1\nfi\n\nif [[ -z \"$WORKFLOW_NAME\" ]]; then\n  echo \"Workflow name is required\"\n  exit 1\nfi\n\necho \"Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY\"\n\nRUNS=$(\n  gh api \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs\" \\\n    --paginate \\\n    --jq '.workflow_runs[] | select(.conclusion != \"\") | .id'\n)\n\necho \"Found $(echo \"$RUNS\" | wc -l) completed runs for workflow $WORKFLOW_NAME\"\n\n# Delete logs for each run\nfor RUN in $RUNS; do\n  echo \"Deleting logs for run $RUN\"\n  gh api \\\n    --silent \\\n    --method DELETE \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/runs/$RUN/logs\" || echo \"Failed to delete logs for run $RUN\"\n\n  # Sleep for 100ms to avoid rate limiting\n  sleep 0.1\ndone\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using workflow run logs?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure that you only commit valid workflow files to your repository. If `.github/workflows` contains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing PowerShell?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your PowerShell project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to use PowerShell for CI. It describes how to use Pester, install dependencies, test your module, and publish to the PowerShell Gallery.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes PowerShell and Pester.\n\nFor a full list of up-to-date software and the pre-installed versions of PowerShell and Pester, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see [Writing workflows](https://docs.github.com/en/actions/learn-github-actions).\n\nWe recommend that you have a basic understanding of PowerShell and Pester. For more information, see:\n\n- [Getting started with PowerShell](https://docs.microsoft.com/powershell/scripting/learn/ps101/01-getting-started)\n- [Pester](https://pester.dev/)\n\n## Adding a workflow for Pester\nTo automate your testing with PowerShell and Pester, you can add a workflow that runs every time a change is pushed to your repository. In the following example, `Test-Path` is used to check that a file called `resultsfile.log` is present.\n\nThis example workflow file must be added to your repository's `.github/workflows/` directory:\n\n```hljs yaml\nname: Test PowerShell on Ubuntu\non: push\n\njobs:\n  pester-test:\n    name: Pester test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Perform a Pester test from the command-line\n        shell: pwsh\n        run: Test-Path resultsfile.log | Should -Be $true\n      - name: Perform a Pester test from the Tests.ps1 file\n        shell: pwsh\n        run: |\n          Invoke-Pester Unit.Tests.ps1 -Passthru\n```\n\n- `shell: pwsh` \\- Configures the job to use PowerShell when running the `run` commands.\n\n- `run: Test-Path resultsfile.log` \\- Check whether a file called `resultsfile.log` is present in the repository's root directory.\n\n- `Should -Be $true` \\- Uses Pester to define an expected result. If the result is unexpected, then GitHub Actions flags this as a failed test. For example:\n\n![Screenshot of a workflow run failure for a Pester test. Test reports \"Expected $true, but got $false\" and \"Error: Process completed with exit code 1.\"](https://docs.github.com/assets/cb-58712/images/help/repository/actions-failed-pester-test-updated.png)\n\n- `Invoke-Pester Unit.Tests.ps1 -Passthru` \\- Uses Pester to execute tests defined in a file called `Unit.Tests.ps1`. For example, to perform the same test described above, the `Unit.Tests.ps1` will contain the following:\n\n```hljs powershell\nDescribe \"Check results file is present\" {\n      It \"Check results file is present\" {\n          Test-Path resultsfile.log | Should -Be $true\n      }\n}\n```\n\n## PowerShell module locations\nThe table below describes the locations for various PowerShell modules in each GitHub-hosted runner.\n\n|  | Ubuntu | macOS | Windows |\n| --- | --- | --- | --- |\n| **PowerShell system modules** | `/opt/microsoft/powershell/7/Modules/*` | `/usr/local/microsoft/powershell/7/Modules/*` | `C:\\program files\\powershell\\7\\Modules\\*` |\n| **PowerShell add-on modules** | `/usr/local/share/powershell/Modules/*` | `/usr/local/share/powershell/Modules/*` | `C:\\Modules\\*` |\n| **User-installed modules** | `/home/runner/.local/share/powershell/Modules/*` | `/Users/runner/.local/share/powershell/Modules/*` | `C:\\Users\\runneradmin\\Documents\\PowerShell\\Modules\\*` |\n\nNote\n\nOn Ubuntu runners, Azure PowerShell modules are stored in `/usr/share/` instead of the default location of PowerShell add-on modules (i.e. `/usr/local/share/powershell/Modules/`).\n\n## Installing dependencies\nGitHub-hosted runners have PowerShell 7 and Pester installed. You can use `Install-Module` to install additional dependencies from the PowerShell Gallery before building and testing your code.\n\nNote\n\nThe pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by using `Install-Module` with `-MaximumVersion`.\n\nYou can also cache dependencies to speed up your workflow. For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\nFor example, the following job installs the `SqlServer` and `PSScriptAnalyzer` modules:\n\n```hljs yaml\njobs:\n  install-dependencies:\n    name: Install dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install from PSGallery\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module SqlServer, PSScriptAnalyzer\n```\n\nNote\n\nBy default, no repositories are trusted by PowerShell. When installing modules from the PowerShell Gallery, you must explicitly set the installation policy for `PSGallery` to `Trusted`.\n\n## Caching dependencies\nYou can cache PowerShell dependencies using a unique key, which allows you to restore the dependencies for future workflows with the [`cache`](https://github.com/marketplace/actions/cache) action. For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\nPowerShell caches its dependencies in different locations, depending on the runner's operating system. For example, the `path` location used in the following Ubuntu example will be different for a Windows operating system.\n\n```hljs yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Setup PowerShell module cache\n    id: cacher\n    uses: actions/cache@v4\n    with:\n      path: \"~/.local/share/powershell/Modules\"\n      key: ${{ runner.os }}-SqlServer-PSScriptAnalyzer\n  - name: Install required PowerShell modules\n    if: steps.cacher.outputs.cache-hit != 'true'\n    shell: pwsh\n    run: |\n      Set-PSRepository PSGallery -InstallationPolicy Trusted\n      Install-Module SqlServer, PSScriptAnalyzer -ErrorAction Stop\n```\n\n## Testing your code\nYou can use the same commands that you use locally to build and test your code.\n\n## Using PSScriptAnalyzer to lint code\nThe following example installs `PSScriptAnalyzer` and uses it to lint all `ps1` files in the repository. For more information, see [PSScriptAnalyzer on GitHub](https://github.com/PowerShell/PSScriptAnalyzer).\n\n```hljs yaml\n  lint-with-PSScriptAnalyzer:\n    name: Install and run PSScriptAnalyzer\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Lint with PSScriptAnalyzer\n        shell: pwsh\n        run: |\n          Invoke-ScriptAnalyzer -Path *.ps1 -Recurse -Outvariable issues\n          $errors   = $issues.Where({$_.Severity -eq 'Error'})\n          $warnings = $issues.Where({$_.Severity -eq 'Warning'})\n          if ($errors) {\n              Write-Error \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\" -ErrorAction Stop\n          } else {\n              Write-Output \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\"\n          }\n```\n\n## Packaging workflow data as artifacts\nYou can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nThe following example demonstrates how you can use the `upload-artifact` action to archive the test results received from `Invoke-Pester`. For more information, see the [`upload-artifact` action](https://github.com/actions/upload-artifact).\n\n```hljs yaml\nname: Upload artifact from Ubuntu\n\non: [push]\n\njobs:\n  upload-pester-results:\n    name: Run Pester and upload results\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Test with Pester\n        shell: pwsh\n        run: Invoke-Pester Unit.Tests.ps1 -Passthru | Export-CliXml -Path Unit.Tests.xml\n      - name: Upload test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: ubuntu-Unit-Tests\n          path: Unit.Tests.xml\n    if: ${{ always() }}\n```\n\nThe `always()` function configures the job to continue processing even if there are test failures. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#always).\n\n## Publishing to PowerShell Gallery\nYou can configure your workflow to publish your PowerShell module to the PowerShell Gallery when your CI tests pass. You can use secrets to store any tokens or credentials needed to publish your package. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\nThe following example creates a package and uses `Publish-Module` to publish it to the PowerShell Gallery:\n\n```hljs yaml\nname: Publish PowerShell Module\n\non:\n  release:\n    types: [created]\n\njobs:\n  publish-to-gallery:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build and publish\n        env:\n          NUGET_KEY: ${{ secrets.NUGET_KEY }}\n        shell: pwsh\n        run: |\n          ./build.ps1 -Path /tmp/samplemodule\n          Publish-Module -Path /tmp/samplemodule -NuGetApiKey $env:NUGET_KEY -Verbose\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing PowerShell?\n\nAssistant: Here are some code examples:\n\n### Adding a workflow for Pester\n```yaml\n```hljs yaml\nname: Test PowerShell on Ubuntu\non: push\n\njobs:\n  pester-test:\n    name: Pester test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Perform a Pester test from the command-line\n        shell: pwsh\n        run: Test-Path resultsfile.log | Should -Be $true\n      - name: Perform a Pester test from the Tests.ps1 file\n        shell: pwsh\n        run: |\n          Invoke-Pester Unit.Tests.ps1 -Passthru\n```\n```\n\n### Installing dependencies\n```yaml\n```hljs yaml\njobs:\n  install-dependencies:\n    name: Install dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install from PSGallery\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module SqlServer, PSScriptAnalyzer\n```\n```\n\n### Caching dependencies\n```yaml\n```hljs yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Setup PowerShell module cache\n    id: cacher\n    uses: actions/cache@v4\n    with:\n      path: \"~/.local/share/powershell/Modules\"\n      key: ${{ runner.os }}-SqlServer-PSScriptAnalyzer\n  - name: Install required PowerShell modules\n    if: steps.cacher.outputs.cache-hit != 'true'\n    shell: pwsh\n    run: |\n      Set-PSRepository PSGallery -InstallationPolicy Trusted\n      Install-Module SqlServer, PSScriptAnalyzer -ErrorAction Stop\n```\n```\n\n### Using PSScriptAnalyzer to lint code\n```yaml\n```hljs yaml\n  lint-with-PSScriptAnalyzer:\n    name: Install and run PSScriptAnalyzer\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Lint with PSScriptAnalyzer\n        shell: pwsh\n        run: |\n          Invoke-ScriptAnalyzer -Path *.ps1 -Recurse -Outvariable issues\n          $errors   = $issues.Where({$_.Severity -eq 'Error'})\n          $warnings = $issues.Where({$_.Severity -eq 'Warning'})\n          if ($errors) {\n              Write-Error \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\" -ErrorAction Stop\n          } else {\n              Write-Output \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\"\n          }\n```\n```\n\n### Packaging workflow data as artifacts\n```yaml\n```hljs yaml\nname: Upload artifact from Ubuntu\n\non: [push]\n\njobs:\n  upload-pester-results:\n    name: Run Pester and upload results\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Test with Pester\n        shell: pwsh\n        run: Invoke-Pester Unit.Tests.ps1 -Passthru | Export-CliXml -Path Unit.Tests.xml\n      - name: Upload test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: ubuntu-Unit-Tests\n          path: Unit.Tests.xml\n    if: ${{ always() }}\n```\n```\n\n### Publishing to PowerShell Gallery\n```yaml\n```hljs yaml\nname: Publish PowerShell Module\n\non:\n  release:\n    types: [created]\n\njobs:\n  publish-to-gallery:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build and publish\n        env:\n          NUGET_KEY: ${{ secrets.NUGET_KEY }}\n        shell: pwsh\n        run: |\n          ./build.ps1 -Path /tmp/samplemodule\n          Publish-Module -Path /tmp/samplemodule -NuGetApiKey $env:NUGET_KEY -Verbose\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing PowerShell?\n\nAssistant: Here are the recommended best practices:\n\n• Always specify the required package versions by using `Install-Module` with `-MaximumVersion`.\n• By default, no repositories are trusted by PowerShell. When installing modules from the PowerShell Gallery, you must explicitly set the installation policy for `PSGallery` to `Trusted`.\n• Use the `always()` function to configure the job to continue processing even if there are test failures.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Monitoring workflows?\n\nAssistant: You can monitor GitHub Actions workflows by using tools like the visualization graph and run logs.\n\nHere's a detailed explanation:\n\n\n## About monitoring workflows\nYou can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.\n\n## Notifications for workflow runs\nYou can subscribe to notifications about workflow runs that you trigger.\n\n## Using the visualization graph\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows.\n\n## Viewing workflow run history\nYou can view logs for each run of a workflow. Logs include the status for each job and step in a workflow.\n\n## Viewing job execution time\nYou can view the execution time of a job, including the billable minutes that a job accrued.\n\n## Adding a workflow status badge\nYou can display a status badge in your repository to indicate the status of your workflows.\n\n## Using workflow run logs\nYou can view, search, and download the logs for each job in a workflow run.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Usage limits, billing, and administration?\n\nAssistant: There are usage limits for GitHub Actions workflows. Usage charges apply to repositories that go beyond the amount of free minutes and storage for a repository.\n\nHere's a detailed explanation:\n\n\n## About billing for GitHub Actions\nGitHub Actions help you automate your software development workflows in the same place you store code and collaborate on pull requests and issues. You can write individual tasks, called actions, and combine them to create a custom workflow. For more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\nGitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions).\n\n## Availability\nGitHub Actions is available on all GitHub products, but GitHub Actions is not available for private repositories owned by accounts using legacy per-repository plans. For more information, see [GitHub’s plans](https://docs.github.com/en/get-started/learning-about-github/githubs-plans).\n\n## Usage limits\nThere are some limits on GitHub Actions usage when using GitHub-hosted runners. These limits are subject to change.\n\nNote\n\nFor self-hosted runners, different usage limits apply. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#usage-limits).\n\n- **Job execution time** - Each job in a workflow can run for up to 6 hours of execution time. If a job reaches this limit, the job is terminated and fails to complete.\n\n- **Workflow run time** - Each workflow run is limited to 35 days. If a workflow run reaches this limit, the workflow run is cancelled. This period includes execution duration, and time spent on waiting and approval.\n\n- **API requests** - You can execute up to 1,000 requests to the GitHub API in an hour across all actions within a repository. If requests are exceeded, additional API calls will fail which might cause jobs to fail.\n\n- **Webhook rate limit** - Each repository is limited to 1500 events triggering a workflow run every 10 seconds. When the limit is reached, the workflow runs that were supposed to be triggered by the webhook events will be blocked and will not be queued.\n\n- **Concurrent jobs** - The number of concurrent jobs you can run in your account depends on your GitHub plan, as well as the type of runner used. If exceeded, any additional jobs are queued.\n\n**Standard GitHub-hosted runners**\n\n| GitHub plan | Total concurrent jobs | Maximum concurrent macOS jobs |\n| --- | --- | --- |\n| Free | 20 | 5 |\n| Pro | 40 | 5 |\n| Team | 60 | 5 |\n| Enterprise | 500 | 50 |\n\n**GitHub-hosted larger runners**\n\n| GitHub plan | Total concurrent jobs | Maximum concurrent macOS jobs | Maximum concurrent GPU jobs |\n| --- | --- | --- | --- |\n| Team | 1000 | 5 | 100 |\n| Enterprise | 1000 | 50 | 100 |\n\nNote\n\n- If required, customers on enterprise plans can request a higher limit for concurrent jobs. For more information, contact us through the [GitHub Support portal](https://support.github.com/), or contact your sales representative.\n- The maximum concurrent macOS jobs is shared across standard GitHub-hosted runner and GitHub-hosted larger runners.\n\n- **Job matrix** - A job matrix can generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.\n\n- **Workflow run queue** - No more than 500 workflow runs can be queued in a 10 second interval per repository. If a workflow run reaches this limit, the workflow run is terminated and fails to complete.\n\n## Usage policy\nIn addition to the usage limits, you must ensure that you use GitHub Actions within the [GitHub Terms of Service](https://docs.github.com/en/site-policy/github-terms/github-terms-of-service). For more information on GitHub Actions-specific terms, see the [GitHub Additional Product Terms](https://docs.github.com/en/site-policy/github-terms/github-terms-for-additional-products-and-features#a-actions-usage).\n\n## GitHub Actions usage metrics\nOrganization owners and users with the \"View organization Actions metrics\" permission can view GitHub Actions usage metrics for their organization. These metrics can help you understand how and where your Actions minutes are being used. For more information, see [Viewing GitHub Actions metrics for your organization](https://docs.github.com/en/enterprise-cloud@latest/organizations/collaborating-with-groups-in-organizations/viewing-usage-metrics-for-github-actions).\n\nWhen you view usage metrics, it is important to remember that GitHub Actions usage metrics do not apply minute multipliers to the metrics displayed. While they _can_ help you understand your bill, their primary purpose is to help you understand how and where Actions minutes are being used in your organization.\n\nFor more information about minute multipliers, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#minute-multipliers).\n\n## Billing for reusable workflows\nIf you reuse a workflow, billing is always associated with the caller workflow. Assignment of GitHub-hosted runners is always evaluated using only the caller's context. The caller cannot use GitHub-hosted runners from the called repository.\n\nFor more information see, [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Artifact and log retention policy\nYou can configure the artifact and log retention period for your repository, organization, or enterprise account.\n\nBy default, the artifacts and log files generated by workflows are retained for 90 days before they are automatically deleted.\nYou can adjust the retention period, depending on the type of repository:\n\n- For public repositories: you can change this retention period to anywhere between 1 day or 90 days.\n- For private repositories: you can change this retention period to anywhere between 1 day or 400 days.\n\nWhen you customize the retention period, it only applies to new artifacts and log files, and does not retroactively apply to existing objects. For managed repositories and organizations, the maximum retention period cannot exceed the limit set by the managing organization or enterprise.\n\nFor more information, see:\n\n- [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#configuring-the-retention-period-for-github-actions-artifacts-and-logs-in-your-repository)\n- [Configuring the retention period for GitHub Actions artifacts and logs in your organization](https://docs.github.com/en/organizations/managing-organization-settings/configuring-the-retention-period-for-github-actions-artifacts-and-logs-in-your-organization)\n- [Enforcing policies for GitHub Actions in your enterprise](https://docs.github.com/en/enterprise-cloud@latest/admin/policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#enforcing-a-policy-for-artifact-and-log-retention-in-your-enterprise)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Usage limits, billing, and administration?\n\nAssistant: Here are the recommended best practices:\n\n• If required, customers on enterprise plans can request a higher limit for concurrent jobs. For more information, contact us through the GitHub Support portal, or contact your sales representative.\n• The maximum concurrent macOS jobs is shared across standard GitHub-hosted runner and GitHub-hosted larger runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing workflow runs and deployments?\n\nAssistant: GitHub enables you to have control over your workflow runs and deployments.\n\nHere's a detailed explanation:\n\n\n## Managing workflow runs\n- [Managing workflow runs](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs)\n  - [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow)\n  - [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs)\n  - [Canceling a workflow](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow)\n  - [Disabling and enabling a workflow](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/disabling-and-enabling-a-workflow)\n  - [Skipping workflow runs](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs)\n  - [Deleting a workflow run](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run)\n  - [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts)\n  - [Removing workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts)\n  - [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/approving-workflow-runs-from-public-forks)\n  - [Approving workflow runs from private forks](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/approving-workflow-runs-from-private-forks)\n\n## Managing deployments\n- [Managing deployments](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments)\n  - [Viewing deployment history](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/viewing-deployment-history)\n  - [Managing environments for deployment](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment)\n  - [Reviewing deployments](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments)\n  - [Creating custom deployment protection rules](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules)\n  - [Configuring custom deployment protection rules](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using GitHub CLI in workflows?\n\nAssistant: You can script with GitHub CLI in GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nGitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable called `GH_TOKEN` to a token with the required scopes.\n\n## Example Workflow: Comment when opened\nThis workflow uses the `gh issue comment` subcommand to add a comment when an issue is opened.\n\n## Example Workflow: Report remaining open issues\nThis workflow first uses the `gh api` subcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using GitHub CLI in workflows?\n\nAssistant: Here are some code examples:\n\n### Comment when opened\n```yaml\nname: Comment when opened\non:\n  issues:\n    types:\n      - opened\njobs:\n  comment:\n    runs-on: ubuntu-latest\n    steps:\n      - run: gh issue comment $ISSUE --body \"Thank you for opening this issue!\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          ISSUE: ${{ github.event.issue.html_url }}\n\n```\n\n### Report remaining open issues\n```yaml\nname: Report remaining open issues\non:\n  schedule:\n    # Daily at 8:20 UTC\n    - cron: '20 8 * * *'\njobs:\n  track_pr:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          numOpenIssues=\"$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='\\\n            query($name: String!, $owner: String!) {\\\n              repository(owner: $owner, name: $name) {\\\n                issues(states:OPEN){\\\n                  totalCount\\\n                }\\\n              }\\\n            }\\\n          ' --jq '.data.repository.issues.totalCount')\"\n\n          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          OWNER: ${{ github.repository_owner }}\n          REPO: ${{ github.event.repository.name }}\n      - run: |\n          gh issue create --title \"Issue report\" --body \"$NUM_OPEN_ISSUES issues remaining\" --repo $GITHUB_REPOSITORY\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using GitHub CLI in workflows?\n\nAssistant: Here are the recommended best practices:\n\n• Set the `GH_TOKEN` environment variable for each step that uses GitHub CLI to ensure proper authentication.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in Azure?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with Azure.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Azure, without needing to store the Azure credentials as long-lived GitHub secrets.\n\nThis guide gives an overview of how to configure Azure to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`azure/login`](https://github.com/Azure/login) action that uses tokens to authenticate to Azure and access resources.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\n## Adding the federated credentials to Azure\nGitHub's OIDC provider works with Azure's workload identity federation. For an overview, see Microsoft's documentation at [Workload identity federation](https://docs.microsoft.com/en-us/azure/active-directory/develop/workload-identity-federation).\n\nTo configure the OIDC identity provider in Azure, you will need to perform the following configuration. For instructions on making these changes, refer to [the Azure documentation](https://docs.microsoft.com/en-us/azure/developer/github/connect-from-azure).\n\nIn the following procedure, you will create an application for Microsoft Entra ID (previously known as Azure AD).\n\n1. Create an Entra ID application and a service principal.\n2. Add federated credentials for the Entra ID application.\n3. Create GitHub secrets for storing Azure configuration.\n\nAdditional guidance for configuring the identity provider:\n\n- For security hardening, make sure you've reviewed [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud). For an example, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-subject-in-your-cloud-provider).\n- For the `audience` setting, `api://AzureADTokenExchange` is the recommended value, but you can also specify other values here.\n\n## Updating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1. Add permissions settings for the token.\n2. Use the [`azure/login`](https://github.com/Azure/login) action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n## Adding permissions settings\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n- Using environment variables on the runner ( `ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n- Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Requesting the access token\nThe [`azure/login`](https://github.com/Azure/login) action receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see the [`azure/login`](https://github.com/Azure/login) documentation.\n\nThe following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources.\n\n```hljs yaml\nname: Run Azure Login with OIDC\non: [push]\n\npermissions:\n  id-token: write\n  contents: read\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Az CLI login'\n        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: 'Run az commands'\n        run: |\n          az account show\n          az group list\n```\n\n## Further reading\n- [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n\n- [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in Azure?\n\nAssistant: Here are some code examples:\n\n### Adding permissions settings\n```yaml\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n```\n\n### Single job permissions settings\n```yaml\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n```\n\n### Run Azure Login with OIDC\n```yaml\n```hljs yaml\nname: Run Azure Login with OIDC\non: [push]\n\npermissions:\n  id-token: write\n  contents: read\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Az CLI login'\n        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: 'Run az commands'\n        run: |\n          az account show\n          az group list\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in Azure?\n\nAssistant: Here are the recommended best practices:\n\n• For security hardening, make sure you've reviewed About security hardening with OpenID Connect.\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Choosing the runner for a job?\n\nAssistant: Define the type of machine that will process a job in your workflow.\n\nHere's a detailed explanation:\n\n\n## Overview\nUse `jobs.<job_id>.runs-on` to define the type of machine to run the job on.\n\n- The destination machine can be either a [GitHub-hosted runner](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#choosing-github-hosted-runners), [larger runner](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#choosing-runners-in-a-group), or a [self-hosted runner](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#choosing-self-hosted-runners).\n\n- You can target runners based on the labels assigned to them, or their group membership, or a combination of these.\n\n- You can provide `runs-on` as:\n  - A single string\n  - A single variable containing a string\n  - An array of strings, variables containing strings, or a combination of both\n  - A `key: value` pair using the `group` or `labels` keys\n- If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified `runs-on` values. For example, here the job will only run on a self-hosted runner that has the labels `linux`, `x64`, and `gpu`:\n\n```hljs yaml\nruns-on: [self-hosted, linux, x64, gpu]\n```\n\nFor more information, see [Choosing self-hosted runners](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#choosing-self-hosted-runners).\n\n- You can mix strings and variables in an array. For example:\n\n```hljs yaml\non:\n    workflow_dispatch:\n      inputs:\n        chosen-os:\n          required: true\n          type: choice\n          options:\n        - Ubuntu\n        - macOS\n\njobs:\ntest:\n    runs-on: [self-hosted, \"${{ inputs.chosen-os }}\"]\n    steps:\n    - run: echo Hello world!\n```\n\n- If you would like to run your workflow on multiple machines, use [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy).\n\nNote\n\nQuotation marks are not required around simple strings like `self-hosted`, but they are required for expressions like `\"${{ inputs.chosen-os }}\"`.\n\n## Choosing GitHub-hosted runners\nIf you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by `runs-on`.\n\nThe value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.\n\nFor more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).\n\n### Standard GitHub-hosted runners for public repositories\n\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 4 | 16 GB | 14 GB | x64 | `ubuntu-latest`,<br> `ubuntu-24.04`,<br> `ubuntu-22.04`,<br> `ubuntu-20.04` |\n| Windows | 4 | 16 GB | 14 GB | x64 | `windows-latest`,<br> `windows-2025`\\[Public preview\\],<br> `windows-2022`,<br> `windows-2019` |\n| Linux \\[Public preview\\] | 4 | 16 GB | 14 GB | arm64 | `ubuntu-24.04-arm`,<br> `ubuntu-22.04-arm` |\n| macOS | 4 | 14 GB | 14 GB | Intel | `macos-13` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `macos-latest`,<br> `macos-14`,<br> `macos-15` \\[Public preview\\] |\n\nNote\n\nThe arm64 Linux runner is in public preview and subject to change.\n\n### Standard GitHub-hosted runners for private repositories\n\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#per-minute-rates).\n\n| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |\n| --- | --- | --- | --- | --- | --- |\n| Linux | 2 | 7 GB | 14 GB | x64 | `ubuntu-latest`,<br> `ubuntu-24.04`,<br> `ubuntu-22.04`,<br> `ubuntu-20.04` |\n| Windows | 2 | 7 GB | 14 GB | x64 | `windows-latest`,<br> `windows-2025`\\[Public preview\\],<br> `windows-2022`,<br> `windows-2019` |\n| macOS | 4 | 14 GB | 14 GB | Intel | `macos-13` |\n| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `macos-latest`,<br> `macos-14`,<br> `macos-15` \\[Public preview\\] |\n\nIn addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see [About larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners/about-larger-runners).\n\nNote\n\nThe `-latest` runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.\n\nWarning\n\nBeta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.\n\n#### Example: Specifying an operating system\n\n```hljs yaml\nruns-on: ubuntu-latest\n```\n\nFor more information, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).\n\n## Choosing self-hosted runners\nTo specify a self-hosted runner for your job, configure `runs-on` in your workflow file with self-hosted runner labels.\n\nSelf-hosted runners may have the `self-hosted` label. When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\n\nNote that Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.\n\n#### Example: Using labels for runner selection\n\n```hljs yaml\nruns-on: [self-hosted, linux]\n```\n\nFor more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners) and [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow).\n\n## Choosing runners in a group\nYou can use `runs-on` to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.\n\nRunner groups can only have [larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners) or [self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners) as members.\n\n#### Example: Using groups to control where jobs are run\n\nIn this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:\n\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\ncheck-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n#### Example: Combining groups and labels\n\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:\n\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\ncheck-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Choosing the runner for a job?\n\nAssistant: Here are some code examples:\n\n### Example: Specifying an operating system\n```yaml\n```hljs yaml\nruns-on: ubuntu-latest\n```\n```\n\n### Example: Using labels for runner selection\n```yaml\n```hljs yaml\nruns-on: [self-hosted, linux]\n```\n```\n\n### Example: Using groups to control where jobs are run\n```yaml\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\ncheck-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n### Example: Combining groups and labels\n```yaml\n```hljs yaml\nname: learn-github-actions\non: [push]\njobs:\ncheck-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Choosing the runner for a job?\n\nAssistant: Here are the recommended best practices:\n\n• Quotation marks are not required around simple strings like `self-hosted`, but they are required for expressions like `\"${{ inputs.chosen-os }}\"`.\n• When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied.\n• We recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Azure Pipelines to GitHub Actions?\n\nAssistant: GitHub Actions and Azure Pipelines share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\nHere's a detailed explanation:\n\n\n## Introduction\nAzure Pipelines and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Azure Pipelines and GitHub Actions share some similarities in workflow configuration:\n\n- Workflow configuration files are written in YAML and are stored in the code's repository.\n- Workflows include one or more jobs.\n- Jobs include one or more steps or individual commands.\n- Steps or tasks can be reused and shared with the community.\n\nFor more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## Key differences\nWhen migrating from Azure Pipelines, consider the following differences:\n\n- Azure Pipelines supports a legacy _classic editor_, which lets you define your CI configuration in a GUI editor instead of creating the pipeline definition in a YAML file. GitHub Actions uses YAML files to define workflows and does not support a graphical editor.\n- Azure Pipelines allows you to omit some structure in job definitions. For example, if you only have a single job, you don't need to define the job and only need to define its steps. GitHub Actions requires explicit configuration, and YAML structure cannot be omitted.\n- Azure Pipelines supports _stages_ defined in the YAML file, which can be used to create deployment workflows. GitHub Actions requires you to separate stages into separate YAML workflow files.\n- On-premises Azure Pipelines build agents can be selected with capabilities. GitHub Actions self-hosted runners can be selected with labels.\n\n## Migrating jobs and steps\nJobs and steps in Azure Pipelines are very similar to jobs and steps in GitHub Actions. In both systems, jobs have the following characteristics:\n\n- Jobs contain a series of steps that run sequentially.\n- Jobs run on separate virtual machines or in separate containers.\n- Jobs run in parallel by default, but can be configured to run sequentially.\n\n## Migrating script steps\nYou can run a script or a shell command as a step in a workflow. In Azure Pipelines, script steps can be specified using the `script` key, or with the `bash`, `powershell`, or `pwsh` keys. Scripts can also be specified as an input to the [Bash task](https://docs.microsoft.com/azure/devops/pipelines/tasks/utility/bash?view=azure-devops) or the [PowerShell task](https://docs.microsoft.com/azure/devops/pipelines/tasks/utility/powershell?view=azure-devops).\n\nIn GitHub Actions, all scripts are specified using the `run` key. To select a particular shell, you can specify the `shell` key when providing the script. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun).\n\n## Differences in script error handling\nIn Azure Pipelines, scripts can be configured to error if any output is sent to `stderr`. GitHub Actions does not support this configuration.\n\nGitHub Actions configures shells to \"fail fast\" whenever possible, which stops the script immediately if one of the commands in a script exits with an error code. In contrast, Azure Pipelines requires explicit configuration to exit immediately on an error. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#exit-codes-and-error-action-preference).\n\n## Differences in the default shell on Windows\nIn Azure Pipelines, the default shell for scripts on Windows platforms is the Command shell ( _cmd.exe_). In GitHub Actions, the default shell for scripts on Windows platforms is PowerShell. PowerShell has several differences in built-in commands, variable expansion, and flow control.\n\nIf you're running a simple command, you might be able to run a Command shell script in PowerShell without any changes. But in most cases, you will either need to update your script with PowerShell syntax or instruct GitHub Actions to run the script with the Command shell instead of PowerShell. You can do this by specifying `shell` as `cmd`.\n\n## Migrating conditionals and expression syntax\nAzure Pipelines and GitHub Actions can both run steps conditionally. In Azure Pipelines, conditional expressions are specified using the `condition` key. In GitHub Actions, conditional expressions are specified using the `if` key.\n\nAzure Pipelines uses functions within expressions to execute steps conditionally. In contrast, GitHub Actions uses an infix notation. For example, you must replace the `eq` function in Azure Pipelines with the `==` operator in GitHub Actions.\n\n## Dependencies between jobs\nBoth Azure Pipelines and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies can be specified explicitly. In Azure Pipelines, this is done with the `dependsOn` key. In GitHub Actions, this is done with the `needs` key.\n\n## Migrating tasks to actions\nAzure Pipelines uses _tasks_, which are application components that can be re-used in multiple workflows. GitHub Actions uses _actions_, which can be used to perform tasks and customize your workflow. In both systems, you can specify the name of the task or action to run, along with any required inputs as key/value pairs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Azure Pipelines to GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### Azure Pipelines syntax for script steps\n```yaml\njobs:\n  - job: scripts\n    pool:\n      vmImage: 'windows-latest'\n    steps:\n      - script: echo \"This step runs in the default shell\"\n      - bash: echo \"This step runs in bash\"\n      - pwsh: Write-Host \"This step runs in PowerShell Core\"\n      - task: PowerShell@2\n        inputs:\n          script: Write-Host \"This step runs in PowerShell\"\n```\n\n### GitHub Actions syntax for script steps\n```yaml\njobs:\n  scripts:\n    runs-on: windows-latest\n    steps:\n      - run: echo \"This step runs in the default shell\"\n      - run: echo \"This step runs in bash\"\n        shell: bash\n      - run: Write-Host \"This step runs in PowerShell Core\"\n        shell: pwsh\n      - run: Write-Host \"This step runs in PowerShell\"\n        shell: powershell\n```\n\n### Azure Pipelines syntax using CMD by default\n```yaml\njobs:\n  - job: run_command\n    pool:\n      vmImage: 'windows-latest'\n    steps:\n      - script: echo \"This step runs in CMD on Windows by default\"\n```\n\n### GitHub Actions syntax for specifying CMD\n```yaml\njobs:\n  run_command:\n    runs-on: windows-latest\n    steps:\n      - run: echo \"This step runs in PowerShell on Windows by default\"\n      - run: echo \"This step runs in CMD on Windows explicitly\"\n        shell: cmd\n```\n\n### Azure Pipelines syntax for conditional expressions\n```yaml\njobs:\n  - job: conditional\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - script: echo \"This step runs with str equals 'ABC' and num equals 123\"\n        condition: and(eq(variables.str, 'ABC'), eq(variables.num, 123))\n```\n\n### GitHub Actions syntax for conditional expressions\n```yaml\njobs:\n  conditional:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This step runs with str equals 'ABC' and num equals 123\"\n        if: ${{ env.str == 'ABC' && env.num == 123 }}\n```\n\n### Azure Pipelines syntax for dependencies between jobs\n```yaml\njobs:\n  - job: initial\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - script: echo \"This job will be run first.\"\n  - job: fanout1\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: initial\n    steps:\n      - script: echo \"This job will run after the initial job, in parallel with fanout2.\"\n  - job: fanout2\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: initial\n    steps:\n      - script: echo \"This job will run after the initial job, in parallel with fanout1.\"\n  - job: fanin\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: [fanout1, fanout2]\n    steps:\n      - script: echo \"This job will run after fanout1 and fanout2 have finished.\"\n```\n\n### GitHub Actions syntax for dependencies between jobs\n```yaml\njobs:\n  initial:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first.\"\n  fanout1:\n    runs-on: ubuntu-latest\n    needs: initial\n    steps:\n      - run: echo \"This job will run after the initial job, in parallel with fanout2.\"\n  fanout2:\n    runs-on: ubuntu-latest\n    needs: initial\n    steps:\n      - run: echo \"This job will run after the initial job, in parallel with fanout1.\"\n  fanin:\n    runs-on: ubuntu-latest\n    needs: [fanout1, fanout2]\n    steps:\n      - run: echo \"This job will run after fanout1 and fanout2 have finished.\"\n```\n\n### Azure Pipelines syntax for tasks\n```yaml\njobs:\n  - job: run_python\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - task: UsePythonVersion@0\n        inputs:\n          versionSpec: '3.7'\n          architecture: 'x64'\n      - script: python script.py\n```\n\n### GitHub Actions syntax for actions\n```yaml\njobs:\n  run_python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.7'\n          architecture: 'x64'\n      - run: python script.py\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from GitLab CI/CD to GitHub Actions?\n\nAssistant: GitHub Actions and GitLab CI/CD share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\nHere's a detailed explanation:\n\n\n## Introduction\nGitLab CI/CD and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. GitLab CI/CD and GitHub Actions share some similarities in workflow configuration:\n\n- Workflow configuration files are written in YAML and are stored in the code's repository.\n- Workflows include one or more jobs.\n- Jobs include one or more steps or individual commands.\n- Jobs can run on either managed or self-hosted machines.\n\nThere are a few differences, and this guide will show you the important differences so that you can migrate your workflow to GitHub Actions.\n\n## Jobs\nJobs in GitLab CI/CD are very similar to jobs in GitHub Actions. In both systems, jobs have the following characteristics:\n\n- Jobs contain a series of steps or scripts that run sequentially.\n- Jobs can run on separate machines or in separate containers.\n- Jobs run in parallel by default, but can be configured to run sequentially.\n\nYou can run a script or a shell command in a job. In GitLab CI/CD, script steps are specified using the `script` key. In GitHub Actions, all scripts are specified using the `run` key.\n\n## Runners\nRunners are machines on which the jobs run. Both GitLab CI/CD and GitHub Actions offer managed and self-hosted variants of runners. In GitLab CI/CD, `tags` are used to run jobs on different platforms, while in GitHub Actions it is done with the `runs-on` key.\n\n## Docker images\nBoth GitLab CI/CD and GitHub Actions support running jobs in a Docker image. In GitLab CI/CD, Docker images are defined with an `image` key, while in GitHub Actions it is done with the `container` key.\n\n## Condition and expression syntax\nGitLab CI/CD uses `rules` to determine if a job will run for a specific condition. GitHub Actions uses the `if` keyword to prevent a job from running unless a condition is met.\n\n## Dependencies between Jobs\nBoth GitLab CI/CD and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies in GitHub Actions can be specified explicitly with the `needs` key. GitLab CI/CD also has a concept of `stages`, where jobs in a stage run concurrently, but the next stage will start when all the jobs in the previous stage have completed.\n\n## Scheduling workflows\nBoth GitLab CI/CD and GitHub Actions allow you to run workflows at a specific interval. In GitLab CI/CD, pipeline schedules are configured with the UI, while in GitHub Actions you can trigger a workflow on a scheduled interval with the \"on\" key.\n\n## Variables and secrets\nGitLab CI/CD and GitHub Actions support setting variables in the pipeline or workflow configuration file, and creating secrets using the GitLab or GitHub UI.\n\n## Caching\nGitLab CI/CD and GitHub Actions provide a method in the configuration file to manually cache workflow files.\n\n## Artifacts\nBoth GitLab CI/CD and GitHub Actions can upload files and directories created by a job as artifacts. In GitHub Actions, artifacts can be used to persist data across multiple jobs.\n\n## Databases and service containers\nBoth systems enable you to include additional containers for databases, caching, or other dependencies.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from GitLab CI/CD to GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### GitLab CI/CD syntax for jobs\n```yaml\njob1:\n  variables:\n    GIT_CHECKOUT: \"true\"\n  script:\n    - echo \"Run your script here\"\n```\n\n### GitHub Actions syntax for jobs\n```yaml\njobs:\n  job1:\n    steps:\n      - uses: actions/checkout@v4\n      - run: echo \"Run your script here\"\n```\n\n### GitLab CI/CD syntax for runners\n```yaml\nwindows_job:\n  tags:\n    - windows\n  script:\n    - echo Hello, %USERNAME%!\n\nlinux_job:\n  tags:\n    - linux\n  script:\n    - echo \"Hello, $USER!\"\n```\n\n### GitHub Actions syntax for runners\n```yaml\nwindows_job:\n  runs-on: windows-latest\n  steps:\n    - run: echo Hello, %USERNAME%!\n\nlinux_job:\n  runs-on: ubuntu-latest\n  steps:\n    - run: echo \"Hello, $USER!\"\n```\n\n### GitLab CI/CD syntax for Docker images\n```yaml\nmy_job:\n  image: node:20-bookworm-slim\n```\n\n### GitHub Actions syntax for Docker images\n```yaml\njobs:\n  my_job:\n    container: node:20-bookworm-slim\n```\n\n### GitLab CI/CD syntax for conditions and expressions\n```yaml\ndeploy_prod:\n  stage: deploy\n  script:\n    - echo \"Deploy to production server\"\n  rules:\n    - if: '$CI_COMMIT_BRANCH == \"master\"' \n```\n\n### GitHub Actions syntax for conditions and expressions\n```yaml\njobs:\n  deploy_prod:\n    if: contains( github.ref, 'master')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploy to production server\"\n```\n\n### GitLab CI/CD syntax for dependencies between jobs\n```yaml\nstages:\n  - build\n  - test\n  - deploy\n\nbuild_a:\n  stage: build\n  script:\n    - echo \"This job will run first.\"\n\nbuild_b:\n  stage: build\n  script:\n    - echo \"This job will run first, in parallel with build_a.\"\n\ntest_ab:\n  stage: test\n  script:\n    - echo \"This job will run after build_a and build_b have finished.\"\n\ndeploy_ab:\n  stage: deploy\n  script:\n    - echo \"This job will run after test_ab is complete\"\n```\n\n### GitHub Actions syntax for dependencies between jobs\n```yaml\njobs:\n  build_a:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first.\"\n\n  build_b:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first, in parallel with build_a\"\n\n  test_ab:\n    runs-on: ubuntu-latest\n    needs: [build_a,build_b]\n    steps:\n      - run: echo \"This job will run after build_a and build_b have finished\"\n\n  deploy_ab:\n    runs-on: ubuntu-latest\n    needs: [test_ab]\n    steps:\n      - run: echo \"This job will run after test_ab is complete\"\n```\n\n### GitLab CI/CD syntax for caching\n```yaml\nimage: node:latest\n\ncache:\n  key: $CI_COMMIT_REF_SLUG\n  paths:\n    - .npm/\n\nbefore_script:\n  - npm ci --cache .npm --prefer-offline\n\ntest_async:\n  script:\n    - node ./specs/start.js ./specs/async.spec.js\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from GitLab CI/CD to GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure to review the differences in syntax between GitLab CI/CD and GitHub Actions to avoid migration issues.\n• Utilize the `needs` key in GitHub Actions to manage job dependencies effectively.\n• Leverage caching to speed up your workflows and reduce redundant work.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Security for GitHub Actions?\n\nAssistant: Use security best practices with GitHub Actions, and use GitHub Actions to improve the security of your software supply chain.\n\nHere's a detailed explanation:\n\n\n## Security guides\n- [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions)\n\n  - [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions)\n\n  - [Automatic token authentication](https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication)\n\n  - [Using GitHub's security features to secure your use of GitHub Actions](https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions)\n\n## Using artifact attestations\n- [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds)\n\n  - [Using artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3)\n\n  - [Enforcing artifact attestations with a Kubernetes admission controller](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller)\n\n  - [Verifying attestations offline](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline)\n\n## Security hardening your deployments\n- [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect)\n\n  - [Configuring OpenID Connect in Amazon Web Services](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)\n\n  - [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure)\n\n  - [Configuring OpenID Connect in Google Cloud Platform](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform)\n\n  - [Configuring OpenID Connect in HashiCorp Vault](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault)\n\n  - [Configuring OpenID Connect in JFrog](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog)\n\n  - [Configuring OpenID Connect in PyPI](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi)\n\n  - [Configuring OpenID Connect in cloud providers](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers)\n\n  - [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Travis CI to GitHub Actions?\n\nAssistant: This guide helps you migrate from Travis CI to GitHub Actions. It compares their concepts and syntax, describes the similarities, and demonstrates their different approaches to common tasks.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide helps you migrate from Travis CI to GitHub Actions. It compares their concepts and syntax, describes the similarities, and demonstrates their different approaches to common tasks.\n\n## Before you start\nBefore starting your migration to GitHub Actions, it would be useful to become familiar with how it works:\n\n- For a quick example that demonstrates a GitHub Actions job, see Quickstart for GitHub Actions.\n- To learn the essential GitHub Actions concepts, see Understanding GitHub Actions.\n\n## Comparing job execution\nTo give you control over when CI tasks are executed, a GitHub Actions workflow uses jobs that run in parallel by default. Each job contains steps that are executed in a sequence that you define. If you need to run setup and cleanup actions for a job, you can define steps in each job to perform these.\n\n## Key similarities\nGitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process.\n\n## Using YAML syntax\nTravis CI and GitHub Actions both use YAML to create jobs and workflows, and these files are stored in the code's repository. For more information on how GitHub Actions uses YAML, see Understanding GitHub Actions.\n\n## Custom variables\nTravis CI lets you set variables and share them between stages. Similarly, GitHub Actions lets you define variables for a workflow. For more information, see Store information in variables.\n\n## Default variables\nTravis CI and GitHub Actions both include default environment variables that you can use in your YAML files. For GitHub Actions, you can see these listed in Store information in variables.\n\n## Parallel job processing\nTravis CI can use stages to run jobs in parallel. Similarly, GitHub Actions runs jobs in parallel. For more information, see About workflows.\n\n## Status badges\nTravis CI and GitHub Actions both support status badges, which let you indicate whether a build is passing or failing. For more information, see Adding a workflow status badge.\n\n## Using a matrix\nTravis CI and GitHub Actions both support a matrix, allowing you to perform testing using combinations of operating systems and software packages. For more information, see Running variations of jobs in a workflow.\n\n## Targeting specific branches\nTravis CI and GitHub Actions both allow you to target your CI to a specific branch. For more information, see Workflow syntax for GitHub Actions.\n\n## Checking out submodules\nTravis CI and GitHub Actions both allow you to control whether submodules are included in the repository clone.\n\n## Using environment variables in a matrix\nTravis CI and GitHub Actions can both add custom variables to a test matrix, which allows you to refer to the variable in a later step.\n\n## Key features in GitHub Actions\nWhen migrating from Travis CI, consider the following key features in GitHub Actions.\n\n## Storing secrets\nGitHub Actions allows you to store secrets and reference them in your jobs.\n\n## Sharing files between jobs and workflows\nGitHub Actions includes integrated support for artifact storage, allowing you to share files between jobs in a workflow.\n\n## Hosting your own runners\nIf your jobs require specific hardware or software, GitHub Actions allows you to host your own runners and send your jobs to them for processing.\n\n## Concurrent jobs and execution time\nThe concurrent jobs and workflow execution times in GitHub Actions can vary depending on your GitHub plan.\n\n## Using different languages in GitHub Actions\nWhen working with different languages in GitHub Actions, you can create a step in your job to set up your language dependencies.\n\n## Executing scripts\nGitHub Actions can use run steps to run scripts or shell commands.\n\n## Error handling in GitHub Actions\nWhen migrating to GitHub Actions, there are different approaches to error handling that you might need to be aware of.\n\n## Migrating syntax for conditionals and expressions\nTo run jobs under conditional expressions, Travis CI and GitHub Actions share a similar if condition syntax.\n\n## Migrating phases to steps\nWhere Travis CI uses phases to run steps, GitHub Actions has steps which execute actions.\n\n## Caching dependencies\nTravis CI and GitHub Actions let you manually cache dependencies for later reuse.\n\n## Examples of common tasks\nThis section compares how GitHub Actions and Travis CI perform common tasks.\n\n## Configuring environment variables\nYou can create custom environment variables in a GitHub Actions job.\n\n## Building with Node.js\nThis section compares how to build with Node.js in both Travis CI and GitHub Actions.\n\n## Next steps\nTo continue learning about the main features of GitHub Actions, see Writing workflows.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Travis CI to GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### Travis CI syntax for a matrix\n```yaml\nmatrix:\n  include:\n    - rvm: '2.5'\n    - rvm: '2.6.3'\n```\n\n### GitHub Actions syntax for a matrix\n```yaml\njobs:\n  build:\n    strategy:\n      matrix:\n        ruby: ['2.5', '2.6.3']\n```\n\n### Travis CI syntax for targeting specific branches\n```yaml\nbranches:\n  only:\n    - main\n    - 'mona/octocat'\n```\n\n### GitHub Actions syntax for targeting specific branches\n```yaml\non:\n  push:\n    branches:\n      - main\n      - 'mona/octocat'\n```\n\n### Travis CI syntax for checking out submodules\n```yaml\ngit:\n  submodules: false\n```\n\n### GitHub Actions syntax for checking out submodules\n```yaml\n- uses: actions/checkout@v4\n  with:\n    submodules: false\n```\n\n### Using environment variables in a matrix\n```yaml\nname: Node.js CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n       include:\n         - node-version: '14.x'\n           site: \"prod\"\n           datacenter: \"site-a\"\n         - node-version: '16.x'\n           site: \"dev\"\n           datacenter: \"site-b\"\n    steps:\n      - name: Echo site details\n        env:\n          SITE: ${{ matrix.site }}\n          DATACENTER: ${{ matrix.datacenter }}\n        run: echo $SITE $DATACENTER\n```\n\n### Travis CI syntax for phases and steps\n```yaml\nlanguage: python\npython:\n  - \"3.7\"\n\nscript:\n  - python script.py\n```\n\n### GitHub Actions syntax for steps and actions\n```yaml\njobs:\n  run_python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.7'\n          architecture: 'x64'\n      - run: python script.py\n```\n\n### Travis CI syntax for caching\n```yaml\nlanguage: node_js\ncache: npm\n```\n\n### GitHub Actions syntax for caching\n```yaml\n- name: Cache node modules\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: v1-npm-deps-\n```\n\n### Travis CI syntax for an environment variable\n```yaml\nenv:\n  - MAVEN_PATH=\"/usr/local/maven\"\n```\n\n### GitHub Actions workflow with an environment variable\n```yaml\njobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from Travis CI to GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• Familiarize yourself with GitHub Actions concepts before migrating.\n• Utilize YAML syntax for defining jobs and workflows.\n• Leverage custom and default variables effectively.\n• Take advantage of parallel job processing for efficiency.\n• Use status badges to monitor build status.\n• Implement matrix builds for testing across multiple environments.\n• Ensure proper error handling in your workflows.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About Actions Runner Controller?\n\nAssistant: You can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## About Actions Runner Controller\nActions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, see [Operator pattern](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) in the Kubernetes documentation.\n\nWith ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, see [Autoscaling with self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners).\n\nThe following diagram illustrates the architecture of ARC's autoscaling runner scaleset mode.\n\nNote\n\nTo view the following diagram in a larger size, see the [Autoscaling Runner Scale Sets mode](https://github.com/actions/actions-runner-controller/blob/master/docs/gha-runner-scale-set-controller/README.md#how-it-works) documentation in the Actions Runner Controller repository.\n\n![Diagram showing ARC's autoscaling runner ScaleSet mode.](https://docs.github.com/assets/cb-497738/images/help/actions/arc-diagram.png)\n\n01. Actions Runner Controller is installed using the supplied Helm charts, and the controller manager pod is deployed in the specified namespace. A new AutoScalingRunnerSet resource is deployed via the supplied Helm charts or a customized manifest file. The AutoScalingRunnerSet Controller calls GitHub's APIs to fetch the runner group ID that the runner scale set will belong to.\n02. The AutoScalingRunnerSet Controller calls the APIs one more time to either fetch or create a runner scale set in the GitHub Actions service before creating the Runner ScaleSet Listener resource.\n03. A Runner ScaleSet Listener pod is deployed by the AutoScalingListener Controller. In this pod, the listener application connects to the GitHub Actions Service to authenticate and establish an HTTPS long poll connection. The listener stays idle until it receives a `Job Available` message from the GitHub Actions Service.\n04. When a workflow run is triggered from a repository, the GitHub Actions Service dispatches individual job runs to the runners or runner scalesets where the `runs-on` key matches the name of the runner scaleset or labels of self-hosted runners.\n05. When the Runner ScaleSet Listener receives the `Job Available` message, it checks whether it can scale up to the desired count. If it can, the Runner ScaleSet Listener acknowledges the message.\n06. The Runner ScaleSet Listener uses a Service Account and a Role bound to that account to make an HTTPS call through the Kubernetes APIs to patch the Ephemeral RunnerSet resource with the number of desired replicas count.\n07. The Ephemeral RunnerSet attempts to create new runners and the EphemeralRunner Controller requests a Just-in-Time (JIT) configuration token to register these runners. The controller attempts to create runner pods. If the pod's status is `failed`, the controller retries up to 5 times. After 24 hours the GitHub Actions Service unassigns the job if no runner accepts it.\n08. Once the runner pod is created, the runner application in the pod uses the JIT configuration token to register itself with the GitHub Actions Service. It then establishes another HTTPS long poll connection to receive the job details it needs to execute.\n09. The GitHub Actions Service acknowledges the runner registration and dispatches the job run details.\n10. Throughout the job run execution, the runner continuously communicates the logs and job run status back to the GitHub Actions Service.\n11. When the runner completes its job successfully, the EphemeralRunner Controller checks with the GitHub Actions Service to see if runner can be deleted. If it can, the Ephemeral RunnerSet deletes the runner.\n\n## Actions Runner Controller components\nARC consists of a set of resources, some of which are created specifically for ARC. An ARC deployment applies these resources onto a Kubernetes cluster. Once applied, it creates a set of Pods that contain your self-hosted runners' containers. With ARC, GitHub can treat these runner containers as self-hosted runners and allocate jobs to them as needed.\n\nEach resource that is deployed by ARC is given a name composed of:\n\n- An installation name, which is the installation name you specify when you install the Helm chart.\n- A resource identification suffix, which is a string that identifies the resource type. This value is not configurable.\n\nNote\n\nDifferent versions of Kubernetes have different length limits for names of resources. The length limit for the resource name is calculated by adding the length of the installation name and the length of the resource identification suffix. If the resource name is longer than the reserved length, you will receive an error.\n\n## Resources deployed by `gha-runner-scale-set-controller`\n| Template | Resource Kind | Name | Reserved Length | Description | Notes |\n| --- | --- | --- | --- | --- | --- |\n| `deployment.yaml` | Deployment | INSTALLATION_NAME-gha-rs-controller | 18 | The resource running controller-manager | The pods created by this resource have the ReplicaSet suffix and the Pod suffix. |\n| `serviceaccount.yaml` | ServiceAccount | INSTALLATION_NAME-gha-rs-controller | 18 | This is created if `serviceAccount.create` in `values.yaml` is set to true. | The name can be customized in `values.yaml` |\n| `manager_cluster_role.yaml` | ClusterRole | INSTALLATION_NAME-gha-rs-controller | 18 | ClusterRole for the controller manager | This is created if the value of `flags.watchSingleNamespace` is empty. |\n| `manager_cluster_role_binding.yaml` | ClusterRoleBinding | INSTALLATION_NAME-gha-rs-controller | 18 | ClusterRoleBinding for the controller manager | This is created if the value of `flags.watchSingleNamespace` is empty. |\n| `manager_single_namespace_controller_role.yaml` | Role | INSTALLATION_NAME-gha-rs-controller-single-namespace | 35 | Role for the controller manager | This is created if the value of `flags.watchSingleNamespace` is set. |\n| `manager_single_namespace_controller_role_binding.yaml` | RoleBinding | INSTALLATION_NAME-gha-rs-controller-single-namespace | 35 | RoleBinding for the controller manager | This is created if the value of `flags.watchSingleNamespace` is set. |\n| `manager_single_namespace_watch_role.yaml` | Role | INSTALLATION_NAME-gha-rs-controller-single-namespace-watch | 41 | Role for the controller manager for the namespace configured | This is created if the value of `flags.watchSingleNamespace` is set. |\n| `manager_single_namespace_watch_role_binding.yaml` | RoleBinding | INSTALLATION_NAME-gha-rs-controller-single-namespace-watch | 41 | RoleBinding for the controller manager for the namespace configured | This is created if the value of `flags.watchSingleNamespace` is set. |\n| `manager_listener_role.yaml` | Role | INSTALLATION_NAME-gha-rs-controller-listener | 26 | Role for the listener | This is always created. |\n| `manager_listener_role_binding.yaml ` | RoleBinding | INSTALLATION_NAME-gha-rs-controller-listener | 26 | RoleBinding for the listener | This is always created and binds the listener role with the service account, which is either created by `serviceaccount.yaml` or configured with `values.yaml`. |\n\n## Resources deployed by `gha-runner-scale-set`\n| Template | Resource Kind | Name | Reserved Length | Description | Notes |\n| --- | --- | --- | --- | --- | --- |\n| `autoscalingrunnerset.yaml` | AutoscalingRunnerSet | INSTALLATION_NAME | 0 | Top level resource working with scale sets | The name is limited to 45 characters in length. |\n| `no_permission_service_account.yaml` | ServiceAccount | INSTALLATION_NAME-gha-rs-no-permission | 21 | Service account mounted to the runner container | This is created if the container mode is not \"kubernetes\" and `template.spec.serviceAccountName` is not specified. |\n| `githubsecret.yaml` | Secret | INSTALLATION_NAME-gha-rs-github-secret | 20 | Secret containing values needed to authenticate to the GitHub API | This is created if `githubConfigSecret` is an object. If a string is provided, this secret will not be created. |\n| `manager_role.yaml` | Role | INSTALLATION_NAME-gha-rs-manager | 15 | Role provided to the manager to be able to reconcile on resources in the autoscaling runner set's namespace | This is always created. |\n| `manager_role_binding.yaml` | RoleBinding | INSTALLATION_NAME-gha-rs-manager | 15 | Binding manager_role to the manager service account. | This is always created. |\n| `kube_mode_role.yaml` | Role | INSTALLATION_NAME-gha-rs-kube-mode | 17 | Role providing necessary permissions for the hook | This is created when the container mode is set to \"kubernetes\" and `template.spec.serviceAccount` is not provided. |\n| `kube_mode_serviceaccount.yaml` | ServiceAccount | INSTALLATION_NAME-gha-rs-kube-mode | 17 | Service account bound to the runner pod. | This is created when the container mode is set to \"kubernetes\" and `template.spec.serviceAccount` is not provided. |\n\n## About custom resources\nARC consists of several custom resource definitions (CRDs). For more information on custom resources, see [Custom Resources](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) in the Kubernetes documentation. You can find the list of custom resource definitions used for ARC in the following API schema definitions.\n\n- [actions.github.com/v1alpha1](https://pkg.go.dev/github.com/actions/actions-runner-controller/apis/actions.github.com/v1alpha1)\n- [actions.summerwind.net/v1alpha1](https://pkg.go.dev/github.com/actions/actions-runner-controller/apis/actions.summerwind.net/v1alpha1)\n\nBecause custom resources are extensions of the Kubernetes API, they won't be available in a default Kubernetes installation. You will need to install these custom resources to use ARC. For more information on installing custom resources, see [Quickstart for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller).\n\nOnce the custom resources are installed, you can deploy ARC into your Kubernetes cluster. For information about deploying ARC, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller).\n\n## About the runner container image\nGitHub maintains a [minimal runner container image](https://github.com/actions/runner/pkgs/container/actions-runner). A new image will be published with every runner binaries release. The most recent image will have the runner binaries version and `latest` as tags.\n\nThis image contains the least amount of packages necessary for the container runtime and the runner binaries. To install additional software, you can create your own runner image. You can use ARC's runner image as a base, or use the corresponding setup actions. For instance, `actions/setup-java` for Java or `actions/setup-node` for Node.\n\nYou can find the definition of ARC's runner image in [this Dockerfile](https://github.com/actions/runner/blob/main/images/Dockerfile) and the definition of the base image in [this Dockerfile](https://github.com/dotnet/dotnet-docker/blob/main/src/runtime-deps/8.0/bookworm-slim/amd64/Dockerfile).\n\n## Creating your own runner image\nYou can create your own runner image that meets your requirements. Your runner image must fulfill the following conditions.\n\n- Use a base image that can run the self-hosted runner application. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n- The [runner binary](https://github.com/actions/runner/releases) must be placed under `/home/runner/` and launched using `/home/runner/run.sh`.\n- If you use Kubernetes mode, the [runner container hooks](https://github.com/actions/runner-container-hooks/releases) must be placed under `/home/runner/k8s`.\n\nYou can use the following example Dockerfile to start creating your own runner image.\n\n```hljs dockerfile\nFROM mcr.microsoft.com/dotnet/runtime-deps:6.0 as build\n\n# Replace value with the latest runner release version\n# source: https://github.com/actions/runner/releases\n# ex: 2.303.0\nARG RUNNER_VERSION=\"\"\nARG RUNNER_ARCH=\"x64\"\n# Replace value with the latest runner-container-hooks release version\n# source: https://github.com/actions/runner-container-hooks/releases\n# ex: 0.3.1\nARG RUNNER_CONTAINER_HOOKS_VERSION=\"\"\n\nENV DEBIAN_FRONTEND=noninteractive\nENV RUNNER_MANUALLY_TRAP_SIG=1\nENV ACTIONS_RUNNER_PRINT_LOG_TO_STDOUT=1\n\nRUN apt update -y && apt install curl unzip -y\n\nRUN adduser --disabled-password --gecos \"\" --uid 1001 runner \\\n    && groupadd docker --gid 123 \\\n    && usermod -aG sudo runner \\\n    && usermod -aG docker runner \\\n    && echo \"%sudo ALL=(ALL:ALL) NOPASSWD:ALL\" > /etc/sudoers \\\n    && echo \"Defaults env_keep += \\\"DEBIAN_FRONTEND\\\"\" >> /etc/sudoers\n\nWORKDIR /home/runner\n\nRUN curl -f -L -o runner.tar.gz https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-${RUNNER_ARCH}-${RUNNER_VERSION}.tar.gz \\\n    && tar xzf ./runner.tar.gz \\\n    && rm runner.tar.gz\n\nRUN curl -f -L -o runner-container-hooks.zip https://github.com/actions/runner-container-hooks/releases/download/v${RUNNER_CONTAINER_HOOKS_VERSION}/actions-runner-hooks-k8s-${RUNNER_CONTAINER_HOOKS_VERSION}.zip \\\n    && unzip ./runner-container-hooks.zip -d ./k8s \\\n    && rm runner-container-hooks.zip\n\nUSER runner\n\n```\n\n## Executing workflows\nAfter installation and configuration are complete, you can use ARC to execute workflow runs. A workflow can be created in the same repository that can target a self hosted runner created by ARC. For more information about targeting workflows to run on self-hosted runners, see [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow).\n\n## Using ARC runners in a workflow\nYou cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of the `runnerScaleSetName` field in your [`values.yaml`](https://github.com/actions/actions-runner-controller/blob/master/charts/gha-runner-scale-set/values.yaml) file. These are used as the 'single label' to use as your `runs-on` target. For more information, see [Using Actions Runner Controller runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow).\n\n## Scaling runners\nYou can scale runners statically or dynamically depending on your needs. For more information, see [Deploying runner scale sets with Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller#scaling-runners).\n\n## Software installed in the ARC runner image\nThe ARC [runner image](https://github.com/actions/runner/pkgs/container/actions-runner) is bundled with the following software:\n\n- [Runner binaries](https://github.com/actions/runner)\n- [Runner container hooks](https://github.com/actions/runner-container-hooks)\n- Docker (required for Docker-in-Docker mode)\n\nFor more information, see [ARC's runner image Dockerfile](https://github.com/actions/runner/blob/main/images/Dockerfile) in the Actions repository.\n\n## Assets and releases\nARC is released as two Helm charts and one container image. The Helm charts are only published as Open Container Initiative (OCI) packages. ARC does not provide tarballs or Helm repositories via GitHub Pages.\n\nYou can find the latest releases of ARC's Helm charts and container image on GitHub Packages:\n\n- [`gha-runner-scale-set-controller` Helm chart](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set-controller)\n- [`gha-runner-scale-set` Helm chart](https://github.com/actions/actions-runner-controller/pkgs/container/actions-runner-controller-charts%2Fgha-runner-scale-set)\n- [`gha-runner-scale-set-controller` container image](https://github.com/actions/actions-runner-controller/pkgs/container/gha-runner-scale-set-controller)\n\nThe supported runner image is released as a separate container image, which you can find at [`actions-runner`](https://github.com/actions/runner/pkgs/container/actions-runner) on GitHub Packages.\n\n## Legal notice\nPortions have been adapted from [https://github.com/actions/actions-runner-controller/](https://github.com/actions/actions-runner-controller/) under the Apache-2.0 license:\n\n```hljs text\nCopyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for About Actions Runner Controller?\n\nAssistant: Here are some code examples:\n\n### Creating your own runner image\n```yaml\n```hljs dockerfile\nFROM mcr.microsoft.com/dotnet/runtime-deps:6.0 as build\n\n# Replace value with the latest runner release version\n# source: https://github.com/actions/runner/releases\n# ex: 2.303.0\nARG RUNNER_VERSION=\"\"\nARG RUNNER_ARCH=\"x64\"\n# Replace value with the latest runner-container-hooks release version\n# source: https://github.com/actions/runner-container-hooks/releases\n# ex: 0.3.1\nARG RUNNER_CONTAINER_HOOKS_VERSION=\"\"\n\nENV DEBIAN_FRONTEND=noninteractive\nENV RUNNER_MANUALLY_TRAP_SIG=1\nENV ACTIONS_RUNNER_PRINT_LOG_TO_STDOUT=1\n\nRUN apt update -y && apt install curl unzip -y\n\nRUN adduser --disabled-password --gecos \"\" --uid 1001 runner \\\n    && groupadd docker --gid 123 \\\n    && usermod -aG sudo runner \\\n    && usermod -aG docker runner \\\n    && echo \"%sudo ALL=(ALL:ALL) NOPASSWD:ALL\" > /etc/sudoers \\\n    && echo \"Defaults env_keep += \\\"DEBIAN_FRONTEND\\\"\" >> /etc/sudoers\n\nWORKDIR /home/runner\n\nRUN curl -f -L -o runner.tar.gz https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-${RUNNER_ARCH}-${RUNNER_VERSION}.tar.gz \\\n    && tar xzf ./runner.tar.gz \\\n    && rm runner.tar.gz\n\nRUN curl -f -L -o runner-container-hooks.zip https://github.com/actions/runner-container-hooks/releases/download/v${RUNNER_CONTAINER_HOOKS_VERSION}/actions-runner-hooks-k8s-${RUNNER_CONTAINER_HOOKS_VERSION}.zip \\\n    && unzip ./runner-container-hooks.zip -d ./k8s \\\n    && rm runner-container-hooks.zip\n\nUSER runner\n\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About Actions Runner Controller?\n\nAssistant: Here are the recommended best practices:\n\n• You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of the `runnerScaleSetName` field in your `values.yaml` file.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Accessing contextual information about workflow runs?\n\nAssistant: You can access context information in workflows and actions.\n\nHere's a detailed explanation:\n\n\n## About contexts\nContexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects.\n\nContexts, objects, and properties will vary significantly under different workflow run conditions. For example, the `matrix` context is only populated for jobs in a matrix.\n\nYou can access contexts using the expression syntax. For more information, see Evaluate expressions in workflows and actions.\n\n`${{ <context> }}`\n\nWarning\n\nWhen creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.\n\n## Determining when to use contexts\nGitHub Actions includes a collection of variables called _contexts_ and a similar collection of variables called _default variables_. These variables are intended for use at different points in the workflow:\n\n- **Default environment variables:** These environment variables exist only on the runner that is executing your job. For more information, see Store information in variables.\n- **Contexts:** You can use most contexts at any point in your workflow, including when _default variables_ would be unavailable. For example, you can use contexts with expressions to perform initial processing before the job is routed to a runner for execution; this allows you to use a context with the conditional `if` keyword to determine whether a step should run. Once the job is running, you can also retrieve context variables from the runner that is executing the job, such as `runner.os`. For details of where you can use various contexts within a workflow, see Context availability.\n\n## Context availability\nDifferent contexts are available throughout a workflow run. For example, the `secrets` context may only be used at certain places within a job.\n\nIn addition, some functions may only be used in certain places. For example, the `hashFiles` function is not available everywhere.\n\n## Example: printing context information to the log\nYou can print the contents of contexts to the log for debugging. The `toJSON` function is required to pretty-print JSON objects to the log.\n\nWarning\n\nWhen using the whole `github` context, be mindful that it includes sensitive information such as `github.token`. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.\n\n## github context\nThe `github` context contains information about the workflow run and the event that triggered the run. You can also read most of the `github` context data in environment variables. For more information about environment variables, see Store information in variables.\n\n## env context\nThe `env` context contains variables that have been set in a workflow, job, or step. It does not contain variables inherited by the runner process. For more information about setting variables in your workflow, see Workflow syntax for GitHub Actions.\n\n## vars context\nNote\n\nConfiguration variables for GitHub Actions are in public preview and subject to change.\n\nThe `vars` context contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows, see Store information in variables.\n\n## job context\nThe `job` context contains information about the currently running job.\n\n## jobs context\nThe `jobs` context is only available in reusable workflows, and can only be used to set outputs for a reusable workflow.\n\n## steps context\nThe `steps` context contains information about the steps in the current job that have an `id` specified and have already run.\n\n## runner context\nThe `runner` context contains information about the runner that is executing the current job.\n\n## secrets context\nThe `secrets` context contains the names and values of secrets that are available to a workflow run. The `secrets` context is not available for composite actions due to security reasons.\n\n## strategy context\nFor workflows with a matrix, the `strategy` context contains information about the matrix execution strategy for the current job.\n\n## matrix context\nFor workflows with a matrix, the `matrix` context contains the matrix properties defined in the workflow file that apply to the current job.\n\n## needs context\nThe `needs` context contains outputs from all jobs that are defined as a direct dependency of the current job.\n\n## inputs context\nThe `inputs` context contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Accessing contextual information about workflow runs?\n\nAssistant: Here are some code examples:\n\n### Example of using contexts in a job\n```yaml\nname: CI\non: push\njobs:\n  prod-check:\n    if: ${{ github.ref == 'refs/heads/main' }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploying to production server on branch $GITHUB_REF\"\n```\n\n### Example: printing context information to the log\n```yaml\nname: Context testing\non: push\n\njobs:\n  dump_contexts_to_log:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Dump GitHub context\n        env:\n          GITHUB_CONTEXT: ${{ toJson(github) }}\n        run: echo \"$GITHUB_CONTEXT\"\n      - name: Dump job context\n        env:\n          JOB_CONTEXT: ${{ toJson(job) }}\n        run: echo \"$JOB_CONTEXT\"\n      - name: Dump steps context\n        env:\n          STEPS_CONTEXT: ${{ toJson(steps) }}\n        run: echo \"$STEPS_CONTEXT\"\n      - name: Dump runner context\n        env:\n          RUNNER_CONTEXT: ${{ toJson(runner) }}\n        run: echo \"$RUNNER_CONTEXT\"\n      - name: Dump strategy context\n        env:\n          STRATEGY_CONTEXT: ${{ toJson(strategy) }}\n        run: echo \"$STRATEGY_CONTEXT\"\n      - name: Dump matrix context\n        env:\n          MATRIX_CONTEXT: ${{ toJson(matrix) }}\n        run: echo \"$MATRIX_CONTEXT\"\n```\n\n### Example usage of the github context\n```yaml\nname: Run CI\non: [push, pull_request]\n\njobs:\n  normal_ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run normal CI\n        run: echo \"Running normal CI\"\n\n  pull_request_ci:\n    runs-on: ubuntu-latest\n    if: ${{ github.event_name == 'pull_request' }}\n    steps:\n      - name: Run PR CI\n        run: echo \"Running PR only CI\"\n```\n\n### Example usage of the env context\n```yaml\nname: Hi Mascot\non: push\nenv:\n  mascot: Mona\n  super_duper_var: totally_awesome\n\njobs:\n  windows_job:\n    runs-on: windows-latest\n    steps:\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat\n        env:\n          mascot: Octocat\n  linux_job:\n    runs-on: ubuntu-latest\n    env:\n      mascot: Tux\n    steps:\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Accessing contextual information about workflow runs?\n\nAssistant: Here are the recommended best practices:\n\n• When creating workflows and actions, consider whether your code might execute untrusted input from possible attackers.\n• Be cautious when exporting or printing the context, especially sensitive information like `github.token`.\n• Use the `toJSON` function to pretty-print JSON objects to the log for debugging.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing larger runners?\n\nAssistant: You can configure larger runners for your organization or enterprise.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\nEnterprise or organization owners can manage larger runners.\n\n## In this article\nNote\n\n- The information and instructions in this article only apply to larger runners with Linux and Windows operating systems.\n\n## Adding a larger runner to an organization\nOrganization owners can add a larger runner to an organization control which repositories can use it. When you create a new runner for an organization, by default, all repositories in the organization have access to the runner. To limit which repositories can use the runner, assign it to a runner group with access to specific repositories. For more information, see Allowing repositories to access larger runners.\n\nYou can choose an operating system and a hardware configuration from the list of available options. When new instances of this runner are deployed through autoscaling, they'll use the same operating system and hardware configuration you've defined here.\n\nNew runners are automatically assigned to the default group, or you can choose which group the runners must join during the runner creation process. In addition, you can modify the runner's group membership after you've registered the runner. For more information, see Controlling access to larger runners.\n\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. Click **New runner**, then click **New GitHub-hosted runner**.\n5. Complete the required details to configure your new runner:\n   - **Name:** Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such as `ubuntu-20.04-16core`.\n   - **Platform:** Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.\n   - **Image:** Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.\n     - **GitHub-owned:** For images managed by GitHub, select an image under this tab.\n     - **Partner:** For images managed by a partner, select an image under this tab. Windows 11 desktop and GPU-optimized images are located under this tab.\n   - **Size:** Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under the **GPU-powered** tab.\n   - **Maximum concurrency:** Choose the maximum number of jobs that can be active at any time.\n   - **Runner group:** Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.\n\nNote\n\nThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named `code-scanning`. For more information on code scanning with larger runners, see Configuring larger runners for default setup.\n6. Click **Create runner**.\n7. To allow repositories to access your larger runners, add them to the list of repositories that can use it. For more information, see Allowing repositories to access larger runners.\n\n## Allowing repositories to access larger runners\nRepositories are granted access to larger runners through runner groups. Enterprise administrators can choose which organizations are granted access to enterprise-level runner groups, and organization owners control repository-level access to all larger runners.\n\nOrganization owners can use and configure enterprise-level runner groups for the repositories in their organization, or they can create organization-level runner groups to control access.\n\n- **For enterprise-level runner groups:** By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.\n- **For organization-level runner groups:** By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access.\n\nOnce a repository has access to larger runners, the larger runners can be added to workflow files. For more information, see Running jobs on larger runners.\n1. Navigate to the main page of the organization where your runner groups are located.\n2. Click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runner groups**.\n4. Select a runner group from either list on the page. Organization-level runner groups are listed at the top of the page, and enterprise-level runner groups are listed under \"Shared by the Enterprise.\"\n5. On the runner group page, under \"Repository access,\" select **All repositories** or **Selected repositories**. If you choose to grant access to specific repositories, click , then select the repositories you would like to grant access to from the list.\n\nWarning\n\nIf you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\nFor more information, see Controlling access to larger runners.\n\n## Changing the name of a larger runner\nNote\n\nThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named `code-scanning`. For more information on code scanning with larger runners, see Configuring larger runners for default setup.\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. In the list of runners, select the runner you would like to edit.\n5. Enter a new name for the runner in the text field under \"Name.\"\n6. Click **Save**.\n\n## Changing the size of a larger runner\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. In the list of runners, select the runner you would like to edit.\n5. Select a new size for the runner from the list of available options under \"Size.\" The available sizes depend on the image that is installed on the runner.\n6. Click **Save**.\n\n## Changing the image of a larger runner\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. In the list of runners, select the runner you would like to edit.\n5. Select a new image for the runner from the list of available options under \"Image.\" The available images are limited to GitHub-owned images.\n6. Click **Save**.\n\n## Configuring autoscaling for larger runners\nYou can control the maximum number of jobs allowed to run concurrently for specific runner sets. Setting this field to a higher value can help prevent workflows being blocked due to parallelism.\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. In the list of runners, select the runner you would like to edit.\n5. In the \"Auto-scaling\" section, under \"Maximum Job Concurrency,\" enter the maximum number of jobs you would like to allow to run at the same time.\n6. Click **Save**.\n\n## Creating static IP addresses for larger runners\nNote\n\nTo use static IP addresses, your organization must use GitHub Enterprise Cloud. For more information about how you can try GitHub Enterprise Cloud for free, see Setting up a trial of GitHub Enterprise Cloud.\n\nYou can enable static IP addresses for larger runners. When you do this, the larger runners are assigned static IP address ranges. All IP addresses in the range assigned are usable and not in CIDR notation. By default, you can configure up to 10 different larger runners with IP ranges for your account. If you would like to use more than 10 larger runners with static IP address ranges, please contact us through the GitHub Support portal.\n\nThe number of available IP addresses in the assigned ranges does not restrict number of concurrent jobs specified for autoscaling. Within a runner pool, there is a load balancer which allows for high reuse of the IP addresses in the assigned ranges. This ensures your workflows can run concurrently at scale while each machine is assigned a static IP address.\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Actions**, then click **Runners**.\n4. In the list of runners, select the runner you would like to edit.\n5. To assign static IP addresses to the runner, under \"Networking,\" check **Assign unique & static public IP address ranges for this runner**.\n6. Click **Save**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Managing larger runners?\n\nAssistant: Here are the recommended best practices:\n\n• The names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be named `code-scanning`.\n• If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using GitHub Actions for project management?\n\nAssistant: You can use GitHub Actions to automate many of your project management tasks.\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can use GitHub Actions to automate your project management tasks by creating workflows. Each workflow contains a series of tasks that are performed automatically every time the workflow runs. For example, you can create a workflow that runs every time an issue is created to add a label and leave a comment.\n\n## When do workflows run?\nYou can configure your workflows to run on a schedule or be triggered when an event occurs. For example, you can set your workflow to run when someone creates an issue in a repository.\n\nMany workflow triggers are useful for automating project management.\n\n- An issue is opened, assigned, or labeled.\n- A comment is added to an issue.\n- A scheduled time.\n\nFor a full list of events that can trigger workflows, see Events that trigger workflows.\n\n## What can workflows do?\nWorkflows can do many things, such as commenting on an issue, adding or removing labels, and opening issues.\n\nYou can learn about using GitHub Actions for project management by following these tutorials, which include example workflows that you can adapt to meet your needs.\n\n- Adding labels to issues\n- Commenting on an issue when a label is added\n- Closing inactive issues\n- Scheduling issue creation\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing self-hosted runners?\n\nAssistant: You can host your own runners to run workflows in a highly customizable environment.\n\nHere's a detailed explanation:\n\n\n## About self-hosted runners\nYou can host your own runners and customize the environment used to run jobs in your GitHub Actions workflows.\n\n## Adding self-hosted runners\nYou can add a self-hosted runner to a repository, an organization, or an enterprise.\n\n## Autoscaling with self-hosted runners\nYou can automatically scale your self-hosted runners in response to webhook events.\n\n## Running scripts before or after a job\nScripts can automatically execute on a self-hosted runner, directly before or after a job.\n\n## Customizing the containers used by jobs\nYou can customize how your self-hosted runner invokes a container for a job.\n\n## Configuring the self-hosted runner application as a service\nYou can configure the self-hosted runner application as a service to automatically start the runner application when the machine starts.\n\n## Using a proxy server with self-hosted runners\nYou can configure self-hosted runners to use a proxy server to communicate with GitHub.\n\n## Using labels with self-hosted runners\nYou can use labels to organize your self-hosted runners based on their characteristics.\n\n## Using self-hosted runners in a workflow\nTo use self-hosted runners in a workflow, you can use labels or groups to specify the runner for a job.\n\n## Managing access to self-hosted runners using groups\nYou can use policies to limit access to self-hosted runners that have been added to an organization.\n\n## Monitoring and troubleshooting self-hosted runners\nYou can monitor your self-hosted runners to view their activity and diagnose common issues.\n\n## Removing self-hosted runners\nYou can permanently remove a self-hosted runner from a repository or organization.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using Actions Runner Controller runners in a workflow?\n\nAssistant: You can use Actions Runner Controller runners in a workflow file.\n\nHere's a detailed explanation:\n\n\n## About using ARC runners in a workflow file\nTo assign jobs to run on a runner scale set, you can specify the name of the scale set as the value for the `runs-on` key in your GitHub Actions workflow file.\n\nFor example, the following configuration for a runner scale set has the `INSTALLATION_NAME` value set to `arc-runner-set`.\n\n```hljs bash\n# Using a Personal Access Token (PAT)\nINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n```\n\nTo use this configuration in a workflow, set the value of the `runs-on` key in your workflow to `arc-runner-set`, similar to the following example.\n\n```hljs yaml\njobs:\n  job_name:\n    runs-on: arc-runner-set\n``\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using Actions Runner Controller runners in a workflow?\n\nAssistant: Here are some code examples:\n\n### Using a Personal Access Token (PAT)\n```yaml\n# Using a Personal Access Token (PAT)\nINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set\n\n```\n\n### Workflow Example\n```yaml\njobs:\n  job_name:\n    runs-on: arc-runner-set\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using Actions Runner Controller runners in a workflow?\n\nAssistant: Here are the recommended best practices:\n\n• Runner scale set names are unique within the runner group they belong to.\n• To deploy multiple runner scale sets with the same name, they must belong to different runner groups.\n• You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in HashiCorp Vault?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with HashiCorp Vault.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with a HashiCorp Vault to retrieve secrets.\n\nThis guide gives an overview of how to configure HashiCorp Vault to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in the hashicorp/vault-action action to retrieve secrets from HashiCorp Vault.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see About security hardening with OpenID Connect.\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see About security hardening with OpenID Connect.\n\n## Adding the identity provider to HashiCorp Vault\nTo use OIDC with HashiCorp Vault, you will need to add a trust configuration for the GitHub OIDC provider. For more information, see the HashiCorp Vault documentation.\n\nTo configure your Vault server to accept JSON Web Tokens (JWT) for authentication:\n\n1. Enable the JWT `auth` method, and use `write` to apply the configuration to your Vault.\nFor `oidc_discovery_url` and `bound_issuer` parameters, use `https://token.actions.githubusercontent.com`. These parameters allow the Vault server to verify the received JSON Web Tokens (JWT) during the authentication process.\n\n```hljs shell\nvault auth enable jwt\n```\n\n```hljs shell\nvault write auth/jwt/config \\\n     bound_issuer=\"https://token.actions.githubusercontent.com\" \\\n     oidc_discovery_url=\"https://token.actions.githubusercontent.com\"\n```\n\n2. Configure a policy that only grants access to the specific paths your workflows will use to retrieve secrets. For more advanced policies, see the HashiCorp Vault Policies documentation.\n\n```hljs shell\nvault policy write myproject-production - <<EOF\n# Read-only permission on 'secret/data/production/*' path\n\npath \"secret/data/production/*\" {\n     capabilities = [ \"read\" ]\n}\nEOF\n```\n\n3. Configure roles to group different policies together. If the authentication is successful, these policies are attached to the resulting Vault access token.\n\n```hljs shell\nvault write auth/jwt/role/myproject-production -<<EOF\n{\n     \"role_type\": \"jwt\",\n     \"user_claim\": \"actor\",\n     \"bound_claims\": {\n       \"repository\": \"user-or-org-name/repo-name\"\n     },\n     \"policies\": [\"myproject-production\"],\n     \"ttl\": \"10m\"\n}\nEOF\n```\n\n- `ttl` defines the validity of the resulting access token.\n- Ensure that the `bound_claims` parameter is defined for your security requirements, and has at least one condition. Optionally, you can also set the `bound_subject` as well as the `bound_audiences` parameter.\n- To check arbitrary claims in the received JWT payload, the `bound_claims` parameter contains a set of claims and their required values. In the above example, the role will accept any incoming authentication requests from the `repo-name` repository owned by the `user-or-org-name` account.\n- To see all the available claims supported by GitHub's OIDC provider, see About security hardening with OpenID Connect.\n\n## Updating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1. Add permissions settings for the token.\n2. Use the hashicorp/vault-action action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see Managing environments for deployment.\n\nTo add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes:\n\n- Grant permission to fetch the token from the GitHub OIDC provider:\n  - The workflow needs `permissions:` settings with the `id-token` value set to `write`. This lets you fetch the OIDC token from every job in the workflow.\n- Request the JWT from the GitHub OIDC provider, and present it to HashiCorp Vault to receive an access token:\n  - You can use the hashicorp/vault-action action to fetch the JWT and receive the access token from Vault, or you could use the Actions toolkit to fetch the tokens for your job.\n\nThis example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault.\n\n## Adding permissions settings\nThe job or workflow run requires a `permissions` setting with `id-token: write` to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see About security hardening with OpenID Connect.\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n- Using environment variables on the runner ( `ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n- Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see Reusing workflows.\n\nNote\n\nWhen the `permissions` key is used, all unspecified permissions are set to _no access_, with the exception of the metadata scope, which always gets _read_ access. As a result, you may need to add other permissions, such as `contents: read`. See Automatic token authentication for more information.\n\n## Requesting the access token\nThe hashicorp/vault-action action receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Action documentation.\n\nThis example demonstrates how to create a job that requests a secret from HashiCorp Vault.\n\n- `VAULT-URL`: Replace this with the URL of your HashiCorp Vault.\n- `VAULT-NAMESPACE`: Replace this with the Namespace you've set in HashiCorp Vault. For example: `admin`.\n- `ROLE-NAME`: Replace this with the role you've set in the HashiCorp Vault trust relationship.\n- `SECRET-PATH`: Replace this with the path to the secret you're retrieving from HashiCorp Vault. For example: `secret/data/production/ci npmToken`.\n\n```hljs yaml\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          method: jwt\n          url: VAULT-URL\n          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n```\n\nNote\n\n- If your Vault server is not accessible from the public network, consider using a self-hosted runner with other available Vault auth methods. For more information, see About self-hosted runners.\n- `VAULT-NAMESPACE` must be set for a Vault Enterprise (including HCP Vault) deployment. For more information, see Vault namespace.\n\n## Revoking the access token\nBy default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using the Vault API.\n\n1. Set the `exportToken` option to `true` (default: `false`). This exports the issued Vault access token as an environment variable: `VAULT_TOKEN`.\n2. Add a step to call the Revoke a Token (Self) Vault API to revoke the access token.\n\n```hljs yaml\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          exportToken: true\n          method: jwt\n          url: VAULT-URL\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n\n      - name: Revoke token\n        # This step always runs at the end regardless of the previous steps result\n        if: always()\n        run: |\n          curl -X POST -sv -H \"X-Vault-Token: ${{ env.VAULT_TOKEN }}\" \\\n            VAULT-URL/v1/auth/token/revoke-self\n```\n\n## Further reading\n- Using OpenID Connect with reusable workflows\n\n- About self-hosted runners\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in HashiCorp Vault?\n\nAssistant: Here are some code examples:\n\n### Enable JWT auth method\n```yaml\nvault auth enable jwt\n```\n\n### Write JWT config\n```yaml\nvault write auth/jwt/config \\\n     bound_issuer=\"https://token.actions.githubusercontent.com\" \\\n     oidc_discovery_url=\"https://token.actions.githubusercontent.com\"\n```\n\n### Write policy for production\n```yaml\nvault policy write myproject-production - <<EOF\n# Read-only permission on 'secret/data/production/*' path\n\npath \"secret/data/production/*\" {\n     capabilities = [ \"read\" ]\n}\nEOF\n```\n\n### Write role for production\n```yaml\nvault write auth/jwt/role/myproject-production -<<EOF\n{\n     \"role_type\": \"jwt\",\n     \"user_claim\": \"actor\",\n     \"bound_claims\": {\n       \"repository\": \"user-or-org-name/repo-name\"\n     },\n     \"policies\": [\"myproject-production\"],\n     \"ttl\": \"10m\"\n}\nEOF\n```\n\n### Workflow permissions settings\n```yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\n### Job to retrieve secret from Vault\n```yaml\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          method: jwt\n          url: VAULT-URL\n          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n```\n\n### Job to revoke token\n```yaml\njobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          exportToken: true\n          method: jwt\n          url: VAULT-URL\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n\n      - name: Revoke token\n        # This step always runs at the end regardless of the previous steps result\n        if: always()\n        run: |\n          curl -X POST -sv -H \"X-Vault-Token: ${{ env.VAULT_TOKEN }}\" \\\n            VAULT-URL/v1/auth/token/revoke-self\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in HashiCorp Vault?\n\nAssistant: Here are the recommended best practices:\n\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security.\n• If your Vault server is not accessible from the public network, consider using a self-hosted runner with other available Vault auth methods.\n• When the permissions key is used, all unspecified permissions are set to no access, with the exception of the metadata scope, which always gets read access.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Evaluate expressions in workflows and actions?\n\nAssistant: You can evaluate expressions in workflows and actions.\n\nHere's a detailed explanation:\n\n\n## About expressions\nYou can use expressions to programmatically set environment variables in workflow files and access contexts. An expression can be any combination of literal values, references to a context, or functions. You can combine literals, context references, and functions using operators. For more information about contexts, see Accessing contextual information about workflow runs.\n\nExpressions are commonly used with the conditional `if` keyword in a workflow file to determine whether a step should run. When an `if` conditional is `true`, the step will run.\n\nYou need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string.\n\n`${{ <expression> }}`\n\nNote\n\nThe exception to this rule is when you are using expressions in an `if` clause, where, optionally, you can usually omit `${{` and `}}`. For more information about `if` conditionals, see Workflow syntax for GitHub Actions.\n\nWarning\n\nWhen creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.\n\n## Example setting an environment variable\n```hljs yaml\nenv:\n  MY_ENV_VAR: ${{ <expression> }}\n```\n\n## Literals\nAs part of an expression, you can use `boolean`, `null`, `number`, or `string` data types.\n\n| Data type | Literal value |\n| --- | --- |\n| `boolean` | `true` or `false` |\n| `null` | `null` |\n| `number` | Any number format supported by JSON. |\n| `string` | You don't need to enclose strings in `${{` and `}}`. However, if you do, you must use single quotes ( `'`) around the string. To use a literal single quote, escape the literal single quote using an additional single quote ( `''`). Wrapping with double quotes ( `\"`) will throw an error. |\n\nNote that in conditionals, falsy values ( `false`, `0`, `-0`, `\"\", ''`, `null`) are coerced to `false` and truthy ( `true` and other non-falsy values) are coerced to `true`.\n\n## Example of literals\n```hljs yaml\nenv:\n  myNull: ${{ null }}\n  myBoolean: ${{ false }}\n  myIntegerNumber: ${{ 711 }}\n  myFloatNumber: ${{ -9.2 }}\n  myHexNumber: ${{ 0xff }}\n  myExponentialNumber: ${{ -2.99e-2 }}\n  myString: Mona the Octocat\n  myStringInBraces: ${{ 'It''s open source!' }}\n```\n\n## Operators\n| Operator | Description |\n| --- | --- |\n| `( )` | Logical grouping |\n| `[ ]` | Index |\n| `.` | Property de-reference |\n| `!` | Not |\n| `<` | Less than |\n| `<=` | Less than or equal |\n| `>` | Greater than |\n| `>=` | Greater than or equal |\n| `==` | Equal |\n| `!=` | Not equal |\n| `&&` | And |\n| `||` | Or |\n\nNote\n\n- GitHub ignores case when comparing strings.\n- `steps.<step_id>.outputs.<output_name>` evaluates as a string. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. For more information, see Accessing contextual information about workflow runs.\n- For numerical comparison, the `fromJSON()` function can be used to convert a string to a number. For more information on the `fromJSON()` function, see fromJSON.\n\nGitHub performs loose equality comparisons.\n\n- If the types do not match, GitHub coerces the type to a number. GitHub casts data types to a number using these conversions:\n\n| Type | Result |\n| --- | --- |\n| Null | `0` |\n| Boolean | `true` returns `1`<br>`false` returns `0` |\n| String | Parsed from any legal JSON number format, otherwise `NaN`. <br> Note: empty string returns `0`. |\n| Array | `NaN` |\n| Object | `NaN` |\n\n- When `NaN` is one of the operands of any relational comparison ( `>`, `<`, `>=`, `<=`), the result is always `false`. For more information, see the NaN Mozilla docs.\n\n- GitHub ignores case when comparing strings.\n\n- Objects and arrays are only considered equal when they are the same instance.\n\nGitHub offers ternary operator like behaviour that you can use in expressions. By using a ternary operator in this way, you can dynamically set the value of an environment variable based on a condition, without having to write separate if-else blocks for each possible option.\n\n## Example\n```hljs yaml\nenv:\n  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}\n```\n\nIn this example, we're using a ternary operator to set the value of the `MY_ENV_VAR` environment variable based on whether the GitHub reference is set to `refs/heads/main` or not. If it is, the variable is set to `value_for_main_branch`. Otherwise, it is set to `value_for_other_branches`. It is important to note that the first value after the `&&` must be truthy. Otherwise, the value after the `||` will always be returned.\n\n## Functions\nGitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions:\n\n| Type | Result |\n| --- | --- |\n| Null | `''` |\n| Boolean | `'true'` or `'false'` |\n| Number | Decimal format, exponential for large numbers |\n| Array | Arrays are not converted to a string |\n| Object | Objects are not converted to a string |\n\n## contains\n`contains( search, item )`\n\nReturns `true` if `search` contains `item`. If `search` is an array, this function returns `true` if the `item` is an element in the array. If `search` is a string, this function returns `true` if the `item` is a substring of `search`. This function is not case sensitive. Casts values to a string.\n\n## Example using a string\n`contains('Hello world', 'llo')` returns `true`.\n\n## Example using an object filter\n`contains(github.event.issue.labels.*.name, 'bug')` returns `true` if the issue related to the event has a label \"bug\".\n\n## Example matching an array of strings\nInstead of writing `github.event_name == \"push\" || github.event_name == \"pull_request\"`, you can use `contains()` with `fromJSON()` to check if an array of strings contains an `item`.\n\nFor example, `contains(fromJSON('[\"push\", \"pull_request\"]'), github.event_name)` returns `true` if `github.event_name` is \"push\" or \"pull_request\".\n\n## startsWith\n`startsWith( searchString, searchValue )`\n\nReturns `true` when `searchString` starts with `searchValue`. This function is not case sensitive. Casts values to a string.\n\n## Example of `startsWith`\n`startsWith('Hello world', 'He')` returns `true`.\n\n## endsWith\n`endsWith( searchString, searchValue )`\n\nReturns `true` if `searchString` ends with `searchValue`. This function is not case sensitive. Casts values to a string.\n\n## Example of `endsWith`\n`endsWith('Hello world', 'ld')` returns `true`.\n\n## format\n`format( string, replaceValue0, replaceValue1, ..., replaceValueN)`\n\nReplaces values in the `string`, with the variable `replaceValueN`. Variables in the `string` are specified using the `{N}` syntax, where `N` is an integer. You must specify at least one `replaceValue` and `string`. There is no maximum for the number of variables ( `replaceValueN`) you can use. Escape curly braces using double braces.\n\n## Example of `format`\n```hljs javascript\nformat('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat')\n```\n\nReturns 'Hello Mona the Octocat'.\n\n## Example escaping braces\n```hljs javascript\nformat('{{Hello {0} {1} {2}!}}', 'Mona', 'the', 'Octocat')\n```\n\nReturns '{Hello Mona the Octocat!}'.\n\n## join\n`join( array, optionalSeparator )`\n\nThe value for `array` can be an array or a string. All values in `array` are concatenated into a string. If you provide `optionalSeparator`, it is inserted between the concatenated values. Otherwise, the default separator `,` is used. Casts values to a string.\n\n## Example of `join`\n`join(github.event.issue.labels.*.name, ', ')` may return 'bug, help wanted'.\n\n## toJSON\n`toJSON(value)`\n\nReturns a pretty-print JSON representation of `value`. You can use this function to debug the information provided in contexts.\n\n## Example of `toJSON`\n`toJSON(job)` might return `{ \"status\": \"success\" }`.\n\n## fromJSON\n`fromJSON(value)`\n\nReturns a JSON object or JSON data type for `value`. You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects.\n\n## Example returning a JSON object\nThis workflow sets a JSON matrix in one job, and passes it to the next job using an output and `fromJSON`.\n\n```hljs yaml\nname: build\non: push\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      matrix: ${{ steps.set-matrix.outputs.matrix }}\n    steps:\n      - id: set-matrix\n        run: echo \"matrix={\\\"include\\\":[{\\\"project\\\":\\\"foo\\\",\\\"config\\\":\\\"Debug\\\"},{\\\"project\\\":\\\"bar\\\",\\\"config\\\":\\\"Release\\\"}]}\" >> $GITHUB_OUTPUT\n  job2:\n    needs: job1\n    runs-on: ubuntu-latest\n    strategy:\n      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}\n    steps:\n      - run: echo \"Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}\"\n```\n\n## Example returning a JSON data type\nThis workflow uses `fromJSON` to convert environment variables from a string to a Boolean or integer.\n\n```hljs yaml\nname: print\non: push\nenv:\n  continue: true\n  time: 3\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    steps:\n      - continue-on-error: ${{ fromJSON(env.continue) }}\n        timeout-minutes: ${{ fromJSON(env.time) }}\n        run: echo ...\n```\n\n## hashFiles\n`hashFiles(path)`\n\nReturns a single hash for the set of files that matches the `path` pattern. You can provide a single `path` pattern or multiple `path` patterns separated by commas. The `path` is relative to the `GITHUB_WORKSPACE` directory and can only include files inside of the `GITHUB_WORKSPACE`. This function calculates an individual SHA-256 hash for each matched file, and then uses those hashes to calculate a final SHA-256 hash for the set of files. If the `path` pattern does not match any files, this returns an empty string. For more information about SHA-256, see SHA-2.\n\n## Examples with a single pattern\nMatches any `package-lock.json` file in the repository.\n\n`hashFiles('**/package-lock.json')`\n\nMatches all `.js` files in the `src` directory at root level, but ignores any subdirectories of `src`.\n\n`hashFiles('/src/*.js')`\n\nMatches all `.rb` files in the `lib` directory at root level, including any subdirectories of `lib`.\n\n`hashFiles('/lib/**/*.rb')`\n\n## Examples with multiple patterns\nCreates a hash for any `package-lock.json` and `Gemfile.lock` files in the repository.\n\n`hashFiles('**/package-lock.json', '**/Gemfile.lock')`\n\nCreates a hash for all `.rb` files in the `lib` directory at root level, including any subdirectories of `lib`, but excluding `.rb` files in the `foo` subdirectory.\n\n`hashFiles('/lib/**/*.rb', '!/lib/foo/*.rb')`\n\n## Status check functions\nYou can use the following status check functions as expressions in `if` conditionals. A default status check of `success()` is applied unless you include one of these functions. For more information about `if` conditionals, see Workflow syntax for GitHub Actions and Metadata syntax for GitHub Actions.\n\n## success\nReturns `true` when all previous steps have succeeded.\n\n## Example of `success`\n```hljs yaml\nsteps:\n  ...\n  - name: The job has succeeded\n    if: ${{ success() }}\n```\n\n## always\nCauses the step to always execute, and returns `true`, even when canceled. The `always` expression is best used at the step level or on tasks that you expect to run even when a job is canceled. For example, you can use `always` to send logs even when a job is canceled.\n\nWarning\n\nAvoid using `always` for any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative: `if: ${{ !cancelled() }}`.\n\n## Example of `always`\n```hljs yaml\nif: ${{ always() }}\n```\n\n## cancelled\nReturns `true` if the workflow was canceled.\n\n## Example of `cancelled`\n```hljs yaml\nif: ${{ cancelled() }}\n```\n\n## failure\nReturns `true` when any previous step of a job fails. If you have a chain of dependent jobs, `failure()` returns `true` if any ancestor job fails.\n\n## Example of `failure`\n```hljs yaml\nsteps:\n  ...\n  - name: The job has failed\n    if: ${{ failure() }}\n```\n\n## failure with conditions\nYou can include extra conditions for a step to run after a failure, but you must still include `failure()` to override the default status check of `success()` that is automatically applied to `if` conditions that don't contain a status check function.\n\n## Example of `failure` with conditions\n```hljs yaml\nsteps:\n  ...\n  - name: Failing step\n    id: demo\n    run: exit 1\n  - name: The demo step has failed\n    if: ${{ failure() && steps.demo.conclusion == 'failure' }}\n```\n\n## Object filters\nYou can use the `*` syntax to apply a filter and select matching items in a collection.\n\nFor example, consider an array of objects named `fruits`.\n\n```hljs json\n[\n  { \"name\": \"apple\", \"quantity\": 1 },\n  { \"name\": \"orange\", \"quantity\": 2 },\n  { \"name\": \"pear\", \"quantity\": 1 }\n]\n```\n\nThe filter `fruits.*.name` returns the array `[ \"apple\", \"orange\", \"pear\" ]`.\n\nYou may also use the `*` syntax on an object. For example, suppose you have an object named `vegetables`.\n\n```hljs json\n{\n  \"scallions\":\n  {\n    \"colors\": [\"green\", \"white\", \"red\"],\n    \"ediblePortions\": [\"roots\", \"stalks\"],\n  },\n  \"beets\":\n  {\n    \"colors\": [\"purple\", \"red\", \"gold\", \"white\", \"pink\"],\n    \"ediblePortions\": [\"roots\", \"stems\", \"leaves\"],\n  },\n  \"artichokes\":\n  {\n    \"colors\": [\"green\", \"purple\", \"red\", \"black\"],\n    \"ediblePortions\": [\"hearts\", \"stems\", \"leaves\"],\n  },\n}\n```\n\nThe filter `vegetables.*.ediblePortions` could evaluate to:\n\n```hljs json\n[\n  [\"roots\", \"stalks\"],\n  [\"hearts\", \"stems\", \"leaves\"],\n  [\"roots\", \"stems\", \"leaves\"],\n]\n```\n\nSince objects don't preserve order, the order of the output cannot be guaranteed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Evaluate expressions in workflows and actions?\n\nAssistant: Here are some code examples:\n\n### Example setting an environment variable\n```yaml\n```hljs yaml\nenv:\n  MY_ENV_VAR: ${{ <expression> }}\n```\n```\n\n### Example of literals\n```yaml\n```hljs yaml\nenv:\n  myNull: ${{ null }}\n  myBoolean: ${{ false }}\n  myIntegerNumber: ${{ 711 }}\n  myFloatNumber: ${{ -9.2 }}\n  myHexNumber: ${{ 0xff }}\n  myExponentialNumber: ${{ -2.99e-2 }}\n  myString: Mona the Octocat\n  myStringInBraces: ${{ 'It''s open source!' }}\n```\n```\n\n### Example\n```yaml\n```hljs yaml\nenv:\n  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}\n```\n```\n\n### Example using a string\n```yaml\n`contains('Hello world', 'llo')` returns `true`.\n```\n\n### Example using an object filter\n```yaml\n`contains(github.event.issue.labels.*.name, 'bug')` returns `true` if the issue related to the event has a label \"bug\".\n```\n\n### Example matching an array of strings\n```yaml\n`contains(fromJSON('[\"push\", \"pull_request\"]'), github.event_name)` returns `true` if `github.event_name` is \"push\" or \"pull_request\".\n```\n\n### Example of `startsWith`\n```yaml\n`startsWith('Hello world', 'He')` returns `true`.\n```\n\n### Example of `endsWith`\n```yaml\n`endsWith('Hello world', 'ld')` returns `true`.\n```\n\n### Example of `format`\n```yaml\n```hljs javascript\nformat('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat')\n```\n```\n\n### Example escaping braces\n```yaml\n```hljs javascript\nformat('{{Hello {0} {1} {2}!}}', 'Mona', 'the', 'Octocat')\n```\n```\n\n### Example of `join`\n```yaml\n`join(github.event.issue.labels.*.name, ', ')` may return 'bug, help wanted'.\n```\n\n### Example of `toJSON`\n```yaml\n`toJSON(job)` might return `{ \"status\": \"success\" }`.\n```\n\n### Example returning a JSON object\n```yaml\n```hljs yaml\nname: build\non: push\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      matrix: ${{ steps.set-matrix.outputs.matrix }}\n    steps:\n      - id: set-matrix\n        run: echo \"matrix={\\\"include\\\":[{\\\"project\\\":\\\"foo\\\",\\\"config\\\":\\\"Debug\\\"},{\\\"project\\\":\\\"bar\\\",\\\"config\\\":\\\"Release\\\"}]}\" >> $GITHUB_OUTPUT\n  job2:\n    needs: job1\n    runs-on: ubuntu-latest\n    strategy:\n      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}\n    steps:\n      - run: echo \"Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}\"\n```\n```\n\n### Example returning a JSON data type\n```yaml\n```hljs yaml\nname: print\non: push\nenv:\n  continue: true\n  time: 3\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    steps:\n      - continue-on-error: ${{ fromJSON(env.continue) }}\n        timeout-minutes: ${{ fromJSON(env.time) }}\n        run: echo ...\n```\n```\n\n### Example of `success`\n```yaml\n```hljs yaml\nsteps:\n  ...\n  - name: The job has succeeded\n    if: ${{ success() }}\n```\n```\n\n### Example of `always`\n```yaml\n```hljs yaml\nif: ${{ always() }}\n```\n```\n\n### Example of `cancelled`\n```yaml\n```hljs yaml\nif: ${{ cancelled() }}\n```\n```\n\n### Example of `failure`\n```yaml\n```hljs yaml\nsteps:\n  ...\n  - name: The job has failed\n    if: ${{ failure() }}\n```\n```\n\n### Example of `failure` with conditions\n```yaml\n```hljs yaml\nsteps:\n  ...\n  - name: Failing step\n    id: demo\n    run: exit 1\n  - name: The demo step has failed\n    if: ${{ failure() && steps.demo.conclusion == 'failure' }}\n```\n```\n\n### Example of `hashFiles` with a single pattern\n```yaml\n`hashFiles('**/package-lock.json')`\n```\n\n### Example of `hashFiles` with multiple patterns\n```yaml\n`hashFiles('**/package-lock.json', '**/Gemfile.lock')`\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Evaluate expressions in workflows and actions?\n\nAssistant: Here are the recommended best practices:\n\n• When creating workflows and actions, always consider whether your code might execute untrusted input from possible attackers.\n• Avoid using `always` for any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Use cases and examples?\n\nAssistant: Example workflows that demonstrate the features of GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Creating an example workflow\n[Creating an example workflow](https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow)\n\n## Building and testing\n[Building and testing](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing)\n\n  - [Building and testing Go](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go)\n  - [Building and testing Java with Ant](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant)\n  - [Building and testing Java with Gradle](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle)\n  - [Building and testing Java with Maven](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven)\n  - [Building and testing .NET](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net)\n  - [Building and testing Node.js](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs)\n  - [Building and testing PowerShell](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell)\n  - [Building and testing Python](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python)\n  - [Building and testing Ruby](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby)\n  - [Building and testing Rust](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust)\n  - [Building and testing Swift](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift)\n  - [Building and testing Xamarin applications](https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-xamarin-applications)\n\n## Deploying\n[Deploying](https://docs.github.com/en/actions/use-cases-and-examples/deploying)\n\n  - [Deploying with GitHub Actions](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions)\n  - [Deploying Node.js to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-nodejs-to-azure-app-service)\n  - [Deploying Python to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service)\n  - [Deploying Java to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-java-to-azure-app-service)\n  - [Deploying .NET to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-net-to-azure-app-service)\n  - [Deploying PHP to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-php-to-azure-app-service)\n  - [Deploying Docker to Azure App Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service)\n  - [Deploying to Azure Static Web App](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app)\n  - [Deploying to Azure Kubernetes Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service)\n  - [Deploying to Amazon Elastic Container Service](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-amazon-elastic-container-service)\n  - [Deploying to Google Kubernetes Engine](https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-google-kubernetes-engine)\n  - [Installing an Apple certificate on macOS runners for Xcode development](https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development)\n\n## Publishing packages\n[Publishing packages](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages)\n\n  - [About packaging with GitHub Actions](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/about-packaging-with-github-actions)\n  - [Publishing Docker images](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images)\n  - [Publishing Java packages with Gradle](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-gradle)\n  - [Publishing Java packages with Maven](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-maven)\n  - [Publishing Node.js packages](https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-nodejs-packages)\n\n## Managing projects\n[Managing projects](https://docs.github.com/en/actions/use-cases-and-examples/project-management)\n\n  - [Using GitHub Actions for project management](https://docs.github.com/en/actions/use-cases-and-examples/project-management/using-github-actions-for-project-management)\n  - [Adding labels to issues](https://docs.github.com/en/actions/use-cases-and-examples/project-management/adding-labels-to-issues)\n  - [Closing inactive issues](https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues)\n  - [Commenting on an issue when a label is added](https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added)\n  - [Scheduling issue creation](https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation)\n\n## Using containerized services\n[Using containerized services](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services)\n\n  - [About service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers)\n  - [Creating PostgreSQL service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers)\n  - [Creating Redis service containers](https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring the self-hosted runner application as a service?\n\nAssistant: You can configure the self-hosted runner application as a service to automatically start the runner application when the machine starts.\n\nHere's a detailed explanation:\n\n\n## Platform navigation\n\n\n## In this article\nNote\n\nYou must add a runner to GitHub before you can configure the self-hosted runner application as a service.\nFor more information, see [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n\nFor Linux systems that use `systemd`, you can use the `svc.sh` script that is created after successfully adding the runner to install and manage using the application as a service.\n\nOn the runner machine, open a shell in the directory where you installed the self-hosted runner application. Use the commands below to install and manage the self-hosted runner service.\n\nNote\n\nConfiguring the self-hosted runner application as a service on Windows is part of the application configuration process. If you have already configured the self-hosted runner application but did not choose to configure it as a service, you must remove the runner from GitHub and re-configure the application. When you re-configure the application, choose the option to configure the application as a service.\n\nFor more information, see [Removing self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/removing-self-hosted-runners) and [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n\nYou can manage the runner service in the Windows **Services** application, or you can use PowerShell to run the commands below.\n\nNote\n\nYou must add a runner to GitHub before you can configure the self-hosted runner application as a service.\nFor more information, see [Adding self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring the self-hosted runner application as a service?\n\nAssistant: Here are some code examples:\n\n### Installing the service\n```yaml\nsudo ./svc.sh install\n```\n\n### Installing the service as a different user\n```yaml\n./svc.sh install USERNAME\n```\n\n### Starting the service\n```yaml\nsudo ./svc.sh start\n```\n\n### Starting the service on Windows\n```yaml\nStart-Service \"actions.runner.*\"\n```\n\n### Checking the status of the service\n```yaml\nsudo ./svc.sh status\n```\n\n### Checking the status of the service on Windows\n```yaml\nGet-Service \"actions.runner.*\"\n```\n\n### Stopping the service\n```yaml\nsudo ./svc.sh stop\n```\n\n### Stopping the service on Windows\n```yaml\nStop-Service \"actions.runner.*\"\n```\n\n### Uninstalling the service\n```yaml\nsudo ./svc.sh uninstall\n```\n\n### Uninstalling the service on Windows\n```yaml\nRemove-Service \"actions.runner.*\"\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring the self-hosted runner application as a service?\n\nAssistant: Here are the recommended best practices:\n\n• You must add a runner to GitHub before you can configure the self-hosted runner application as a service.\n• If you have already configured the self-hosted runner application but did not choose to configure it as a service, you must remove the runner from GitHub and re-configure the application.\n• Consider using the `serviced` template at `actions-runner/bin/actions.runner.service.template` as a reference for customized service configurations.\n• If you use a customized service, the self-hosted runner service must always be invoked using the `runsvc.sh` entry point.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Travis CI with GitHub Actions Importer?\n\nAssistant: Learn how to use GitHub Actions Importer to automate the migration of your Travis CI pipelines to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About migrating from Travis CI with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Travis CI pipelines to GitHub Actions.\n\n## Prerequisites\n- A Travis CI account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.\n- Access to create a Travis CI API access token for your account or organization.\n- An environment where you can run Linux-based containers, and can install the necessary tools.\n\n  - Docker is [installed](https://docs.docker.com/get-docker/) and running.\n  - [GitHub CLI](https://cli.github.com/) is installed.\n\nNote\n\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n\n## Limitations\nThere are some limitations when migrating from Travis CI pipelines to GitHub Actions with GitHub Actions Importer.\n\n## Manual tasks\nCertain Travis CI constructs must be migrated manually. These include:\n\n- Secrets\n- Unknown job properties\n\nFor more information on manual migrations, see [Migrating from Travis CI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions).\n\n## Travis CI project languages\nGitHub Actions Importer transforms Travis CI project languages by adding a set of preconfigured build tools and a default build script to the transformed workflow. If no language is explicitly declared, GitHub Actions Importer assumes a project language is Ruby.\n\nFor a list of the project languages supported by GitHub Actions Importer, see [Supported project languages](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer#supported-project-languages).\n\n## Installing the GitHub Actions Importer CLI extension\n1. Install the GitHub Actions Importer CLI extension:\n\n```hljs bash\ngh extension install github/gh-actions-importer\n```\n\n2. Verify that the extension is installed:\n\n```hljs bash\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Configuring credentials\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with Travis CI and GitHub.\n\n1. Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n\nYour token must have the `workflow` scope.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n2. Create a Travis CI API access token. For more information, see [Get your Travis CI API token](https://docs.travis-ci.com/user/migrate/travis-migrate-to-apps-gem-guide/#4-get-your-travis-ci-api-token) in the Travis CI documentation.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n3. In your terminal, run the GitHub Actions Importer `configure` CLI command:\n\n```hljs shell\ngh actions-importer configure\n```\n\nThe `configure` command will prompt you for the following information:\n\n   - For \"Which CI providers are you configuring?\", use the arrow keys to select `Travis CI`, press `Space` to select it, then press `Enter`.\n   - For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press `Enter`.\n   - For \"Base url of the GitHub instance\", press `Enter` to accept the default value ( `https://github.com`).\n   - For \"Personal access token for Travis CI\", enter the value for the Travis CI API access token that you created earlier, and press `Enter`.\n   - For \"Base url of the Travis CI instance\", enter the URL of your Travis CI instance, and press `Enter`.\n   - For \"Travis CI organization name\", enter the name of your Travis CI organization, and press `Enter`.\n\nAn example of the output of the `configure` command is shown below.\n\n```hljs shell\n$ gh actions-importer configure\n✔ Which CI providers are you configuring?: Travis CI\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Travis CI: ***************\n✔ Base url of the Travis CI instance: https://travis-ci.com\n✔ Travis CI organization name: actions-importer-labs\nEnvironment variables successfully updated.\n```\n\n4. In your terminal, run the GitHub Actions Importer `update` CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\n\n```hljs shell\ngh actions-importer update\n```\n\nThe output of the command should be similar to below:\n\n```hljs shell\nUpdating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date\n```\n\n## Perform an audit of Travis CI\nYou can use the `audit` command to get a high-level view of all pipelines in a Travis CI server.\n\nThe `audit` command performs the following steps:\n\n1. Fetches all of the projects defined in a Travis CI server.\n2. Converts each pipeline to its equivalent GitHub Actions workflow.\n3. Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n## Running the audit command\nTo perform an audit of a Travis CI server, run the following command in your terminal:\n\n```hljs shell\ngh actions-importer audit travis-ci --output-dir tmp/audit\n```\n\n## Inspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\nThe audit summary has the following sections.\n\n## Pipelines\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Pipelines\" section:\n\n- **Successful** pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\n- **Partially successful** pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\n- **Unsupported** pipelines are definition types that are not supported by GitHub Actions Importer.\n- **Failed** pipelines encountered a fatal error when being converted. This can occur for one of three reasons:\n\n  - The pipeline was originally misconfigured and not valid.\n  - GitHub Actions Importer encountered an internal error when converting it.\n  - There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\n\n## Build steps\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Build steps\" section:\n\n- A **known** build step is a step that was automatically converted to an equivalent action.\n- An **unknown** build step is a step that was not automatically converted to an equivalent action.\n- An **unsupported** build step is a step that is either:\n  - Fundamentally not supported by GitHub Actions.\n  - Configured in a way that is incompatible with GitHub Actions.\n- An **action** is a list of the actions that were used in the converted workflows. This can be important for:\n  - If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\n  - Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\n\n## Manual tasks\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\n\nListed below are some key terms that can appear in the \"Manual tasks\" section:\n\n- A **secret** is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n- A **self-hosted runner** refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\n\n## Files\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\n\nEach pipeline file has a variety of files included in the audit, including:\n\n- The original pipeline as it was defined in GitHub.\n- Any network responses used to convert the pipeline.\n- The converted workflow file.\n- Stack traces that can be used to troubleshoot a failed pipeline conversion.\n\nAdditionally, the `workflow_usage.csv` file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\n\n## Forecast potential build runner usage\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Travis CI server.\n\n## Running the forecast command\nTo perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```hljs shell\ngh actions-importer forecast travis-ci --output-dir tmp/forecast\n```\n\n## Inspecting the forecast report\nThe `forecast_report.md` file in the specified output directory contains the results of the forecast.\n\nListed below are some key terms that can appear in the forecast report:\n\n- The **job count** is the total number of completed jobs.\n- The **pipeline count** is the number of unique pipelines used.\n- **Execution time** describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.\n  - This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the [GitHub Actions pricing calculator](https://github.com/pricing/calculator) to estimate the costs.\n- **Queue time** metrics describe the amount of time a job spent waiting for a runner to be available to execute it.\n- **Concurrent jobs** metrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure.\n\nAdditionally, these metrics are defined for each queue of runners in Travis CI. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners.\n\n## Perform a dry-run migration of a Travis CI pipeline\nYou can use the `dry-run` command to convert a Travis CI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\n## Running the dry-run command\nTo perform a dry run of migrating your Travis CI pipelines to GitHub Actions, run the following command in your terminal, replacing `my-travis-ci-repository` with the name of your Travis CI repository.\n\n```hljs shell\ngh actions-importer dry-run travis-ci --travis-ci-repository my-travis-ci-repository --output-dir tmp/dry-run\n```\n\n## Perform a production migration of a Travis CI pipeline\nYou can use the `migrate` command to convert a Travis CI pipeline and open a pull request with the equivalent GitHub Actions workflow.\n\n## Running the migrate command\nTo migrate a Travis CI pipeline to GitHub Actions, run the following command in your terminal, replacing the `target-url` value with the URL for your GitHub repository, and `my-travis-ci-repository` with the name of your Travis CI repository.\n\n```hljs shell\ngh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository\n```\n\n## Inspecting the pull request\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\nSome important elements of the pull request include:\n\n- In the pull request description, a section called **Manual steps**, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\n- The converted workflows file. Select the **Files changed** tab in the pull request to view the workflow file that will be added to your GitHub repository.\n\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\n\n## Reference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Travis CI.\n\n## Using environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command. For more information, see the [Configuring credentials](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer#configuring-credentials) section.\n\nGitHub Actions Importer uses the following environment variables to connect to your Travis CI instance:\n\n- `GITHUB_ACCESS_TOKEN`: The personal access token (classic) used to create pull requests with a converted workflow (requires the `workflow` scope).\n- `GITHUB_INSTANCE_URL`: The URL to the target GitHub instance (for example, `https://github.com`).\n- `TRAVIS_CI_ACCESS_TOKEN`: The Travis CI API access token used to view Travis CI resources.\n- `TRAVIS_CI_ORGANIZATION`: The organization name of your Travis CI instance.\n- `TRAVIS_CI_INSTANCE_URL`: The URL of the Travis CI instance.\n- `TRAVIS_CI_SOURCE_GITHUB_ACCESS_TOKEN`: (Optional) The personal access token used to authenticate with your source GitHub instance. If not provided, `GITHUB_ACCESS_TOKEN` will be used instead.\n- `TRAVIS_CI_SOURCE_GITHUB_INSTANCE_URL`: (Optional) The URL to the source GitHub instance, such as [https://github.com](https://github.com/). If not provided, `GITHUB_INSTANCE_URL` will be used instead.\n\nThese environment variables can be specified in a `.env.local` file that is loaded by GitHub Actions Importer when it is run.\n\n## Using optional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n## --source-file-path\nYou can use the `--source-file-path` argument with the `forecast`, `dry-run`, or `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--source-file-path` argument tells GitHub Actions Importer to use the specified source file path instead.\n\nFor example:\n\n```hljs shell\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --source-file-path ./path/to/.travis.yml\n```\n\n## --allow-inactive-repositories\nYou can use this argument to specify whether GitHub Actions Importer should include inactive repositories in an audit. If this option is not set, inactive repositories are not included in audits.\n\n```hljs shell\ngh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --allow-inactive-repositories\n```\n\n## --config-file-path\nYou can use the `--config-file-path` argument with the `audit`, `dry-run`, and `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--config-file-path` argument tells GitHub Actions Importer to use the specified source files instead.\n\n## Audit example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\n\n```hljs shell\ngh actions-importer audit travis-ci --output-dir ./path/to/output/ --config-file-path ./path/to/travis-ci/config.yml\n```\n\n## Dry run example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run.\n\nThe pipeline is selected by matching the `repository_slug` in the configuration file to the value of the `--travis-ci-repository` option. The `path` is then used to pull the specified source file.\n\n```hljs shell\ngh actions-importer dry-run travis-ci --travis-ci-repository travis-org-name/travis-repo-name --output-dir ./output/ --config-file-path ./path/to/travis-ci/config.yml\n```\n\n## Supported project languages\nGitHub Actions Importer supports migrating Travis CI projects in the following languages.\n\n- `android`\n- `bash`\n- `c`\n- `clojure`\n- `c++`\n- `crystal`\n- `c#`\n- `d`\n- `dart`\n- `elixir`\n- `erlang`\n- `generic`\n- `go`\n- `groovy`\n- `haskell`\n- `haxe`\n- `java`\n- `julia`\n- `matlab`\n- `minimal`\n- `nix`\n- `node_js`\n- `objective-c`\n- `perl`\n- `perl6`\n- `php`\n- `python`\n- `r`\n- `ruby`\n- `rust`\n- `scala`\n- `sh`\n- `shell`\n- `smalltalk`\n- `swift`.\n\n## Supported syntax for Travis CI pipelines\nThe following table shows the type of properties GitHub Actions Importer is currently able to convert. For more details about how Travis CI pipeline syntax aligns with GitHub Actions, see [Migrating from Travis CI to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions).\n\n## Environment variables syntax\nGitHub Actions Importer uses the mapping in the table below to convert default Travis CI environment variables to the closest equivalent in GitHub Actions.\n\n## Legal notice\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\naUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Travis CI with GitHub Actions Importer?\n\nAssistant: Here are some code examples:\n\n### Installing the GitHub Actions Importer CLI extension\n```yaml\ngh extension install github/gh-actions-importer\n```\n\n### Verifying the extension is installed\n```yaml\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n### Configuring credentials\n```yaml\ngh actions-importer configure\n```\n\n### Running the audit command\n```yaml\ngh actions-importer audit travis-ci --output-dir tmp/audit\n```\n\n### Running the forecast command\n```yaml\ngh actions-importer forecast travis-ci --output-dir tmp/forecast\n```\n\n### Performing a dry-run migration of a Travis CI pipeline\n```yaml\ngh actions-importer dry-run travis-ci --travis-ci-repository my-travis-ci-repository --output-dir tmp/dry-run\n```\n\n### Performing a production migration of a Travis CI pipeline\n```yaml\ngh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from Travis CI with GitHub Actions Importer?\n\nAssistant: Here are the recommended best practices:\n\n• The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n• Your token must have the `workflow` scope when creating a GitHub personal access token.\n• Secrets must be created manually in GitHub Actions for these pipelines to function properly.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Working with Support for GitHub Actions?\n\nAssistant: Learn how GitHub Support can assist with GitHub Actions\n\nHere's a detailed explanation:\n\n\n## In this article\nYou can [contact GitHub Support](https://docs.github.com/en/support/contacting-github-support) for assistance with GitHub Actions.\n\n## Providing diagnostic and troubleshooting information\nThe contents of private and internal repositories are not visible to GitHub Support, so GitHub Support may request additional information to understand the complete context of your inquiry and reproduce any unexpected behavior. You can accelerate the resolution of your inquiry by providing this information when you initially raise a ticket with GitHub Support.\n\nSome information that GitHub Support will request can include, but is not limited to, the following:\n\n- The URL of the workflow run.\n\nFor example: `https://github.com/ORG/REPO/actions/runs/0123456789`\n\n- The workflow `.yml` file(s) attached to the ticket as `.txt` files. For more information about workflows, see [About workflows](https://docs.github.com/en/actions/using-workflows/about-workflows#about-workflows).\n\n- A copy of your workflow run logs for an example workflow run failure. For more information about workflow run logs, see [Using workflow run logs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-workflow-run-logs#downloading-logs).\n\n- If you are running this workflow on a self-hosted runner, self-hosted runner logs which can be found under the `_diag` folder within the runner. For more information about self-hosted runners, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners#reviewing-the-self-hosted-runner-application-log-files).\n\nSelf-hosted runner log file names are be formatted: `Runner_YYYY####-xxxxxx-utc.log` and `Worker_YYYY####-xxxxxx-utc.log`.\n\nNote\n\nAttach files to your support ticket by changing the file's extension to `.txt` or `.zip`. If you include textual data such as log or workflow file snippets inline in your ticket, ensure they are formatted correctly as Markdown code blocks. For more information about proper Markdown formatting, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code).\n\nIf the information you provide is unreadable due to the loss of formatting by improper Markdown syntax, GitHub Support may request that resubmit the information either as an attachment or with the correct Markdown formatting.\n\nWarning\n\nEnsure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets.\n\n## Ephemeral Runner Application Log Files\nGitHub Support may request the runner application log files from ephemeral runners. GitHub expects and recommends that you have implemented a mechanism to forward and preserve the runner application log files from self-hosted ephemeral runners. For more information about runner application log files and troubleshooting self-hosted runners, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners#reviewing-the-self-hosted-runner-application-log-files).\n\n## Actions Runner Controller\nIf you are using Actions Runner Controller (ARC), GitHub Support may ask you to submit the complete logs for the controller, listeners, and runner pods. For more information about collecting Actions Runner Controller's logs, see [Troubleshooting Actions Runner Controller errors](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors#checking-the-logs-of-the-controller-and-runner-set-listener).\n\nFor more information about the scope of support for Actions Runner Controller, see [About support for Actions Runner Controller](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller).\n\n## CodeQL and GitHub Actions\nIf you are requesting assistance with a CodeQL analysis workflow, GitHub Support may request a copy of the CodeQL debugging artifacts. For more information about debugging artifacts for a CodeQL analysis workflow, see [Logs are not detailed enough](https://docs.github.com/en/code-security/code-scanning/troubleshooting-code-scanning/logs-not-detailed-enough#creating-codeql-debugging-artifacts).\n\nTo provide the debugging artifacts to GitHub Support, please download the CodeQL debugging artifacts from a sample workflow run and attach it to your ticket as a `.zip` file. For more information on downloading workflow artifacts, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts).\n\nIf the CodeQL debugging artifacts `.zip` file is too large to upload to the ticket, please advise GitHub Support, and we will work with you to determine the next steps.\n\n## Scope of support\nIf your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:\n\n- Third party integrations, such as Jira\n- Enterprise Cloud Importer (available only with expert-led migrations)\n- CI/CD, such as Jenkins\n- Writing scripts\n- Configuration of external authentication systems, such as SAML identity providers\n- Open source projects\n- Writing or debugging new queries for CodeQL\n- Cloud provider configurations, such as virtual network setup, custom firewall, or proxy rules\n- Container orchestration, such as Kubernetes setup, or networking\n- Detailed assistance with workflows and data management\n- Public preview features. Support for public preview features is out of GitHub Support's scope.\n\nFor detailed assistance with workflows and data management, consult [GitHub Expert Services](https://github.com/services/), which offer specialized support to help you optimize your use of the platform.\n\nIf you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Working with Support for GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• Attach files to your support ticket by changing the file's extension to `.txt` or `.zip`.\n• Ensure they are formatted correctly as Markdown code blocks.\n• Ensure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Java with Ant?\n\nAssistant: You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Ant.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Ant build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Ant. For a list of software and the pre-installed versions for JDK and Ant, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n- [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Ant framework. For more information, see the [Apache Ant Manual](https://ant.apache.org/manual/).\n\n## Using an Ant workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Ant that should work for most Java with Ant projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. If you already have a workflow in your repository, click **New workflow**.\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Ant\".\n5. On the \"Java with Ant\" workflow, click **Configure**.\n6. Edit the workflow as required. For example, change the Java version.\n7. Click **Commit changes**.\n\nThe `ant.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying the Java version and architecture\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( `x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the default target specified in your `build.xml` file. Your default target will commonly be set to build classes, run tests and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to run a different target, you can specify those.\n\n## Packaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\nAnt will usually create output files like JARs, EARs, or WARs in the `build/jar` directory. You can upload the contents of that directory using the `upload-artifact` action.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Java with Ant?\n\nAssistant: Here are some code examples:\n\n### Set up JDK 11 for x64\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n\n```\n\n### Run the Ant jar target\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Ant jar target\n    run: ant -noinput -buildfile build-ci.xml jar\n\n```\n\n### Upload Java packages as artifacts\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - run: ant -noinput -buildfile build.xml\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/jar\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Java with Ant?\n\nAssistant: Here are the recommended best practices:\n\n• Familiarize yourself with YAML and GitHub Actions syntax before starting.\n• Understand the Ant framework basics to effectively use it in your CI workflow.\n• Use the provided workflow template for a quick start and customize it as needed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating a composite action?\n\nAssistant: In this guide, you'll learn how to build a composite action.\n\nHere's a detailed explanation:\n\n\n## Platform navigation\n\n\n## In this article\n\n\n## Introduction\nIn this guide, you'll learn about the basic components needed to create and use a packaged composite action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" and then \"Goodbye\", or if you provide a custom name, it prints \"Hello [who-to-greet]\" and then \"Goodbye\". The action also maps a random number to the `random-number` output variable, and runs a script named `goodbye.sh`. Once you complete this project, you should understand how to build your own composite action and test it in a workflow. Warning: When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.\n\n## Composite actions and reusable workflows\nComposite actions allow you to collect a series of workflow job steps into a single action which you can then run as a single job step in multiple workflows. Reusable workflows provide another way of avoiding duplication, by allowing you to run a complete workflow from within other workflows. For more information, see Avoiding duplication.\n\n## Prerequisites\nBefore you begin, you'll create a repository on GitHub. 1. Create a new public repository on GitHub. You can choose any repository name, or use the following `hello-world-composite-action` example. You can add these files after your project has been pushed to GitHub. For more information, see Creating a new repository. 2. Clone your repository to your computer. For more information, see Cloning a repository. 3. From your terminal, change directories into your new repository.\n\n## Creating an action metadata file\n1. In the `hello-world-composite-action` repository, create a new file called `action.yml` and add the following example code. For more information about this syntax, see Metadata syntax for GitHub Actions. 2. From your terminal, check in your `action.yml` file.\n\n## Testing out your action in a workflow\nThe following workflow code uses the completed hello world action that you made in Creating a composite action. Copy the workflow code into a `.github/workflows/main.yml` file in another repository, replacing `OWNER` and `SHA` with the repository owner and the SHA of the commit you want to use, respectively. You can also replace the `who-to-greet` input with your name.\n\n## Example composite actions on GitHub\nYou can find many examples of composite actions on GitHub.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating a composite action?\n\nAssistant: Here are some code examples:\n\n### Creating goodbye.sh script\n```yaml\necho \"echo Goodbye\" > goodbye.sh\n```\n\n### Making goodbye.sh executable\n```yaml\nchmod +x goodbye.sh\n```\n\n### Adding goodbye.sh to git\n```yaml\ngit add goodbye.sh\n git commit -m \"Add goodbye script\"\n git push\n```\n\n### Creating action.yml file\n```yaml\nname: 'Hello World'\ndescription: 'Greet someone'\ninputs:\n     who-to-greet:  # id of input\n       description: 'Who to greet'\n       required: true\n       default: 'World'\noutputs:\n     random-number:\n       description: \"Random number\"\n       value: ${{ steps.random-number-generator.outputs.random-number }}\nruns:\n     using: \"composite\"\n     steps:\n    - name: Set Greeting\n      run: echo \"Hello $INPUT_WHO_TO_GREET.\"\n      shell: bash\n      env:\n        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}\n\n    - name: Random Number Generator\n      id: random-number-generator\n      run: echo \"random-number=$(echo $RANDOM)\" >> $GITHUB_OUTPUT\n      shell: bash\n\n    - name: Set GitHub Path\n      run: echo \"$GITHUB_ACTION_PATH\" >> $GITHUB_PATH\n      shell: bash\n      env:\n        GITHUB_ACTION_PATH: ${{ github.action_path }}\n\n    - name: Run goodbye.sh\n      run: goodbye.sh\n      shell: bash\n```\n\n### Creating a workflow to test the action\n```yaml\non: [push]\n\njobs:\nhello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - uses: actions/checkout@v4\n      - id: foo\n        uses: OWNER/hello-world-composite-action@SHA\n        with:\n          who-to-greet: 'Mona the Octocat'\n      - run: echo random-number \"$RANDOM_NUMBER\"\n        shell: bash\n        env:\n          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating a composite action?\n\nAssistant: Here are the recommended best practices:\n\n• Always consider whether your code might execute untrusted input from possible attackers.\n• Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Verifying attestations offline?\n\nAssistant: Artifact attestations can be verified without an internet connection.\n\nHere's a detailed explanation:\n\n\n## Introduction\nArtifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build.\n\nBy default, attestations are stored in GitHub's attestation API, which `gh attestation verify` will query when you go to verify your attestation. That command will also contact GitHub's servers to check for updated key material to use to verify the attestation.\n\nThis command can work without internet connectivity, but you need to supply the attestation bundle and the key material in the trusted root manually.\n\nBefore starting this guide, you should be building with generating artifact attestations. See [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n\n## Step 1: Download attestation bundle\nFirst, get the attestation bundle from the attestation API.\n\nYou can do so with the following command from a machine that is online:\n\n```hljs bash\ngh attestation download PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\nHere is example output from that command:\n\n```hljs bash\nWrote attestations to file sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl.\nAny previous content has been overwritten\n\nThe trusted metadata is now available at sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl\n```\n\n## Step 2: Download trusted roots\nNext, get the key material from the trusted roots.\n\nArtifact attestations uses the Sigstore public good instance for public repositories, and GitHub's Sigstore instance for private repositories. You can use one command to get both trusted roots:\n\n```hljs bash\ngh attestation trusted-root > trusted_root.jsonl\n```\n\n## Updating trusted root information in an offline environment\nIt's best practice to generate a new `trusted_root.jsonl` file any time you are importing new signed material into your offline environment.\n\nThe key material in `trusted_root.jsonl` does not have a built-in expiration date, so anything signed before you generate the trusted root file will continue to successfully verify. Anything signed after the file is generated will verify until that Sigstore instance rotates its key material, which typically happens a few times per year. You will not know if key material has been revoked since you last generated the trusted root file.\n\n## Step 3: Perform offline verification\nNow, you are ready to verify the artifact offline.\n\nYou should import into your offline environment:\n\n- GitHub CLI\n- Your artifact\n- The bundle file\n- The trusted root file\n\nYou can then perform offline verification with the following command:\n\n```hljs bash\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME --bundle sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl --custom-trusted-root trusted_root.jsonl\n```\n\n## Conclusion\nYou are now verifying artifact attestations in an offline environment. We recommend importing a new trusted root whenever you are introducing new signed artifacts to your offline environment.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Verifying attestations offline?\n\nAssistant: Here are some code examples:\n\n### Download attestation bundle\n```yaml\ngh attestation download PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME\n```\n\n### Example output from download command\n```yaml\nWrote attestations to file sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl.\nAny previous content has been overwritten\n\nThe trusted metadata is now available at sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl\n```\n\n### Download trusted roots\n```yaml\ngh attestation trusted-root > trusted_root.jsonl\n```\n\n### Perform offline verification\n```yaml\ngh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME --bundle sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl --custom-trusted-root trusted_root.jsonl\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Verifying attestations offline?\n\nAssistant: Here are the recommended best practices:\n\n• It's best practice to generate a new `trusted_root.jsonl` file any time you are importing new signed material into your offline environment.\n• The key material in `trusted_root.jsonl` does not have a built-in expiration date, so anything signed before you generate the trusted root file will continue to successfully verify.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Running jobs on larger runners?\n\nAssistant: You can speed up your workflows by configuring them to run on larger runners.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\n## Platform navigation\n\n\n## In this article\n\n\n## Running jobs on your runner\nOnce your runner type has been defined, you can update your workflow YAML files to send jobs to your newly created runner instances for processing. You can use runner groups or labels to define where your jobs run.\n\nNote\n\nLarger runners are automatically assigned a default label that corresponds to the runner name. You cannot add custom labels to larger runners, but you can use the default labels or the runner's group to send jobs to specific types of runners.\n\nOnly owner or administrator accounts can see the runner settings. Non-administrative users can contact the organization owner to find out which runners are enabled. Your organization owner can create new runners and runner groups, as well as configure permissions to specify which repositories can access a runner group. For more information, see Managing larger runners.\n\n## Available macOS larger runners\nUse the labels in the table below to run your workflows on the corresponding macOS larger runner.\n\n| Runner Size | Architecture | Processor (CPU) | Memory (RAM) | Storage (SSD) | Workflow label |\n| --- | --- | --- | --- | --- | --- |\n| Large | Intel | 12 | 30 GB | 14 GB | `macos-latest-large`, `macos-13-large`, `macos-14-large` [latest], `macos-15-large` [Public preview] |\n| XLarge | arm64 (M1) | 6 (+ 8 GPU hardware acceleration) | 14 GB | 14 GB | `macos-latest-xlarge`, `macos-13-xlarge`, `macos-14-xlarge` [latest], `macos-15-xlarge` [Public preview] |\n\nNote\n\nFor macOS larger runners, the `-latest` runner label uses the macOS 12 runner image. For macOS Xlarge, the `-latest` runner label uses the macOS 13 runner image.\n\n## Viewing available runners for a repository\nIf you have `repo: write` access to a repository, you can view a list of the runners available to the repository.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n\n3. In the left sidebar, under the \"Management\" section, click **Runners**.\n\n4. Review the list of available runners for the repository.\n\n5. Optionally, to copy a runner's label to use it in a workflow, click  to the right of the runner, then click **Copy label**.\n\nNote\n\nEnterprise and organization owners can create runners from this page. To create a new runner, click **New runner** at the top right of the list of runners to add runners to the repository.\n\n## Using groups to control where jobs are run\nIn this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:\n\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## Using labels to control where jobs are run\nYou can implicitly pass a label to the `runs-on` key by using the syntax `runs-on: LABEL`. Alternatively, you can use the `labels` key, as shown in the example below.\n\nIn this example, the `runs-on` key sends the job to any available runner that has been assigned the `ubuntu-20.04-16core` label:\n\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## Targeting macOS larger runners in a workflow\nTo run your workflows on macOS larger runners, set the value of the `runs-on` key to a label associated with a macOS larger runner. For a list of macOS larger runner labels, see Available macOS larger runners.\n\nIn this example, the workflow uses a label that is associated with macOS XL runners. The `runs-on` key sends the job to any available runner with a matching label:\n\n```yaml\nname: learn-github-actions-testing\non: [push]\njobs:\n  build:\n    runs-on: macos-13-xlarge\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n```\n\n## Using labels and groups to control where jobs are run\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:\n\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n\n## Troubleshooting larger runners\nIf you notice the jobs that target your larger runners are delayed or not running, there are several factors that may be causing this.\n\n- **Concurrency settings:** You may have reached your maximum concurrency limit. If you would like to enable more jobs to run in parallel, you can update your autoscaling settings to a larger number.\n- **Repository permissions:** Ensure you have the appropriate repository permissions enabled for your larger runners. By default, enterprise runners are not available at the repository level and must be manually enabled by an organization administrator.\n- **Billing information:** You must have a valid credit card on file in order to use larger runners. After adding a credit card to your account, it can take up to 10 minutes to enable the use of your larger runners.\n- **Spending limit:** Your GitHub Actions spending limit must be set to a value greater than zero.\n- **Fair use policy:** GitHub has a fair use policy that begins to throttle jobs based on several factors, such as how many jobs you are running or how many jobs are running across the entirety of GitHub Actions.\n- **Job queue to assign time:** Job queue to assign time refers to the time between a job request and GitHub assigning a VM to execute the job. Standard GitHub-hosted runners utilizing prescribed YAML workflow labels (such as `ubuntu-latest`) are always in a \"warm\" state. With larger runners, a warm machine may not be ready to pick up a job on first request as the pools for these machines are smaller.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Running jobs on larger runners?\n\nAssistant: Here are some code examples:\n\n### Using groups to control where jobs are run\n```yaml\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n### Using labels to control where jobs are run\n```yaml\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n### Targeting macOS larger runners in a workflow\n```yaml\n```yaml\nname: learn-github-actions-testing\non: [push]\njobs:\n  build:\n    runs-on: macos-13-xlarge\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test\n```\n```\n\n### Using labels and groups to control where jobs are run\n```yaml\n```yaml\nname: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Running jobs on larger runners?\n\nAssistant: Here are the recommended best practices:\n\n• Larger runners are automatically assigned a default label that corresponds to the runner name.\n• Only owner or administrator accounts can see the runner settings.\n• Non-administrative users can contact the organization owner to find out which runners are enabled.\n• Enterprise and organization owners can create runners from the repository management page.\n• You must have a valid credit card on file in order to use larger runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using containerized services?\n\nAssistant: You can use containerized services in your GitHub Actions workflows.\n\nHere's a detailed explanation:\n\n\n## About service containers\nYou can use service containers to connect databases, web services, memory caches, and other tools to your workflow.\n\n## Creating PostgreSQL service containers\nYou can create a PostgreSQL service container to use in your workflow. This guide shows examples of creating a PostgreSQL service for jobs that run in containers or directly on the runner machine.\n\n## Creating Redis service containers\nYou can use service containers to create a Redis client in your workflow. This guide shows examples of creating a Redis service for jobs that run in containers or directly on the runner machine.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Sharing workflows, secrets, and runners with your organization?\n\nAssistant: Learn how you can use organization features to collaborate with your team, by sharing workflow templates, secrets, variables, and self-hosted runners.\n\nHere's a detailed explanation:\n\n\n## Overview\nIf you need to share workflows and other GitHub Actions features with your team, then consider collaborating within a GitHub organization. An organization allows you to centrally store and manage secrets, artifacts, and self-hosted runners. You can also create workflow templates in the `.github` repository and share them with other users in your organization.\n\n## Sharing workflows\nYour organization can share workflows by reusing the workflows exactly or by creating workflow templates.\n\n## Reusing workflows\nYou can call one workflow from within another workflow. This allows you to reuse workflows, avoiding duplication and making your workflows easier to maintain. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Using workflow templates\nWorkflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization. For more information, see [Creating workflow templates for your organization](https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization).\n\n## Sharing secrets and variables within an organization\nYou can centrally manage your secrets and variables within an organization, and then make them available to selected repositories. This also means that you can update a secret or variable in one location, and have the change apply to all repository workflows that use it.\n\nWhen creating a secret or variable in an organization, you can use a policy to limit which repositories can access it. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.\n\nOrganization owners can create secrets or variables at the organization level.\n\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n3. In the \"Security\" section of the sidebar, select **Secrets and variables**, then click **Actions**.\n4. Click the **Secrets** or **Variables** tab, and create the secret or variable with your desired values and options.\n\nFor more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions#creating-secrets-for-an-organization) or [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-an-organization).\n\n## Share self-hosted runners within an organization\nOrganization owners can add their self-hosted runners to groups, and then create policies that control which repositories can access the group.\n\nFor more information, see [Managing access to self-hosted runners using groups](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups).\n\n## Next steps\nTo continue learning about GitHub Actions, see [Creating workflow templates for your organization](https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Sharing workflows, secrets, and runners with your organization?\n\nAssistant: Here are the recommended best practices:\n\n• Consider collaborating within a GitHub organization to share workflows and other GitHub Actions features.\n• Use workflow templates to save time and promote consistency across your organization.\n• Centrally manage secrets and variables to make them available to selected repositories.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Jenkins to GitHub Actions?\n\nAssistant: GitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\n\nHere's a detailed explanation:\n\n\n## Introduction\nJenkins and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Jenkins and GitHub Actions share some similarities in workflow configuration:\n\n- Jenkins creates workflows using _Declarative Pipelines_, which are similar to GitHub Actions workflow files.\n- Jenkins uses _stages_ to run a collection of steps, while GitHub Actions uses jobs to group one or more steps or individual commands.\n- Jenkins and GitHub Actions support container-based builds. For more information, see [Creating a Docker container action](https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action).\n- Steps or tasks can be reused and shared with the community.\n\nFor more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions).\n\n## Key differences\n- Jenkins has two types of syntax for creating pipelines: Declarative Pipeline and Scripted Pipeline. GitHub Actions uses YAML to create workflows and configuration files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n- Jenkins deployments are typically self-hosted, with users maintaining the servers in their own data centers. GitHub Actions offers a hybrid cloud approach by hosting its own runners that you can use to run jobs, while also supporting self-hosted runners. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\n## Comparing capabilities\n### Distributing your builds\nJenkins lets you send builds to a single build agent, or you can distribute them across multiple agents. You can also classify these agents according to various attributes, such as operating system types.\n\nSimilarly, GitHub Actions can send jobs to GitHub-hosted or self-hosted runners, and you can use labels to classify runners according to various attributes. For more information, see [Understanding GitHub Actions](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#runners) and [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners).\n\n### Using sections to organize pipelines\nJenkins splits its Declarative Pipelines into multiple sections. Similarly, GitHub Actions organizes its workflows into separate sections. The table below compares Jenkins sections with the GitHub Actions workflow.\n\n| Jenkins Directives | GitHub Actions |\n| --- | --- |\n| [`agent`](https://jenkins.io/doc/book/pipeline/syntax/#agent) | [`jobs.<job_id>.runs-on`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on)<br>[`jobs.<job_id>.container`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idcontainer) |\n| [`post`](https://jenkins.io/doc/book/pipeline/syntax/#post) | None |\n| [`stages`](https://jenkins.io/doc/book/pipeline/syntax/#stages) | [`jobs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobs) |\n| [`steps`](https://jenkins.io/doc/book/pipeline/syntax/#steps) | [`jobs.<job_id>.steps`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) |\n\n## Using directives\nJenkins uses directives to manage _Declarative Pipelines_. These directives define the characteristics of your workflow and how it will execute. The table below demonstrates how these directives map to concepts within GitHub Actions.\n\n| Jenkins Directives | GitHub Actions |\n| --- | --- |\n| [`environment`](https://jenkins.io/doc/book/pipeline/syntax/#environment) | [`jobs.<job_id>.env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#env)<br>[`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv) |\n| [`options`](https://jenkins.io/doc/book/pipeline/syntax/#parameters) | [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy)<br>[`jobs.<job_id>.strategy.fail-fast`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast)<br>[`jobs.<job_id>.timeout-minutes`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idtimeout-minutes) |\n| [`parameters`](https://jenkins.io/doc/book/pipeline/syntax/#parameters) | [`inputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs)<br>[`outputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#outputs-for-docker-container-and-javascript-actions) |\n| [`triggers`](https://jenkins.io/doc/book/pipeline/syntax/#triggers) | [`on`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#on)<br>[`on.<event_name>.types`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes)<br>[`on.<push>.<branches|tags>`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore)<br>[`on.<pull_request>.<branches>`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore)<br>[`on.<push|pull_request>.paths`](https://docs.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore) |\n| [`triggers { upstreamprojects() }`](https://jenkins.io/doc/book/pipeline/syntax/#triggers) | [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds) |\n| [Jenkins cron syntax](https://jenkins.io/doc/book/pipeline/syntax/#cron-syntax) | [`on.schedule`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onschedule) |\n| [`stage`](https://jenkins.io/doc/book/pipeline/syntax/#stage) | [`jobs.<job_id>`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_id)<br>[`jobs.<job_id>.name`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) |\n| [`tools`](https://jenkins.io/doc/book/pipeline/syntax/#tools) | [Specifications for GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software) |\n| [`input`](https://jenkins.io/doc/book/pipeline/syntax/#input) | [`inputs`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs) |\n| [`when`](https://jenkins.io/doc/book/pipeline/syntax/#when) | [`jobs.<job_id>.if`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idif) |\n\n## Using sequential stages\n### Parallel job processing\nJenkins can run the `stages` and `steps` in parallel, while GitHub Actions currently only runs jobs in parallel.\n\n| Jenkins Parallel | GitHub Actions |\n| --- | --- |\n| [`parallel`](https://jenkins.io/doc/book/pipeline/syntax/#parallel) | [`jobs.<job_id>.strategy.max-parallel`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel) |\n\n### Matrix\nBoth GitHub Actions and Jenkins let you use a matrix to define various system combinations.\n\n| Jenkins | GitHub Actions |\n| --- | --- |\n| [`axis`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-axes) | [`strategy/matrix`](https://docs.github.com/en/actions/using-workflows/about-workflows#using-a-build-matrix)<br>[`context`](https://docs.github.com/en/actions/learn-github-actions/contexts) |\n| [`stages`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-stages) | [`steps-context`](https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context) |\n| [`excludes`](https://jenkins.io/doc/book/pipeline/syntax/#matrix-stages) | None |\n\n### Using steps to execute tasks\nJenkins groups `steps` together in `stages`. Each of these steps can be a script, function, or command, among others. Similarly, GitHub Actions uses `jobs` to execute specific groups of `steps`.\n\n| Jenkins | GitHub Actions |\n| --- | --- |\n| [`steps`](https://jenkins.io/doc/book/pipeline/syntax/#steps) | [`jobs.<job_id>.steps`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsteps) |\n\n## Examples of common tasks\n### Scheduling a pipeline to run with `cron`\n#### Jenkins pipeline with `cron`\n```hljs yaml\npipeline {\n  agent any\n  triggers {\n    cron('H/15 * * * 1-5')\n  }\n}\n```\n#### GitHub Actions workflow with `cron`\n```hljs yaml\non:\n  schedule:\n    - cron: '*/15 * * * 1-5'\n```\n\n### Configuring environment variables in a pipeline\n#### Jenkins pipeline with an environment variable\n```hljs yaml\npipeline {\n  agent any\n  environment {\n    MAVEN_PATH = '/usr/local/maven'\n  }\n}\n```\n#### GitHub Actions workflow with an environment variable\n```hljs yaml\njobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'\n```\n\n### Building from upstream projects\n#### Jenkins pipeline that builds from an upstream project\n```hljs yaml\npipeline {\n  triggers {\n    upstream(\n      upstreamProjects: 'job1,job2',\n      threshold: hudson.model.Result.SUCCESS\n    )\n  }\n}\n```\n#### GitHub Actions workflow that builds from an upstream project\n```hljs yaml\njobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]\n```\n\n### Building with multiple operating systems\n#### Jenkins pipeline that builds with multiple operating systems\n```hljs yaml\npipeline {\n  agent none\n  stages {\n    stage('Run Tests') {\n      matrix {\n        axes {\n          axis {\n            name: 'PLATFORM'\n            values: 'macos', 'linux'\n          }\n        }\n        agent { label \"${PLATFORM}\" }\n        stages {\n          stage('test') {\n            tools { nodejs \"node-20\" }\n            steps {\n              dir(\"scripts/myapp\") {\n                sh(script: \"npm install -g bats\")\n                sh(script: \"bats tests\")\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n#### GitHub Actions workflow that builds with multiple operating systems\n```hljs yaml\nname: demo-workflow\non:\n  push:\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, ubuntu-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm install -g bats\n      - run: bats tests\n        working-directory: ./scripts/myapp\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Jenkins to GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### Jenkins pipeline with `cron`\n```yaml\npipeline {\n  agent any\n  triggers {\n    cron('H/15 * * * 1-5')\n  }\n}\n\n```\n\n### GitHub Actions workflow with `cron`\n```yaml\non:\n  schedule:\n    - cron: '*/15 * * * 1-5'\n\n```\n\n### Jenkins pipeline with an environment variable\n```yaml\npipeline {\n  agent any\n  environment {\n    MAVEN_PATH = '/usr/local/maven'\n  }\n}\n\n```\n\n### GitHub Actions workflow with an environment variable\n```yaml\njobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'\n\n```\n\n### Jenkins pipeline that builds from an upstream project\n```yaml\npipeline {\n  triggers {\n    upstream(\n      upstreamProjects: 'job1,job2',\n      threshold: hudson.model.Result.SUCCESS\n    )\n  }\n}\n\n```\n\n### GitHub Actions workflow that builds from an upstream project\n```yaml\njobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]\n\n```\n\n### Jenkins pipeline that builds with multiple operating systems\n```yaml\npipeline {\n  agent none\n  stages {\n    stage('Run Tests') {\n      matrix {\n        axes {\n          axis {\n            name: 'PLATFORM'\n            values: 'macos', 'linux'\n          }\n        }\n        agent { label \"${PLATFORM}\" }\n        stages {\n          stage('test') {\n            tools { nodejs \"node-20\" }\n            steps {\n              dir(\"scripts/myapp\") {\n                sh(script: \"npm install -g bats\")\n                sh(script: \"bats tests\")\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n### GitHub Actions workflow that builds with multiple operating systems\n```yaml\nname: demo-workflow\non:\n  push:\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, ubuntu-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm install -g bats\n      - run: bats tests\n        working-directory: ./scripts/myapp\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating Redis service containers?\n\nAssistant: You can use service containers to create a Redis client in your workflow. This guide shows examples of creating a Redis service for jobs that run in containers or directly on the runner machine.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you workflow examples that configure a service container using the Docker Hub `redis` image. The workflow runs a script to create a Redis client and populate the client with data. To test that the workflow creates and populates the Redis client, the script prints the client's data to the console.\n\nNote\n\nIf your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:\n\n- If you are using GitHub-hosted runners, you must use an Ubuntu runner.\n- If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.\n\n## Prerequisites\nYou should be familiar with how service containers work with GitHub Actions and the networking differences between running jobs directly on the runner or in a container. For more information, see [About service containers](https://docs.github.com/en/actions/using-containerized-services/about-service-containers).\n\nYou may also find it helpful to have a basic understanding of YAML, the syntax for GitHub Actions, and Redis. For more information, see:\n\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n- [Getting Started with Redis](https://redislabs.com/get-started-with-redis/) in the Redis documentation.\n\n## Running jobs in containers\nConfiguring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow.\n\nYou can copy this workflow file to the `.github/workflows` directory of your repository and modify it as needed.\n\n## Configuring the container job\nThis workflow configures a job that runs in the `node:20-bookworm-slim` container and uses the `ubuntu-latest` GitHub-hosted runner as the Docker host for the container. For more information about the `node:20-bookworm-slim` container, see the [node image](https://hub.docker.com/_/node) on Docker Hub.\n\nThe workflow configures a service container with the label `redis`. All services must run in a container, so each service requires that you specify the container `image`. This example uses the `redis` container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. `redis:6`. For more information, see the [redis image](https://hub.docker.com/_/redis) on Docker Hub.\n\n## Configuring the steps for the container job\nThe workflow performs the following steps:\n\n1. Checks out the repository on the runner\n2. Installs dependencies\n3. Runs a script to create a client\n\n## Running jobs directly on the runner machine\nWhen you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host using `localhost` and the Docker host port number.\n\nYou can copy this workflow file to the `.github/workflows` directory of your repository and modify it as needed.\n\n## Configuring the runner job\nThe example uses the `ubuntu-latest` GitHub-hosted runner as the Docker host.\n\nThe workflow configures a service container with the label `redis`. All services must run in a container, so each service requires that you specify the container `image`. This example uses the `redis` container image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g. `redis:6`. For more information, see the [redis image](https://hub.docker.com/_/redis) on Docker Hub.\n\nThe workflow maps port 6379 on the Redis service container to the Docker host.\n\n## Configuring the steps for the runner job\nThe workflow performs the following steps:\n\n1. Checks out the repository on the runner\n2. Installs dependencies\n3. Runs a script to create a client\n\n## Testing the Redis service container\nYou can test your workflow using the following script, which creates a Redis client and populates the client with some placeholder data. The script then prints the values stored in the Redis client to the terminal. Your script can use any language you'd like, but this example uses Node.js and the `redis` npm module. For more information, see the [npm redis module](https://www.npmjs.com/package/redis).\n\nYou can modify _client.js_ to include any Redis operations needed by your workflow. In this example, the script creates the Redis client instance, adds placeholder data, then retrieves the data.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating Redis service containers?\n\nAssistant: Here are some code examples:\n\n### Redis container example\n```yaml\nname: Redis container example\non: push\n\njobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to Redis\n        # Runs a script that creates a Redis client, populates\n        # the client with data, and retrieves data\n        run: node client.js\n        # Environment variable used by the `client.js` script to create a new Redis client.\n        env:\n          # The hostname used to communicate with the Redis service container\n          REDIS_HOST: redis\n          # The default Redis port\n          REDIS_PORT: 6379\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating Redis service containers?\n\nAssistant: Here are the recommended best practices:\n\n• Use a Linux runner for workflows that involve Docker container actions, job containers, or service containers.\n• Familiarize yourself with YAML and GitHub Actions syntax for better workflow configuration.\n• Ensure that Docker is installed on self-hosted runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Adding scripts to your workflow?\n\nAssistant: You can use GitHub Actions workflows to run scripts.\n\nHere's a detailed explanation:\n\n\n## Using the run keyword to execute commands\nYou can use a GitHub Actions workflow to run scripts and shell commands, which are then executed on the assigned runner. This example demonstrates how to use the `run` keyword to execute the command `npm install -g bats` on the runner.\n\n## Running scripts stored in your repository\nTo use a workflow to run a script stored in your repository you must first check out the repository to the runner. Having done this, you can use the `run` keyword to run the script on the runner. The following example runs two scripts, each in a separate job step. The location of the scripts on the runner is specified by setting a default working directory for run commands.\n\n## Making scripts executable\nAny scripts that you want a workflow job to run must be executable. You can do this either within the workflow by passing the script as an argument to the interpreter that will run the script - for example, `run: bash script.sh` - or by making the file itself executable. You can give the file the execute permission by using the command `git update-index --chmod=+x PATH/TO/YOUR/script.sh` locally, then committing and pushing the file to the repository. Alternatively, for workflows that are run on Linux and Mac runners, you can add a command to give the file the execute permission in the workflow job, prior to running the script.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Adding scripts to your workflow?\n\nAssistant: Here are some code examples:\n\n### Example of running a command using run\n```yaml\njobs:\n  example-job:\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm install -g bats\n\n```\n\n### Example of running scripts stored in the repository\n```yaml\njobs:\n  example-job:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./scripts\n    steps:\n      - name: Check out the repository to the runner\n        uses: actions/checkout@v4\n      - name: Run a script\n        run: ./my-script.sh\n      - name: Run another script\n        run: ./my-other-script.sh\n\n```\n\n### Example of making scripts executable\n```yaml\njobs:\n  example-job:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./scripts\n    steps:\n      - name: Check out the repository to the runner\n        uses: actions/checkout@v4\n      - name: Make the script files executable\n        run: chmod +x my-script.sh my-other-script.sh\n      - name: Run the scripts\n        run: |\n          ./my-script.sh\n          ./my-other-script.sh\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Adding scripts to your workflow?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure scripts are executable before running them in the workflow.\n• Use the `run` keyword to execute shell commands and scripts.\n• Set a default working directory for scripts to simplify paths.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating actions?\n\nAssistant: You can create your own actions, use and customize actions shared by the GitHub community, or write and share the actions you build.\n\nHere's a detailed explanation:\n\n\n## About custom actions\nActions are individual tasks that you can combine to create jobs and customize your workflow. You can create your own actions, or use and customize actions shared by the GitHub community.\n\n## Creating a Docker container action\nThis guide shows you the minimal steps required to build a Docker container action.\n\n## Creating a JavaScript action\nIn this guide, you'll learn how to build a JavaScript action using the actions toolkit.\n\n## Creating a composite action\nIn this guide, you'll learn how to build a composite action.\n\n## Metadata syntax for GitHub Actions\nYou can create actions to perform tasks in your repository. Actions require a metadata file that uses YAML syntax.\n\n## Dockerfile support for GitHub Actions\nWhen creating a Dockerfile for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.\n\n## Setting exit codes for actions\nYou can use exit codes to set the status of an action. GitHub displays statuses to indicate passing or failing actions.\n\n## Releasing and maintaining actions\nYou can leverage automation and open source best practices to release and maintain actions.\n\n## Publishing actions in GitHub Marketplace\nYou can publish actions in GitHub Marketplace and share actions you've created with the GitHub community.\n\n## Developing a third party CLI action\nLearn how to develop an action to set up a CLI on GitHub Actions runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Node.js?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your Node.js project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a continuous integration (CI) workflow that builds and tests Node.js code. If your CI tests pass, you may want to deploy your code or publish a package.\n\n## Prerequisites\nWe recommend that you have a basic understanding of Node.js, YAML, workflow configuration options, and how to create a workflow file. For more information, see:\n\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n- [Getting started with Node.js](https://nodejs.org/en/docs/guides/getting-started-guide/)\n\n## Using a Node.js workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Node.js that should work for most Node.js projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. If you already have a workflow in your repository, click **New workflow**.\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Node.js\".\n5. Filter the selection of workflows by clicking **Continuous integration**.\n6. On the \"Node.js\" workflow, click **Configure**.\n7. Edit the workflow as required. For example, change the Node versions you want to use.\n8. Click **Commit changes**.\n\nThe `node.js.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying the Node.js version\nThe easiest way to specify a Node.js version is by using the `setup-node` action provided by GitHub. For more information see, [`setup-node`](https://github.com/actions/setup-node/).\n\nThe `setup-node` action takes a Node.js version as an input and configures that version on the runner. The `setup-node` action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to `PATH`, which persists for the rest of the job. Using the `setup-node` action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to `PATH`.\n\nThe workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in `node-version`. The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the `node-version` array creates a job that runs the same steps.\n\nEach job can access the value defined in the matrix `node-version` array using the `matrix` context. The `setup-node` action uses the context as the `node-version` input. The `setup-node` action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix) and [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n\n## Installing dependencies\nGitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed.\n\nYou can also cache dependencies to speed up your workflow. For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code. For example, if you run `npm run build` to run build steps defined in your `package.json` file and `npm test` to run your test suite, you would add those commands in your workflow file.\n\n## Packaging workflow data as artifacts\nYou can save artifacts from your build and test steps to view after a job completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\n## Publishing to package registries\nYou can configure your workflow to publish your Node.js package to a package registry after your CI tests pass. For more information about publishing to npm and GitHub Packages, see [Publishing Node.js packages](https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Node.js?\n\nAssistant: Here are some code examples:\n\n### Specifying Node.js version with matrix strategy\n```yaml\nstrategy:\n  matrix:\n    node-version: ['18.x', '20.x']\n\nsteps:\n- uses: actions/checkout@v4\n- name: Use Node.js ${{ matrix.node-version }}\n  uses: actions/setup-node@v4\n  with:\n    node-version: ${{ matrix.node-version }}\n\n```\n\n### Building and testing with exact Node.js versions\n```yaml\nstrategy:\n  matrix:\n    node-version: ['10.17.0', '17.9.0']\n\n```\n\n### Building and testing with a single Node.js version\n```yaml\nname: Node.js CI\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Use Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n      - run: npm ci\n      - run: npm run build --if-present\n      - run: npm test\n\n```\n\n### Installing dependencies using npm\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: npm ci\n\n```\n\n### Installing dependencies using Yarn\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: yarn --frozen-lockfile\n\n```\n\n### Using a private registry and creating the .npmrc file\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    always-auth: true\n    node-version: '20.x'\n    registry-url: https://registry.npmjs.org\n    scope: '@octocat'\n- name: Install dependencies\n  run: npm ci\n  env:\n    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n\n```\n\n### Caching dependencies for npm\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'npm'\n- run: npm install\n- run: npm test\n\n```\n\n### Caching dependencies for Yarn\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'yarn'\n- run: yarn\n- run: yarn test\n\n```\n\n### Caching dependencies for pnpm\n```yaml\nsteps:\n- uses: actions/checkout@v4\n- uses: pnpm/action-setup@0609f0983b7a228f052f81ef4c3d6510cae254ad\n  with:\n    version: 6.10.0\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'pnpm'\n- run: pnpm install\n- run: pnpm test\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Node.js?\n\nAssistant: Here are the recommended best practices:\n\n• Using `npm ci` is generally faster than running `npm install`.\n• If you don't specify a Node.js version, GitHub uses the environment's default Node.js version.\n• You can cache dependencies to speed up your workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying Docker to Azure App Service?\n\nAssistant: You can deploy a Docker container to Azure App Service as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a Docker container to Azure App Service.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Azure.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create an Azure App Service plan.\n\nFor example, you can use the Azure CLI to create a new App Service plan:\n\n```hljs bash\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```  \n\nIn the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n\nSee the Azure documentation for more information on using the Azure CLI:\n   - For authentication, see Sign in with Azure CLI.\n   - If you need to create a new resource group, see az group.\n\n2. Create a web app.\n\nFor example, you can use the Azure CLI to create an Azure App Service web app:\n\n```hljs shell\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --deployment-container-image-name nginx:latest\n```  \n\nIn the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n\n3. Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\n\nIn your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\n\n4. Set registry credentials for your web app.\n\nCreate a personal access token (classic) with the `repo` and `read:packages` scopes. For more information, see Managing your personal access tokens.\n\nSet `DOCKER_REGISTRY_SERVER_URL` to `https://ghcr.io`, `DOCKER_REGISTRY_SERVER_USERNAME` to the GitHub username or organization that owns the repository, and `DOCKER_REGISTRY_SERVER_PASSWORD` to your personal access token from above. This will give your web app credentials so it can pull the container image after your workflow pushes a newly built image to the registry. You can do this with the following Azure CLI command:\n\n```hljs shell\n    az webapp config appsettings set \\\n        --name MY_WEBAPP_NAME \\\n        --resource-group MY_RESOURCE_GROUP \\\n        --settings DOCKER_REGISTRY_SERVER_URL=https://ghcr.io DOCKER_REGISTRY_SERVER_USERNAME=MY_REPOSITORY_OWNER DOCKER_REGISTRY_SERVER_PASSWORD=MY_PERSONAL_ACCESS_TOKEN\n```\n\n5. Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a Docker container to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy a container to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: 'read'\n  packages: 'write'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b\n\n      - name: Log in to GitHub container registry\n        uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Build and push container image to registry\n        uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f\n        with:\n          push: true\n          tags: ghcr.io/${{ env.REPO }}:${{ github.sha }}\n          file: ./Dockerfile\n\n  deploy:\n    runs-on: ubuntu-latest\n\n    needs: build\n\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}'\n```\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-container-webapp.yml` in the GitHub Actions `starter-workflows` repository.\n- The action used to deploy the web app is the official Azure `Azure/webapps-deploy` action.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying Docker to Azure App Service?\n\nAssistant: Here are some code examples:\n\n### Create an Azure App Service plan\n```yaml\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```\n\n### Create an Azure App Service web app\n```yaml\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --deployment-container-image-name nginx:latest\n```\n\n### Set registry credentials for your web app\n```yaml\naz webapp config appsettings set \\\n        --name MY_WEBAPP_NAME \\\n        --resource-group MY_RESOURCE_GROUP \\\n        --settings DOCKER_REGISTRY_SERVER_URL=https://ghcr.io DOCKER_REGISTRY_SERVER_USERNAME=MY_REPOSITORY_OWNER DOCKER_REGISTRY_SERVER_PASSWORD=MY_PERSONAL_ACCESS_TOKEN\n```\n\n### GitHub Actions workflow for deploying Docker to Azure\n```yaml\nname: Build and deploy a container to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: 'read'\n  packages: 'write'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b\n\n      - name: Log in to GitHub container registry\n        uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Build and push container image to registry\n        uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f\n        with:\n          push: true\n          tags: ghcr.io/${{ env.REPO }}:${{ github.sha }}\n          file: ./Dockerfile\n\n  deploy:\n    runs-on: ubuntu-latest\n\n    needs: build\n\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying Docker to Azure App Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About monitoring workflows?\n\nAssistant: You can use the tools in GitHub Actions to monitor your workflows, metrics, and self-hosted runners.\n\nHere's a detailed explanation:\n\n\n## Monitoring your workflows\nTo identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see [Monitoring your current jobs](https://docs.github.com/en/actions/using-github-hosted-runners/monitoring-your-current-jobs).\n\n## Using the visualization graph\nEvery workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows. For example:\n\n![Screenshot of the visualization graph of a workflow run.](https://docs.github.com/assets/cb-63715/images/help/actions/workflow-graph.png)\n\nFor more information, see [Using the visualization graph](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-the-visualization-graph).\n\n## Adding a workflow status badge\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the `README.md` file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the `branch` and `event` query parameters in the URL.\n\n![Screenshot of a workflow status badge. From right to left it shows: the GitHub logo, workflow name (\"GitHub Actions Demo\"), and status (\"passing\").](https://docs.github.com/assets/cb-16218/images/help/repository/actions-workflow-status-badge.png)\n\nFor more information, see [Adding a workflow status badge](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/adding-a-workflow-status-badge).\n\n## Viewing job execution time\nTo identify how long a job took to run, you can view its execution time. For more information, see [Viewing job execution time](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-job-execution-time).\n\n## Viewing workflow run history\nYou can view the status of each job and step in a workflow. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\n## Monitoring GitHub Actions metrics\nTo analyze the efficiency and reliability of your workflows using metrics, see [Viewing GitHub Actions metrics](https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics).\n\n## Monitoring self-hosted runners\nIf you use self-hosted runners, you can view their activity and diagnose common issues.\n\nFor more information, see [Monitoring and troubleshooting self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Closing inactive issues?\n\nAssistant: You can use GitHub Actions to comment on or close issues that have been inactive for a certain period of time.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis tutorial demonstrates how to use the [`actions/stale` action](https://github.com/marketplace/actions/close-stale-issues) to comment on and close issues that have been inactive for a certain period of time. For example, you can comment if an issue has been inactive for 30 days to prompt participants to take action. Then, if no additional activity occurs after 14 days, you can close the issue.\n\nIn the tutorial, you will first make a workflow file that uses the [`actions/stale` action](https://github.com/marketplace/actions/close-stale-issues). Then, you will customize the workflow to suit your needs.\n\n## Creating the workflow\n1. Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n\n2. In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n3. Copy the following YAML contents into your workflow file.\n\n```hljs yaml\nname: Close inactive issues\non:\n     schedule:\n    - cron: \"30 1 * * *\"\n\njobs:\nclose-issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - uses: actions/stale@v9\n        with:\n          days-before-issue-stale: 30\n          days-before-issue-close: 14\n          stale-issue-label: \"stale\"\n          stale-issue-message: \"This issue is stale because it has been open for 30 days with no activity.\"\n          close-issue-message: \"This issue was closed because it has been inactive for 14 days since being marked as stale.\"\n          days-before-pr-stale: -1\n          days-before-pr-close: -1\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```\n\n4. Customize the parameters in your workflow file:\n   - Change the value for `on.schedule` to dictate when you want this workflow to run. In the example above, the workflow will run every day at 1:30 UTC. For more information about scheduled workflows, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#scheduled-events).\n   - Change the value for `days-before-issue-stale` to the number of days without activity before the `actions/stale` action labels an issue. If you never want this action to label issues, set this value to `-1`.\n   - Change the value for `days-before-issue-close` to the number of days without activity before the `actions/stale` action closes an issue. If you never want this action to close issues, set this value to `-1`.\n   - Change the value for `stale-issue-label` to the label that you want to apply to issues that have been inactive for the amount of time specified by `days-before-issue-stale`.\n   - Change the value for `stale-issue-message` to the comment that you want to add to issues that are labeled by the `actions/stale` action.\n   - Change the value for `close-issue-message` to the comment that you want to add to issues that are closed by the `actions/stale` action.\n5. Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n## Expected results\nBased on the `schedule` parameter (for example, every day at 1:30 UTC), your workflow will find issues that have been inactive for the specified period of time and will add the specified comment and label. Additionally, your workflow will close any previously labeled issues if no additional activity has occurred for the specified period of time.\n\nNote\n\nThe `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n\nYou can view the history of your workflow runs to see this workflow run periodically. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n\nThis workflow will only label and/or close 30 issues at a time in order to avoid exceeding a rate limit. You can configure this with the `operations-per-run` setting. For more information, see the [`actions/stale` action documentation](https://github.com/marketplace/actions/close-stale-issues).\n\n## Next steps\n- To learn more about additional things you can do with the `actions/stale` action, like closing inactive pull requests, ignoring issues with certain labels or milestones, or only checking issues with certain labels, see the [`actions/stale` action documentation](https://github.com/marketplace/actions/close-stale-issues).\n- [Search GitHub](https://github.com/search?q=%22uses%3A+actions%2Fstale%22&type=code) for examples of workflows using this action.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Closing inactive issues?\n\nAssistant: Here are some code examples:\n\n### Close inactive issues workflow\n```yaml\nname: Close inactive issues\non:\n     schedule:\n    - cron: \"30 1 * * *\"\n\njobs:\nclose-issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - uses: actions/stale@v9\n        with:\n          days-before-issue-stale: 30\n          days-before-issue-close: 14\n          stale-issue-label: \"stale\"\n          stale-issue-message: \"This issue is stale because it has been open for 30 days with no activity.\"\n          close-issue-message: \"This issue was closed because it has been inactive for 14 days since being marked as stale.\"\n          days-before-pr-stale: -1\n          days-before-pr-close: -1\n          repo-token: ${{ secrets.GITHUB_TOKEN }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Closing inactive issues?\n\nAssistant: Here are the recommended best practices:\n\n• The `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.\n• This workflow will only label and/or close 30 issues at a time in order to avoid exceeding a rate limit. You can configure this with the `operations-per-run` setting.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About private networking with GitHub-hosted runners?\n\nAssistant: You can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.\n\nHere's a detailed explanation:\n\n\n## About GitHub-hosted runners networking\nBy default, GitHub-hosted runners have access to the public internet. However, you may also want these runners to access resources on your private network, such as a package registry, a secret manager, or other on-premise services.\n\nGitHub-hosted runners are shared across all GitHub customers. However with private networking, you can configure hosted runners to be exclusively used to connect to your private network and resources while they are running your workflows.\n\nThere are a few different approaches you could take to configure this access, each with different advantages and disadvantages.\n\n## Using an API Gateway with OIDC\nWith GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For more information, see [Using an API gateway with OIDC](https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc).\n\n## Using WireGuard to create a network overlay\nIf you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places. For more information, see [Using WireGuard to create a network overlay](https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-wireguard-to-create-a-network-overlay).\n\n## Using an Azure Virtual Network (VNET)\nYou can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners. For more information about Azure VNET, see [What is Azure Virtual Network?](https://learn.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview) in the Azure documentation.\n\nOrganization owners using the GitHub Team plan can configure Azure private networking for GitHub-hosted runners at the organization level. For more information, see [About Azure private networking for GitHub-hosted runners in your organization](https://docs.github.com/en/organizations/managing-organization-settings/about-azure-private-networking-for-github-hosted-runners-in-your-organization).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Automating migration with GitHub Actions Importer?\n\nAssistant: Use GitHub Actions Importer to plan and automate your migration to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About GitHub Actions Importer\nYou can use GitHub Actions Importer to plan and automatically migrate your CI/CD supported pipelines to GitHub Actions.\n\nGitHub Actions Importer is distributed as a Docker container, and uses a GitHub CLI extension to interact with the container.\n\nAny workflow that is converted by the GitHub Actions Importer should be inspected for correctness before using it as a production workload. The goal is to achieve an 80% conversion rate for every workflow, however, the actual conversion rate will depend on the makeup of each individual pipeline that is converted.\n\n## Supported CI platforms\nYou can use GitHub Actions Importer to migrate from the following platforms:\n\n- Azure DevOps\n- Bamboo\n- Bitbucket Pipelines\n- CircleCI\n- GitLab (both cloud and self-hosted)\n- Jenkins\n- Travis CI\n\n## Prerequisites\nGitHub Actions Importer has the following requirements:\n\n- An environment where you can run Linux-based containers, and can install the necessary tools.\n\n  - Docker is installed and running.\n  \n  - GitHub CLI is installed.\n\nNote\n\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n\n## Installing the GitHub Actions Importer CLI extension\n1. Install the GitHub Actions Importer CLI extension:\n\n```bash\ngh extension install github/gh-actions-importer\n```\n\n2. Verify that the extension is installed:\n\n```bash\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Updating the GitHub Actions Importer CLI\nTo ensure you're running the latest version of GitHub Actions Importer, you should regularly run the `update` command:\n\n```bash\ngh actions-importer update\n```\n\n## Authenticating at the command line\nYou must configure credentials that allow GitHub Actions Importer to communicate with GitHub and your current CI server. You can configure these credentials using environment variables or a `.env.local` file. The environment variables can be configured in an interactive prompt, by running the following command:\n\n```bash\ngh actions-importer configure\n```\n\n## Using the GitHub Actions Importer CLI\nUse the subcommands of `gh actions-importer` to begin your migration to GitHub Actions, including `audit`, `forecast`, `dry-run`, and `migrate`.\n\n## Auditing your existing CI pipelines\nThe `audit` subcommand can be used to plan your CI/CD migration by analyzing your current CI/CD footprint. This analysis can be used to plan a timeline for migrating to GitHub Actions.\n\nTo run an audit, use the following command to determine your available options:\n\n```bash\n$ gh actions-importer audit -h\nDescription:\n  Plan your CI/CD migration by analyzing your current CI/CD footprint.\n\n[...] \nCommands:\n  azure-devops  An audit will output a list of data used in an Azure DevOps instance.\n  bamboo        An audit will output a list of data used in a Bamboo instance.\n  circle-ci     An audit will output a list of data used in a CircleCI instance.\n  gitlab        An audit will output a list of data used in a GitLab instance.\n  jenkins       An audit will output a list of data used in a Jenkins instance.\n  travis-ci     An audit will output a list of data used in a Travis CI instance.\n```\n\n## Forecasting usage\nThe `forecast` subcommand reviews historical pipeline usage to create a forecast of GitHub Actions usage.\n\nTo run a forecast, use the following command to determine your available options:\n\n```bash\n$ gh actions-importer forecast -h\nDescription:\n  Forecasts GitHub Actions usage from historical pipeline utilization.\n\n[...] \nCommands:\n  azure-devops  Forecasts GitHub Actions usage from historical Azure DevOps pipeline utilization.\n  bamboo        Forecasts GitHub Actions usage from historical Bamboo pipeline utilization.\n  jenkins       Forecasts GitHub Actions usage from historical Jenkins pipeline utilization.\n  gitlab        Forecasts GitHub Actions usage from historical GitLab pipeline utilization.\n  circle-ci     Forecasts GitHub Actions usage from historical CircleCI pipeline utilization.\n  travis-ci     Forecasts GitHub Actions usage from historical Travis CI pipeline utilization.\n  github        Forecasts GitHub Actions usage from historical GitHub pipeline utilization.\n```\n\n## Testing the migration process\nThe `dry-run` subcommand can be used to convert a pipeline to its GitHub Actions equivalent, and then write the workflow to your local filesystem.\n\nTo perform a dry run, use the following command to determine your available options:\n\n```bash\n$ gh actions-importer dry-run -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n\n[...] \nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and output its yaml file.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and output its yaml file.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and output the yaml file(s).\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and output its yaml file.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and output its yaml file.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and output its yaml file.\n```\n\n## Migrating a pipeline to GitHub Actions\nThe `migrate` subcommand can be used to convert a pipeline to its GitHub Actions equivalent and then create a pull request with the contents.\n\nTo run a migration, use the following command to determine your available options:\n\n```bash\n$ gh actions-importer migrate -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n\n[...] \nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and open a pull request with the changes.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and open a pull request with the changes.\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and open a pull request with the changes.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Performing self-serve migrations using IssueOps\nYou can use GitHub Actions and GitHub Issues to run CLI commands for GitHub Actions Importer. This allows you to migrate your CI/CD workflows without installing software on your local machine. This approach is especially useful for organizations that want to enable self-service migrations to GitHub Actions. Once IssueOps is configured, users can open an issue with the relevant template to migrate pipelines to GitHub Actions.\n\nFor more information about setting up self-serve migrations with IssueOps, see the actions/importer-issue-ops template repository.\n\n## Using the GitHub Actions Importer labs repository\nThe GitHub Actions Importer labs repository contains platform-specific learning paths that teach you how to use GitHub Actions Importer and how to approach migrations to GitHub Actions. You can use this repository to learn how to use GitHub Actions Importer to help plan, forecast, and automate your migration to GitHub Actions.\n\nTo learn more, see the GitHub Actions Importer labs repository.\n\n## Legal notice\nPortions have been adapted from https://github.com/github/gh-actions-importer/ under the MIT license:\n\n```text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\naUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Automating migration with GitHub Actions Importer?\n\nAssistant: Here are some code examples:\n\n### Installing the GitHub Actions Importer CLI extension\n```yaml\ngh extension install github/gh-actions-importer\n```\n\n### Verifying the extension installation\n```yaml\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n### Updating the GitHub Actions Importer CLI\n```yaml\ngh actions-importer update\n```\n\n### Configuring credentials\n```yaml\ngh actions-importer configure\n```\n\n### Auditing your existing CI pipelines\n```yaml\n$ gh actions-importer audit -h\nDescription:\n  Plan your CI/CD migration by analyzing your current CI/CD footprint.\n```\n\n### Forecasting usage\n```yaml\n$ gh actions-importer forecast -h\nDescription:\n  Forecasts GitHub Actions usage from historical pipeline utilization.\n```\n\n### Testing the migration process\n```yaml\n$ gh actions-importer dry-run -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n```\n\n### Migrating a pipeline to GitHub Actions\n```yaml\n$ gh actions-importer migrate -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Automating migration with GitHub Actions Importer?\n\nAssistant: Here are the recommended best practices:\n\n• Inspect any workflow converted by the GitHub Actions Importer for correctness before using it as a production workload.\n• Aim for an 80% conversion rate for every workflow, but be aware that the actual conversion rate will depend on the individual pipeline makeup.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating to GitHub Actions?\n\nAssistant: Learn how to migrate your existing CI/CD workflows to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Using GitHub Actions Importer to automate migrations\n- Automating migration with GitHub Actions Importer\n- Extending GitHub Actions Importer with custom transformers\n- Supplemental arguments and settings\n- Migrating from Azure DevOps with GitHub Actions Importer\n- Migrating from Bamboo with GitHub Actions Importer\n- Migrating from Bitbucket Pipelines with GitHub Actions Importer\n- Migrating from CircleCI with GitHub Actions Importer\n- Migrating from GitLab with GitHub Actions Importer\n- Migrating from Jenkins with GitHub Actions Importer\n- Migrating from Travis CI with GitHub Actions Importer\n\n## Manually migrating to GitHub Actions\n- Migrating from Azure Pipelines to GitHub Actions\n- Migrating from CircleCI to GitHub Actions\n- Migrating from GitLab CI/CD to GitHub Actions\n- Migrating from Jenkins to GitHub Actions\n- Migrating from Travis CI to GitHub Actions\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About GitHub Actions?\n\nAssistant: GitHub Actions is a tool that you can use to build automations to assist with each stage of the software development lifecycle. This section describes GitHub Actions concepts, common terminology, and some high level use cases.\n\nHere's a detailed explanation:\n\n\n## Understanding GitHub Actions\nLearn the basics of GitHub Actions, including core concepts and essential terminology.\n\n## About continuous integration with GitHub Actions\nYou can create custom continuous integration (CI) workflows directly in your GitHub repository with GitHub Actions.\n\n## About continuous deployment with GitHub Actions\nYou can create custom continuous deployment (CD) workflows directly in your GitHub repository with GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Avoiding duplication?\n\nAssistant: You can use reusable workflows or composite actions to avoid duplicating the content of workflows.\n\nHere's a detailed explanation:\n\n\n## About reusable workflows and composite actions\nReusable workflows and composite actions are two ways to avoid duplicating the content of workflows.\n\n**Reusable workflows** allow you to reuse an entire workflow, including all of its jobs and steps. This is particularly useful when you have a complete CI/CD process that you want to use across multiple repositories. Reusable workflows can be centrally maintained, in one location, but used in many repositories across your organization.\n\n**Composite actions** allow you to combine multiple steps into a single action. You can then run this bundle of steps as a single step within a workflow. This is useful if you have a sequence of steps that will be used in more than one workflow. Composite actions allow you refactor long YAML workflow files into much smaller files and avoid copying and pasting between workflow files.\n\nReusable workflows and composite actions solve similar problems, but have a few important differences. Most of the time you can use either solution. But some of the time, you’ll need to use one or the other, as described later in this article.\n\nFor details of how to create and use reusable workflows and composite actions, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows) and [Creating a composite action](https://docs.github.com/en/actions/creating-actions/creating-a-composite-action).\n\n## Comparison of reusable workflows and composite actions\n- **Workflow jobs** \\- Composite actions contain a series of steps, that are run as a single step within the caller workflow. Unlike reusable workflows, they cannot contain jobs.\n- **Logging** \\- When a composite action runs, the log will show just the step in the caller workflow that ran the composite action, not the individual steps within the composite action. With reusable workflows, every job and step is logged separately.\n- **Specifying runners** \\- Reusable workflows contain one or more jobs. As with all workflow jobs, the jobs in a reusable workflow specify the type of machine on which the job will run. Therefore, if the steps must be run on a type of machine that might be different from the machine chosen for the calling workflow job, then you should use a reusable workflow, not a composite action.\n- **Passing output to steps** \\- A composite action is run as a step within a workflow job, and you can have multiple steps before or after the step that runs the composite action. Reusable workflows are called directly within a job, and not from within a job step. You can't add steps to a job after calling a reusable workflow, so you can't use `GITHUB_ENV` to pass values to subsequent job steps in the caller workflow.\n\n## Key differences between reusable workflows and composite actions\n| Reusable workflows | Composite actions |\n| --- | --- |\n| A YAML file, very similar to any standard workflow file | An action containing a bundle of workflow steps |\n| Each reusable workflow is a single file in the `.github/workflows` directory of a repository | Each composite action is a separate repository, or a directory, containing an `action.yml` file and, optionally, other files |\n| Called by referencing a specific YAML file | Called by referencing a repository or directory in which the action is defined |\n| Called directly within a job, not from a step | Run as a step within a job |\n| Can contain multiple jobs | Does not contain jobs |\n| Each step is logged in real-time | Logged as one step even if it contains multiple steps |\n| Can connect a maximum of four levels of workflows | Can be nested to have up to 10 composite actions in one workflow |\n| Can use secrets | Cannot use secrets |\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring custom deployment protection rules?\n\nAssistant: Use GitHub Apps to automate protecting deployments with third-party systems.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nCustom deployment protection rules are available in public repositories for all plans. For access to custom deployment protection rules in private or internal repositories, you must use GitHub Enterprise. For more information, see GitHub’s plans.\n\n## About custom deployment protection rules\nCustom deployment protection rules are powered by GitHub Apps. Once a deployment protection rule is configured and installed in a repository, it can be enabled for any environments in the repository.\n\nAfter you enable a custom deployment protection rule on an environment, every time a workflow step targets that environment, the deployment protection rule will run automatically. For more information about targeting an environment for deployments, see Managing environments for deployment.\n\nWhen a custom deployment protection rule is triggered it will wait for up to 30 days for a webhook event response before it times out and the workflow job fails.\n\nFor more information about creating your own custom deployment protection rules, see Creating custom deployment protection rules.\n\nAny number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time.\n\n## Using existing custom deployment protection rules\nYou can choose to create your own custom deployment protection rules or you may use any existing custom deployment protection rules.\n\nThe following is a list of official partner implementations for deployment protection rules.\n\n- Datadog: you can enforce protection rules on your GitHub Actions deployment workflows using Datadog monitors. For more information, see Gating your GitHub Actions Deployments with Datadog Monitors in the Datadog documentation.\n- Honeycomb: you can define thresholds to reject or approve deployments based on data you are sending to Honeycomb. For more information, see the Honeycomb app in the GitHub Marketplace.\n- New Relic: for more information, see the New Relic app in the GitHub Marketplace.\n- NCM NodeSource: for more information, see the NCM NodeSource app in the GitHub Marketplace.\n- Sentry: for more information, see the Sentry Deployment Gate app in the GitHub Marketplace.\n- ServiceNow: for more information, see GitHub integration with DevOps Change Velocity in the ServiceNow documentation.\n\n## Prerequisites\nIn order for a custom deployment protection rule to be available to all environments in a repository, you must first install the custom deployment protection rule on the repository. For more information, see Installing your own GitHub App.\n\nAfter a custom deployment protection rule has been installed in a repository, it must be enabled for each environment where you want the rule to apply.\n\n## Enabling custom deployment protection rules for the environment\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the dropdown menu, then click **Settings**.\n\n3. In the left sidebar, click **Environments**.\n\n4. Select the environment you want to configure.\n\n5. Under \"Deployment protection rules,\" check the box next to each custom deployment protection rule you want to enable for the environment.\n\n6. Click **Save protection rules**.\n\nOnce a custom deployment protection rule has been enabled for an environment, it will automatically run whenever a workflow reaches a job that references the environment. You can see the results of an approval or rejection for your deployment by reviewing the details of the deployment.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring custom deployment protection rules?\n\nAssistant: Here are the recommended best practices:\n\n• Custom deployment protection rules are currently in public preview and subject to change.\n• A maximum of 6 deployment protection rules can be enabled on any environment at the same time.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying PHP to Azure App Service?\n\nAssistant: You can deploy your PHP project to Azure App Service as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a PHP project to Azure App Service.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Azure.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create an Azure App Service plan.\n\nFor example, you can use the Azure CLI to create a new App Service plan:\n\n```hljs bash\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```  \n\nIn the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n\nSee the Azure documentation for more information on using the Azure CLI:\n   - For authentication, see Sign in with Azure CLI.\n   - If you need to create a new resource group, see az group.\n\n2. Create a web app.\n\nFor example, you can use the Azure CLI to create an Azure App Service web app with a PHP runtime:\n\n```hljs bash\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"php|7.4\"\n```  \n\nIn the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n\n3. Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\n\nIn your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\n\n4. Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a PHP project to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created. If the path to your project is not the repository root, change `AZURE_WEBAPP_PACKAGE_PATH` to the path to your project. If you use a version of PHP other than `8.x`, change `PHP_VERSION` to the version that you use.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy PHP app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  PHP_VERSION: '8.x'                  # set this to the PHP version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup PHP\n        uses: shivammathur/setup-php@1f2e3d4c5b6a7f8e9d0c1b2a3e4f5d6c7b8a9e0f\n        with:\n          php-version: ${{ env.PHP_VERSION }}\n\n      - name: Check if composer.json exists\n        id: check_files\n        uses: andstor/file-existence-action@2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b\n        with:\n          files: 'composer.json'\n\n      - name: Get Composer Cache Directory\n        id: composer-cache\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: |\n          echo \"dir=$(composer config cache-files-dir)\" >> $GITHUB_OUTPUT\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        if: steps.check_files.outputs.files_exists == 'true'\n        with:\n          path: ${{ steps.composer-cache.outputs.dir }}\n          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-composer-\n\n      - name: Run composer install if composer.json exists\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: composer validate --no-check-publish && composer install --prefer-dist --no-progress\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: php-app\n          path: .\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: php-app\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: .\n```\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-webapps-php.yml` in the GitHub Actions `starter-workflows` repository.\n- The action used to deploy the web app is the official Azure `Azure/webapps-deploy` action.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying PHP to Azure App Service?\n\nAssistant: Here are some code examples:\n\n### Create an Azure App Service plan\n```yaml\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```\n\n### Create a web app\n```yaml\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"php|7.4\"\n```\n\n### GitHub Actions workflow for PHP app deployment\n```yaml\nname: Build and deploy PHP app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  PHP_VERSION: '8.x'                  # set this to the PHP version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup PHP\n        uses: shivammathur/setup-php@1f2e3d4c5b6a7f8e9d0c1b2a3e4f5d6c7b8a9e0f\n        with:\n          php-version: ${{ env.PHP_VERSION }}\n\n      - name: Check if composer.json exists\n        id: check_files\n        uses: andstor/file-existence-action@2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b\n        with:\n          files: 'composer.json'\n\n      - name: Get Composer Cache Directory\n        id: composer-cache\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: |\n          echo \"dir=$(composer config cache-files-dir)\" >> $GITHUB_OUTPUT\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        if: steps.check_files.outputs.files_exists == 'true'\n        with:\n          path: ${{ steps.composer-cache.outputs.dir }}\n          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-composer-\n\n      - name: Run composer install if composer.json exists\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: composer validate --no-check-publish && composer install --prefer-dist --no-progress\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: php-app\n          path: .\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: php-app\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: .\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying PHP to Azure App Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is GitHub Actions Documentation?\n\nAssistant: Comprehensive guide to GitHub Actions, including workflows, use cases, and best practices.\n\nHere's a detailed explanation:\n\n\n## Start here\nGitHub Actions workflows can automate tasks throughout the software development lifecycle. You can view all guides and examples to get started.\n\n## Popular\nA collection of popular topics including workflow syntax, writing workflows, and use cases.\n\n## What's new\nRecent updates and improvements to GitHub Actions.\n\n## Guides\nA list of guides covering various aspects of GitHub Actions, including using workflow templates and publishing Node.js packages.\n\n## All GitHub Actions docs\nA comprehensive list of all documentation related to GitHub Actions, including about GitHub Actions, writing workflows, managing workflow runs, and more.\n\n## Administering GitHub Actions\nInformation on usage limits, billing, and sharing workflows, secrets, and runners with your organization.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for GitHub Actions Documentation?\n\nAssistant: Here are the recommended best practices:\n\n• Use workflow templates for common tasks.\n• Regularly check the What's New section for updates.\n• Follow best practices for security when using GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Running variations of jobs in a workflow?\n\nAssistant: Create a matrix to define variations for each job.\n\nHere's a detailed explanation:\n\n\n## About matrix strategies\nA matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems.\n\n## Using a matrix strategy\nUse `jobs.<job_id>.strategy.matrix` to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called `version` with the value `[10, 12, 14]` and a variable called `os` with the value `[ubuntu-latest, windows-latest]`:\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]\n```\n\nA job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the `os` and `version` variables.\n\nBy default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:\n\n- `{version: 10, os: ubuntu-latest}`\n- `{version: 10, os: windows-latest}`\n- `{version: 12, os: ubuntu-latest}`\n- `{version: 12, os: windows-latest}`\n- `{version: 14, os: ubuntu-latest}`\n- `{version: 14, os: windows-latest}`\n\nA matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.\n\nThe variables that you define become properties in the `matrix` context, and you can reference the property in other areas of your workflow file. In this example, you can use `matrix.version` and `matrix.os` to access the current value of `version` and `os` that the job is using. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n\n## Example: Using a single-dimension matrix\nYou can specify a single variable to create a single-dimension matrix.\n\nFor example, the following workflow defines the variable `version` with the values `[10, 12, 14]`. The workflow will run three jobs, one for each value in the variable. Each job will access the `version` value through the `matrix.version` context and pass the value as `node-version` to the `actions/setup-node` action.\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n## Example: Using a multi-dimension matrix\nYou can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables.\n\nFor example, the following workflow specifies two variables:\n\n- Two operating systems specified in the `os` variable\n- Three Node.js versions specified in the `version` variable\n\nThe workflow will run six jobs, one for each combination of the `os` and `version` variables. Each job will set the `runs-on` value to the current `os` value and will pass the current `version` value to the `actions/setup-node` action.\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, ubuntu-20.04]\n        version: [10, 12, 14]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n## Example: Using contexts to create matrices\nYou can use contexts to create matrices. For more information about contexts, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts).\n\nFor example, the following workflow triggers on the `repository_dispatch` event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix `version` variable will have a value of `[12, 14, 16]`. For more information about the `repository_dispatch` trigger, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#repository_dispatch).\n\n```hljs json\n{\n  \"event_type\": \"test\",\n  \"client_payload\": {\n    \"versions\": [12, 14, 16]\n  }\n}\n```\n\n```hljs yaml\non:\n  repository_dispatch:\n    types:\n      - test\n\njobs:\n  example_matrix:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        version: ${{ github.event.client_payload.versions }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n## Expanding or adding matrix configurations\nUse `jobs.<job_id>.strategy.matrix.include` to expand existing matrix configurations or to add new configurations. The value of `include` is a list of objects.\n\nFor each object in the `include` list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten.\n\nFor example, this matrix:\n\n```hljs yaml\nstrategy:\n  matrix:\n    fruit: [apple, pear]\n    animal: [cat, dog]\n    include:\n      - color: green\n      - color: pink\n        animal: cat\n      - fruit: apple\n        shape: circle\n      - fruit: banana\n      - fruit: banana\n        animal: cat\n```\n\nwill result in six jobs with the following matrix combinations:\n\n- `{fruit: apple, animal: cat, color: pink, shape: circle}`\n- `{fruit: apple, animal: dog, color: green, shape: circle}`\n- `{fruit: pear, animal: cat, color: pink}`\n- `{fruit: pear, animal: dog, color: green}`\n- `{fruit: banana}`\n- `{fruit: banana, animal: cat}`\n\nfollowing this logic:\n- `{color: green}` is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.\n- `{color: pink, animal: cat}` adds `color:pink` only to the original matrix combinations that include `animal: cat`. This overwrites the `color: green` that was added by the previous `include` entry.\n- `{fruit: apple, shape: circle}` adds `shape: circle` only to the original matrix combinations that include `fruit: apple`.\n- `{fruit: banana}` cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.\n- `{fruit: banana, animal: cat}` cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the `{fruit: banana}` matrix combination because that combination was not one of the original matrix combinations.\n\n## Example: Expanding configurations\nFor example, the following workflow will run four jobs, one for each combination of `os` and `node`. When the job for the `os` value of `windows-latest` and `node` value of `16` runs, an additional variable called `npm` with the value of `6` will be included in the job.\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [windows-latest, ubuntu-latest]\n        node: [14, 16]\n        include:\n          - os: windows-latest\n            node: 16\n            npm: 6\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n      - if: ${{ matrix.npm }}\n        run: npm install -g npm@${{ matrix.npm }}\n      - run: npm --version\n```\n\n## Example: Adding configurations\nFor example, this matrix will run 10 jobs, one for each combination of `os` and `version` in the matrix, plus a job for the `os` value of `windows-latest` and `version` value of `17`.\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest, ubuntu-latest]\n        version: [12, 14, 16]\n        include:\n          - os: windows-latest\n            version: 17\n```\n\n## Excluding matrix configurations\nTo remove specific configurations defined in the matrix, use `jobs.<job_id>.strategy.matrix.exclude`. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches `{os: macos-latest, version: 12, environment: production}`, and the two excluded jobs that match `{os: windows-latest, version: 16}`.\n\n```hljs yaml\nstrategy:\n  matrix:\n    os: [macos-latest, windows-latest]\n    version: [12, 14, 16]\n    environment: [staging, production]\n    exclude:\n      - os: macos-latest\n        version: 12\n        environment: production\n      - os: windows-latest\n        version: 16\nruns-on: ${{ matrix.os }}\n```\n\n## Example: Using an output to define two matrices\nYou can use the output from one job to define matrices for multiple jobs.\n\nFor example, the following workflow demonstrates how to define a matrix of values in one job, use that matrix in a second jobs to produce artifacts, and then consume those artifacts in a third job. Each artifact is associated with a value from the matrix.\n\n```hljs yaml\nname: shared matrix\non:\n  push:\n  workflow_dispatch:\n\njobs:\n  define-matrix:\n    runs-on: ubuntu-latest\n\n    outputs:\n      colors: ${{ steps.colors.outputs.colors }}\n\n    steps:\n      - name: Define Colors\n        id: colors\n        run: |\n          echo 'colors=[\"red\", \"green\", \"blue\"]' >> \"$GITHUB_OUTPUT\"\n\n  produce-artifacts:\n    runs-on: ubuntu-latest\n    needs: define-matrix\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n      - name: Define Color\n        env:\n          color: ${{ matrix.color }}\n        run: |\n          echo \"$color\" > color\n      - name: Produce Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: ${{ matrix.color }}\n          path: color\n\n  consume-artifacts:\n    runs-on: ubuntu-latest\n    needs:\n    - define-matrix\n    - produce-artifacts\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n    - name: Retrieve Artifact\n      uses: actions/download-artifact@v4\n      with:\n        name: ${{ matrix.color }}\n\n    - name: Report Color\n      run: |\n        cat color\n```\n\n## Handling failures\nYou can control how job failures are handled with `jobs.<job_id>.strategy.fail-fast` and `jobs.<job_id>.continue-on-error`.\n\n`jobs.<job_id>.strategy.fail-fast` applies to the entire matrix. If `jobs.<job_id>.strategy.fail-fast` is set to `true` or its expression evaluates to `true`, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to `true`.\n\n`jobs.<job_id>.continue-on-error` applies to a single job. If `jobs.<job_id>.continue-on-error` is `true`, other jobs in the matrix will continue running even if the job with `jobs.<job_id>.continue-on-error: true` fails.\n\nYou can use `jobs.<job_id>.strategy.fail-fast` and `jobs.<job_id>.continue-on-error` together. For example, the following workflow will start four jobs. For each job, `continue-on-error` is determined by the value of `matrix.experimental`. If any of the jobs with `continue-on-error: false` fail, all jobs that are in progress or queued will be cancelled. If the job with `continue-on-error: true` fails, the other jobs will not be affected.\n\n```hljs yaml\njobs:\n  test:\n    runs-on: ubuntu-latest\n    continue-on-error: ${{ matrix.experimental }}\n    strategy:\n      fail-fast: true\n      matrix:\n        version: [6, 7, 8]\n        experimental: [false]\n        include:\n          - version: 9\n            experimental: true\n```\n\n## Defining the maximum number of concurrent jobs\nBy default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a `matrix` job strategy, use `jobs.<job_id>.strategy.max-parallel`.\n\nFor example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.\n\n```hljs yaml\njobs:\n  example_matrix:\n    strategy:\n      max-parallel: 2\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Running variations of jobs in a workflow?\n\nAssistant: Here are some code examples:\n\n### Using a matrix strategy\n```yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]\n```\n\n### Using a single-dimension matrix\n```yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n### Using a multi-dimension matrix\n```yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, ubuntu-20.04]\n        version: [10, 12, 14]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n### Using contexts to create matrices\n```yaml\non:\n  repository_dispatch:\n    types:\n      - test\n\njobs:\n  example_matrix:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        version: ${{ github.event.client_payload.versions }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}\n```\n\n### Expanding configurations\n```yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [windows-latest, ubuntu-latest]\n        node: [14, 16]\n        include:\n          - os: windows-latest\n            node: 16\n            npm: 6\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n      - if: ${{ matrix.npm }}\n        run: npm install -g npm@${{ matrix.npm }}\n      - run: npm --version\n```\n\n### Adding configurations\n```yaml\njobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest, ubuntu-latest]\n        version: [12, 14, 16]\n        include:\n          - os: windows-latest\n            version: 17\n```\n\n### Using an output to define two matrices\n```yaml\nname: shared matrix\non:\n  push:\n  workflow_dispatch:\n\njobs:\n  define-matrix:\n    runs-on: ubuntu-latest\n\n    outputs:\n      colors: ${{ steps.colors.outputs.colors }}\n\n    steps:\n      - name: Define Colors\n        id: colors\n        run: |\n          echo 'colors=[\"red\", \"green\", \"blue\"]' >> \"$GITHUB_OUTPUT\"\n\n  produce-artifacts:\n    runs-on: ubuntu-latest\n    needs: define-matrix\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n      - name: Define Color\n        env:\n          color: ${{ matrix.color }}\n        run: |\n          echo \"$color\" > color\n      - name: Produce Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: ${{ matrix.color }}\n          path: color\n\n  consume-artifacts:\n    runs-on: ubuntu-latest\n    needs:\n    - define-matrix\n    - produce-artifacts\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n    - name: Retrieve Artifact\n      uses: actions/download-artifact@v4\n      with:\n        name: ${{ matrix.color }}\n\n    - name: Report Color\n      run: |\n        cat color\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Running variations of jobs in a workflow?\n\nAssistant: Here are the recommended best practices:\n\n• A matrix will generate a maximum of 256 jobs per workflow run.\n• The order of the variables in the matrix determines the order in which the jobs are created.\n• You can use `jobs.<job_id>.strategy.fail-fast` to cancel all in-progress and queued jobs if any job in the matrix fails.\n• To set the maximum number of jobs that can run simultaneously, use `jobs.<job_id>.strategy.max-parallel`.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Control the concurrency of workflows and jobs?\n\nAssistant: Run a single job at a time.\n\nHere's a detailed explanation:\n\n\n## Overview\nBy default, GitHub Actions allows multiple jobs within the same workflow, multiple workflow runs within the same repository, and multiple workflow runs across a repository owner's account to run concurrently. This means that multiple instances of the same workflow or job can run at the same time, performing the same steps.\n\nGitHub Actions also allows you to disable concurrent execution. This can be useful for controlling your account’s or organization’s resources in situations where running multiple workflows or jobs at the same time could cause conflicts or consume more Actions minutes and storage than expected.\n\nFor example, the ability to run workflows concurrently means that if multiple commits are pushed to a repository in quick succession, each push could trigger a separate workflow run, and these runs will execute concurrently.\n\n## Using concurrency in different scenarios\nYou can use `jobs.<job_id>.concurrency` to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context), [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context), [`needs`](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context), [`strategy`](https://docs.github.com/en/actions/learn-github-actions/contexts#strategy-context), and [`matrix`](https://docs.github.com/en/actions/learn-github-actions/contexts#matrix-context). For more information about expressions, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).\n\nYou can also specify `concurrency` at the workflow level. For more information, see [`concurrency`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#concurrency).\n\nThis means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be `pending`. Any existing `pending` job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.\n\nTo also cancel any currently running job or workflow in the same concurrency group, specify `cancel-in-progress: true`. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify `cancel-in-progress` as an expression with any of the allowed expression contexts.\n\nNote\n- The concurrency group name is case insensitive. For example, `prod` and `Prod` will be treated as the same concurrency group.\n- Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.\n\n## Example: Using concurrency and the default behavior\nThe default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The `concurrency` keyword allows you to control the concurrency of workflow runs.\n\nFor example, you can use the `concurrency` keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:\n\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n```\n\nYou can also limit the concurrency of jobs within a workflow by using the `concurrency` keyword at the job level:\n\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: example-group\n      cancel-in-progress: true\n```\n\n## Example: Concurrency groups\nConcurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.\n\nThe `concurrency` key is used to group workflows or jobs together into a concurrency group. When you define a `concurrency` key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same `concurrency` key, GitHub Actions will cancel any workflow or job already running with that key. The `concurrency` key can be a hard-coded string, or it can be a dynamic expression that includes context variables.\n\nIt is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.\n\nThis means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.\n\nIn this example, `job-1` is part of a concurrency group named `staging_environment`. This means that if a new run of `job-1` is triggered, any runs of the same job in the `staging_environment` concurrency group that are already in progress will be cancelled.\n\n```hljs yaml\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: staging_environment\n      cancel-in-progress: true\n```\n\nAlternatively, using a dynamic expression such as `concurrency: ci-${{ github.ref }}` in your workflow means that the workflow or job would be part of a concurrency group named `ci-` followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:\n\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true\n```\n\n## Example: Using concurrency to cancel any in-progress job or run\nTo use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the `concurrency` key with the `cancel-in-progress` option set to `true`:\n\n```hljs yaml\nconcurrency:\n  group: ${{ github.ref }}\n  cancel-in-progress: true\n```\n\nNote that in this example, without defining a particular concurrency group, GitHub Actions will cancel _any_ in-progress run of the job or workflow.\n\n## Example: Using a fallback value\nIf you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, `github.head_ref` is only defined on `pull_request` events. If your workflow responds to other events in addition to `pull_request` events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on `pull_request` events only; if `github.head_ref` is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.\n\n```hljs yaml\nconcurrency:\n  group: ${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true\n```\n\n## Example: Only cancel in-progress jobs or runs for the current workflow\nIf you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.\n\nTo only cancel in-progress runs of the same workflow, you can use the `github.workflow` property to build the concurrency group:\n\n```hljs yaml\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n```\n\n## Example: Only cancel in-progress jobs on specific branches\nIf you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with `cancel-in-progress`. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.\n\nTo only cancel in-progress runs of the same workflow when not running on a release branch, you can set `cancel-in-progress` to an expression similar to the following:\n\n```hljs yaml\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}\n```\n\n## Monitoring your current jobs in your organization or enterprise\nTo identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, see [Monitoring your current jobs](https://docs.github.com/en/actions/using-github-hosted-runners/monitoring-your-current-jobs).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Control the concurrency of workflows and jobs?\n\nAssistant: Here are some code examples:\n\n### Using concurrency and the default behavior\n```yaml\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n```\n```\n\n### Limit concurrency of jobs within a workflow\n```yaml\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: example-group\n      cancel-in-progress: true\n```\n```\n\n### Concurrency groups example\n```yaml\n```hljs yaml\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: staging_environment\n      cancel-in-progress: true\n```\n```\n\n### Dynamic concurrency group example\n```yaml\n```hljs yaml\non:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true\n```\n```\n\n### Cancel any in-progress job or run\n```yaml\n```hljs yaml\nconcurrency:\n  group: ${{ github.ref }}\n  cancel-in-progress: true\n```\n```\n\n### Using a fallback value\n```yaml\n```hljs yaml\nconcurrency:\n  group: ${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true\n```\n```\n\n### Cancel in-progress jobs for the current workflow\n```yaml\n```hljs yaml\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true\n```\n```\n\n### Cancel in-progress jobs on specific branches\n```yaml\n```hljs yaml\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Control the concurrency of workflows and jobs?\n\nAssistant: Here are the recommended best practices:\n\n• The concurrency group name is case insensitive. For example, `prod` and `Prod` will be treated as the same concurrency group.\n• Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Running scripts before or after a job?\n\nAssistant: Scripts can automatically execute on a self-hosted runner, directly before or after a job.\n\nHere's a detailed explanation:\n\n\n## About pre- and post-job scripts\nYou can automatically execute scripts on a self-hosted runner, either before a job runs, or after a job finishes running. You could use these scripts to support the job's requirements, such as building or tearing down a runner environment, or cleaning out directories. You could also use these scripts to track telemetry of how your runners are used.\n\nThe custom scripts are automatically triggered when a specific environment variable is set on the runner; the environment variable must contain the absolute path to the script. For more information, see Triggering the scripts below.\n\nThe following scripting languages are supported:\n\n- **Bash:** Uses `bash` and can fallback to `sh`. Executes by running `-e {pathtofile}`.\n- **PowerShell:** Uses `pwsh` and can fallback to `powershell`. Executes by running `-command \". '{pathtofile}'\".\n\n## Writing the scripts\nYour custom scripts can use the following features:\n\n- **Variables:** Scripts have access to the default variables. The full webhook event payload can be found in `GITHUB_EVENT_PATH`. For more information, see Store information in variables.\n- **Workflow commands:** Scripts can use workflow commands. For more information, see Workflow commands for GitHub Actions. Scripts can also use environment files. For more information, see Environment files.\n\nYour script files must use a file extension for the relevant language, such as `.sh` or `.ps1`, in order to run successfully.\n\nNote\n\nAvoid using your scripts to output sensitive information to the console, as anyone with read access to the repository might be able to see the output in the UI logs.\n\n## Handling exit codes\nFor pre-job scripts, exit code `0` indicates that the script completed successfully, and the job will then proceed to run. If there is any other exit code, the job will not run and will be marked as failed. To see the results of your pre-job scripts, check the logs for `Set up runner` entries. For more information on checking the logs, see Using workflow run logs.\n\nThe `continue-on-error` setting is not supported for use by these scripts.\n\n## Triggering the scripts\nThe custom scripts must be located on the runner, but should not be stored in the `actions-runner` application directory. The scripts are executed in the security context of the service account that's running the runner service.\n\nNote\n\nThe triggered scripts are processed synchronously, so they will block job execution while they are running.\n\nThe scripts are automatically executed when the runner has the following environment variables containing an absolute path to the script:\n\n- `ACTIONS_RUNNER_HOOK_JOB_STARTED`: The script defined in this environment variable is triggered when a job has been assigned to a runner, but before the job starts running.\n- `ACTIONS_RUNNER_HOOK_JOB_COMPLETED`: The script defined in this environment variable is triggered at the end of the job, after all the steps defined in the workflow have run.\n\nTo set these environment variables, you can either add them to the operating system, or add them to a file named `.env` within the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). Note that any change to the `.env` file will require restarting the runner.\nFor example, the following `.env` entry will have the runner automatically run a script, saved as `/opt/runner/cleanup_script.sh` on the runner machine, before each job runs:\n\n```bash\nACTIONS_RUNNER_HOOK_JOB_STARTED=/opt/runner/cleanup_script.sh\n```\n\nNote\n\nThe script defined in `ACTIONS_RUNNER_HOOK_JOB_COMPLETED` is executed at the end of the job, before the job completes. This makes it unsuitable for use cases that may interrupt a runner, such as deleting the runner machine as part of an autoscaling implementation.\n\n## Troubleshooting\n### Permission denied\nIf you get a \"permission denied\" error when you attempt to run a script, make sure that the script is executable. For example, in a terminal on Linux or macOS you can use the following command to make a file executable.\n\n```bash\nchmod +x PATH/TO/FILE\n```\n\nFor information about using workflows to run scripts, see Adding scripts to your workflow.\n\n### No timeout setting\nThere is currently no timeout setting available for scripts executed by `ACTIONS_RUNNER_HOOK_JOB_STARTED` or `ACTIONS_RUNNER_HOOK_JOB_COMPLETED`. As a result, you could consider adding timeout handling to your script.\n\n### Reviewing the workflow run log\nTo confirm whether your scripts are executing, you can review the logs for that job. The scripts will be listed within separate steps for either `Set up runner` or `Complete runner`, depending on which environment variable is triggering the script. For more information on checking the logs, see Using workflow run logs.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Running scripts before or after a job?\n\nAssistant: Here are some code examples:\n\n### Setting up a pre-job script\n```yaml\nACTIONS_RUNNER_HOOK_JOB_STARTED=/opt/runner/cleanup_script.sh\n```\n\n### Making a script executable\n```yaml\nchmod +x PATH/TO/FILE\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Running scripts before or after a job?\n\nAssistant: Here are the recommended best practices:\n\n• Avoid using your scripts to output sensitive information to the console, as anyone with read access to the repository might be able to see the output in the UI logs.\n• The triggered scripts are processed synchronously, so they will block job execution while they are running.\n• The script defined in ACTIONS_RUNNER_HOOK_JOB_COMPLETED is executed at the end of the job, before the job completes. This makes it unsuitable for use cases that may interrupt a runner, such as deleting the runner machine as part of an autoscaling implementation.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Passing information between jobs?\n\nAssistant: You can define outputs to pass information from one job to another.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can use `jobs.<job_id>.outputs` to create a `map` of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds).\n\nOutputs are Unicode strings, and can be a maximum of 1 MB. The total of all outputs in a workflow run can be a maximum of 50 MB.\n\nJob outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions.\n\nIf an output is skipped because it may contain a secret, you will see the following warning message: \"Skip output `{output.Key}` since it may contain secret.\" For more information on how to handle secrets, please refer to the [Example: Masking and passing a secret between jobs or workflows](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#example-masking-and-passing-a-secret-between-jobs-or-workflows).\n\nTo use job outputs in a dependent job, you can use the `needs` context. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Passing information between jobs?\n\nAssistant: Here are some code examples:\n\n### Example: Defining outputs for a job\n```yaml\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    # Map a step output to a job output\n    outputs:\n      output1: ${{ steps.step1.outputs.test }}\n      output2: ${{ steps.step2.outputs.test }}\n    steps:\n      - id: step1\n        run: echo \"test=hello\" >> \"$GITHUB_OUTPUT\"\n      - id: step2\n        run: echo \"test=world\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: job1\n    steps:\n      - env:\n          OUTPUT1: ${{needs.job1.outputs.output1}}\n          OUTPUT2: ${{needs.job1.outputs.output2}}\n        run: echo \"$OUTPUT1 $OUTPUT2\"\n```\n\n### Using Job Outputs in a Matrix Job\n```yaml\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      output_1: ${{ steps.gen_output.outputs.output_1 }}\n      output_2: ${{ steps.gen_output.outputs.output_2 }}\n      output_3: ${{ steps.gen_output.outputs.output_3 }}\n    strategy:\n      matrix:\n        version: [1, 2, 3]\n    steps:\n      - name: Generate output\n        id: gen_output\n        run: |\n          version=\"${{ matrix.version }}\"\n          echo \"output_${version}=${version}\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: [job1]\n    steps:\n      # Will show\n      # {\n      #   \"output_1\": \"1\",\n      #   \"output_2\": \"2\",\n      #   \"output_3\": \"3\"\n      # }\n      - run: echo '${{ toJSON(needs.job1.outputs) }}'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Passing information between jobs?\n\nAssistant: Here are the recommended best practices:\n\n• Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in Amazon Web Services?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with Amazon Web Services.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Amazon Web Services (AWS), without needing to store the AWS credentials as long-lived GitHub secrets.\n\nThis guide explains how to configure AWS to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`aws-actions/configure-aws-credentials`](https://github.com/aws-actions/configure-aws-credentials) that uses tokens to authenticate to AWS and access resources.\n\nNote\n\nSupport for custom claims for OIDC is unavailable in AWS.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\n## Adding the identity provider to AWS\nTo add the GitHub OIDC provider to IAM, see the [AWS documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html).\n\n- For the provider URL: Use `https://token.actions.githubusercontent.com`\n- For the \"Audience\": Use `sts.amazonaws.com` if you are using the [official action](https://github.com/aws-actions/configure-aws-credentials).\n\n## Configuring the role and trust policy\nTo configure the role and trust in IAM, see the AWS documentation [Configure AWS Credentials for GitHub Actions](https://github.com/aws-actions/configure-aws-credentials#configure-aws-credentials-for-github-actions) and [Configuring a role for GitHub OIDC identity provider](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp_oidc.html#idp_oidc_Create_GitHub).\n\nNote\n\nAWS Identity and Access Management (IAM) recommends that users evaluate the IAM condition key, `token.actions.githubusercontent.com:sub`, in the trust policy of any role that trusts GitHub’s OIDC identity provider (IdP). Evaluating this condition key in the role trust policy limits which GitHub actions are able to assume the role.\n\nEdit the trust policy, adding the `sub` field to the validation conditions. For example:\n\n```hljs json\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/octo-branch\"\n  }\n}\n```\n\nIf you use a workflow with an environment, the `sub` field must reference the environment name: `repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#understanding-the-oidc-token).\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n```hljs json\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:environment:prod\"\n  }\n}\n```\n\nIn the following example, `StringLike` is used with a wildcard operator ( `*`) to allow any branch, pull request merge branch, or environment from the `octo-org/octo-repo` organization and repository to assume a role in AWS.\n\n```hljs json\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\\\n        {\\\n            \"Effect\": \"Allow\",\\\n            \"Principal\": {\\\n                \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\"\\\n            },\\\n            \"Action\": \"sts:AssumeRoleWithWebIdentity\",\\\n            \"Condition\": {\\\n                \"StringLike\": {\\\n                    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\"\\\n                },\\\n                \"StringEquals\": {\\\n                    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\"\\\n                }\\\n            }\\\n        }\\\n    ]\n}\n```\n\n## Updating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1. Add permissions settings for the token.\n2. Use the [`aws-actions/configure-aws-credentials`](https://github.com/aws-actions/configure-aws-credentials) action to exchange the OIDC token (JWT) for a cloud access token.\n\n## Adding permissions settings\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n- Using environment variables on the runner ( `ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n- Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Requesting the access token\nThe `aws-actions/configure-aws-credentials` action receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWS [documentation](https://github.com/aws-actions/configure-aws-credentials).\n\n- `BUCKET-NAME`: Replace this with the name of your S3 bucket.\n- `AWS-REGION`: Replace this with the name of your AWS region.\n- `ROLE-TO-ASSUME`: Replace this with your AWS role. For example, `arn:aws:iam::1234567890:role/example-role`\n\n```hljs yaml\n# Sample workflow to access AWS resources when workflow is tied to branch\n# The workflow Creates static website using aws s3\nname: AWS example workflow\non:\n  push\nenv:\n  BUCKET_NAME : \"BUCKET-NAME\"\n  AWS_REGION : \"AWS-REGION\"\n# permission can be added at job level or workflow level\npermissions:\n  id-token: write   # This is required for requesting the JWT\n  contents: read    # This is required for actions/checkout\njobs:\n  S3PackageUpload:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git clone the repository\n        uses: actions/checkout@v4\n      - name: configure aws credentials\n        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502\n        with:\n          role-to-assume: ROLE-TO-ASSUME\n          role-session-name: samplerolesession\n          aws-region: ${{ env.AWS_REGION }}\n      # Upload a file to AWS s3\n      - name: Copy index.html to s3\n        run: |\n          aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/\n``\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in Amazon Web Services?\n\nAssistant: Here are some code examples:\n\n### Trust Policy Example\n```yaml\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/octo-branch\"\n  }\n}\n```\n\n### Trust Policy with Environment Example\n```yaml\n\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:environment:prod\"\n  }\n}\n```\n\n### Role Trust Policy Example\n```yaml\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\\\n        {\\\n            \"Effect\": \"Allow\",\\\n            \"Principal\": {\\\n                \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\"\\\n            },\\\n            \"Action\": \"sts:AssumeRoleWithWebIdentity\",\\\n            \"Condition\": {\\\n                \"StringLike\": {\\\n                    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\"\\\n                },\\\n                \"StringEquals\": {\\\n                    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\"\\\n                }\\\n            }\\\n        }\\\n    ]\n}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in Amazon Web Services?\n\nAssistant: Here are the recommended best practices:\n\n• Support for custom claims for OIDC is unavailable in AWS.\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security.\n• You may need to specify additional permissions here, depending on your workflow's requirements.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using Copilot to troubleshoot workflows?\n\nAssistant: You can use GitHub Copilot to help resolve failed workflow runs.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nThis feature is available for users on all GitHub Copilot subscription tiers.\n\nIf a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error.\n\nTo open a chat about a failed workflow run, you can either:\n\n- Next to the failed check in the merge box, click , then click **Explain error**.\n- In the merge box, click on the failed check. At the top of the workflow run summary page, click **Explain error**.\n\nThis opens a chat window with GitHub Copilot, where it will provide instructions to resolve the issue.\n\nNote\n\nIf you are on a GitHub Copilot Free subscription, this will count towards your monthly chat message limit.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying to Azure Kubernetes Service?\n\nAssistant: You can deploy your project to Azure Kubernetes Service (AKS) as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a project to Azure Kubernetes Service.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create a target AKS cluster and an Azure Container Registry (ACR). For more information, see Quickstart: Deploy an AKS cluster by using the Azure portal - Azure Kubernetes Service and Quickstart - Create registry in portal - Azure Container Registry in the Azure documentation.\n\n2. Create a secret called `AZURE_CREDENTIALS` to store your Azure credentials. For more information about how to find this information and structure the secret, see the `Azure/login` action documentation.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a project to Azure Kubernetes Service when code is pushed to your repository.\n\nUnder the workflow `env` key, change the following values:\n\n- `AZURE_CONTAINER_REGISTRY` to the name of your container registry\n- `PROJECT_NAME` to the name of your project\n- `RESOURCE_GROUP` to the resource group containing your AKS cluster\n- `CLUSTER_NAME` to the name of your AKS cluster\n\nThis workflow uses the `helm` render engine for the `azure/k8s-bake` action. If you will use the `helm` render engine, change the value of `CHART_PATH` to the path to your helm file. Change `CHART_OVERRIDE_PATH` to an array of override file paths. If you use a different render engine, update the input parameters sent to the `azure/k8s-bake` action.\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-kubernetes-service.yml` in the GitHub Actions `starter-workflows` repository.\n- The actions used to in this workflow are the official Azure `Azure/login`, `Azure/aks-set-context`, `Azure/CLI`, `Azure/k8s-bake`, and `Azure/k8s-deploy` actions.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying to Azure Kubernetes Service?\n\nAssistant: Here are some code examples:\n\n### Build and deploy to Azure Kubernetes Service\n```yaml\nname: Build and deploy to Azure Kubernetes Service\n\nenv:\n  AZURE_CONTAINER_REGISTRY: MY_REGISTRY_NAME # set this to the name of your container registry\n  PROJECT_NAME: MY_PROJECT_NAME              # set this to your project's name\n  RESOURCE_GROUP: MY_RESOURCE_GROUP          # set this to the resource group containing your AKS cluster\n  CLUSTER_NAME: MY_CLUSTER_NAME              # set this to the name of your AKS cluster\n  REGISTRY_URL: MY_REGISTRY_URL              # set this to the URL of your registry\n  # If you bake using helm:\n  CHART_PATH: MY_HELM_FILE                   # set this to the path to your helm file\n  CHART_OVERRIDE_PATH: MY_OVERRIDE_FILES     # set this to an array of override file paths\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Azure Login\n      uses: azure/login@14a755a4e2fd6dff25794233def4f2cf3f866955\n      with:\n        creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n    - name: Build image on ACR\n      uses: azure/CLI@61bb69d64d613b52663984bf12d6bac8fd7b3cc8\n      with:\n        azcliversion: 2.29.1\n        inlineScript: |\n          az configure --defaults acr=${{ env.AZURE_CONTAINER_REGISTRY }}\n          az acr build -t -t ${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}:${{ github.sha }}\n\n    - name: Gets K8s context\n      uses: azure/aks-set-context@94ccc775c1997a3fcfbfbce3c459fec87e0ab188\n      with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n          resource-group: ${{ env.RESOURCE_GROUP }}\n          cluster-name: ${{ env.CLUSTER_NAME }}\n      id: login\n\n    - name: Configure deployment\n      uses: azure/k8s-bake@61041e8c2f75c1f01186c8f05fb8b24e1fc507d8\n      with:\n        renderEngine: 'helm'\n        helmChart: ${{ env.CHART_PATH }}\n        overrideFiles: ${{ env.CHART_OVERRIDE_PATH }}\n        overrides: |\n          replicas:2\n        helm-version: 'latest'\n      id: bake\n\n    - name: Deploys application\n      uses: Azure/k8s-deploy@dd4bbd13a5abd2fc9ca8bdcb8aee152bb718fa78\n      with:\n        manifests: ${{ steps.bake.outputs.manifestsBundle }}\n        images: |\n          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.PROJECT_NAME }}:${{ github.sha }}\n        imagepullsecrets: |\n          ${{ env.PROJECT_NAME }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying to Azure Kubernetes Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider.\n• GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Publishing Docker images?\n\nAssistant: You can publish Docker images to a registry, such as Docker Hub or GitHub Packages, as part of your continuous integration (CI) workflow.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that performs a Docker build, and then publishes Docker images to Docker Hub or GitHub Packages. With a single workflow, you can publish images to a single registry or to multiple registries.\n\nNote\n\nIf you want to push to another third-party Docker registry, the example in the Publishing images to GitHub Packages section can serve as a good template.\n\n## Prerequisites\nWe recommend that you have a basic understanding of workflow configuration options and how to create a workflow file. For more information, see Writing workflows.\n\nYou might also find it helpful to have a basic understanding of the following:\n\n- Using secrets in GitHub Actions\n- Automatic token authentication\n- Working with the Container registry\n\n## About image configuration\nThis guide assumes that you have a complete definition for a Docker image stored in a GitHub repository. For example, your repository must contain a Dockerfile, and any other files needed to perform a Docker build to create an image.\n\nYou can use pre-defined annotation keys to add metadata including a description, a license, and a source repository to your container image. For more information, see Working with the Container registry.\n\nIn this guide, we will use the Docker build-push-action action to build the Docker image and push it to one or more Docker registries. For more information, see build-push-action.\n\n## Publishing images to Docker Hub\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when the release event triggers with the published activity type.\n\nIn the example workflow below, we use the Docker login-action and build-push-action actions to build the Docker image and, if the build succeeds, push the built image to Docker Hub.\n\nTo push to Docker Hub, you will need to have a Docker Hub account, and have a Docker Hub repository created. For more information, see Pushing a Docker container image to Docker Hub in the Docker documentation.\n\nThe login-action options required for Docker Hub are:\n\n- username and password: This is your Docker Hub username and password. We recommend storing your Docker Hub username and password as secrets so they aren't exposed in your workflow file. For more information, see Using secrets in GitHub Actions.\n\nThe metadata-action option required for Docker Hub is:\n\n- images: The namespace and name for the Docker image you are building/pushing to Docker Hub.\n\nThe build-push-action options required for Docker Hub are:\n\n- tags: The tag of your new image in the format DOCKER-HUB-NAMESPACE/DOCKER-HUB-REPOSITORY:VERSION. You can set a single tag as shown below, or specify multiple tags in a list.\n\n## Publishing images to GitHub Packages\nEach time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to the release branch.\n\nIn the example workflow below, we use the Docker login-action, metadata-action, and build-push-action actions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages.\n\nThe login-action options required for GitHub Packages are:\n\n- registry: Must be set to ghcr.io.\n- username: You can use the ${ github.actor } context to automatically use the username of the user that triggered the workflow run. For more information, see Accessing contextual information about workflow runs.\n- password: You can use the automatically-generated GITHUB_TOKEN secret for the password. For more information, see Automatic token authentication.\n\nThe metadata-action option required for GitHub Packages is:\n\n- images: The namespace and name for the Docker image you are building.\n\nThe build-push-action options required for GitHub Packages are:\n\n- context: Defines the build's context as the set of files located in the specified path.\n- push: If set to true, the image will be pushed to the registry if it is built successfully.\n- tags and labels: These are populated by output from metadata-action.\n\n## Publishing images to Docker Hub and GitHub Packages\nIn a single workflow, you can publish your Docker image to multiple registries by using the login-action and build-push-action actions for each registry.\n\nThe following example workflow uses the steps from the previous sections to create a single workflow that pushes to both registries.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Publishing Docker images?\n\nAssistant: Here are some code examples:\n\n### Publish Docker image\n```yaml\nname: Publish Docker image\n\non:\n  release:\n    types: [published]\n\njobs:\n  push_to_registry:\n    name: Push Docker image to Docker Hub\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: my-docker-hub-namespace/my-docker-hub-repository\n\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: index.docker.io/my-docker-hub-namespace/my-docker-hub-repository\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Publishing Docker images?\n\nAssistant: Here are the recommended best practices:\n\n• If you want to push to another third-party Docker registry, the example in the Publishing images to GitHub Packages section can serve as a good template.\n• We recommend that you have a basic understanding of workflow configuration options and how to create a workflow file.\n• You might also find it helpful to have a basic understanding of using secrets in GitHub Actions, automatic token authentication, and working with the Container registry.\n• GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Setting a default shell and working directory?\n\nAssistant: Define the default settings that will apply to all jobs in the workflow, or all steps in a job.\n\nHere's a detailed explanation:\n\n\n## Overview\nUse `defaults` to create a `map` of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, see [`jobs.<job_id>.defaults`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaults).\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\n## Setting default shell and working directory\nYou can use `defaults.run` to provide default `shell` and `working-directory` options for all [`run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun) steps in a workflow. You can also set default settings for `run` that are only available to a job. For more information, see [`jobs.<job_id>.defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrun). You cannot use contexts or expressions in this keyword.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\n## Example: Set the default shell and working directory\n```hljs yaml\ndefaults:\n  run:\n    shell: bash\n    working-directory: ./scripts\n```\n\n## Setting default values for a specific job\nUse `jobs.<job_id>.defaults` to create a `map` of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, see [`defaults`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaults).\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\n## Setting default shell and working directory for a job\nUse `jobs.<job_id>.defaults.run` to provide default `shell` and `working-directory` to all `run` steps in the job.\n\nYou can provide default `shell` and `working-directory` options for all [`run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun) steps in a job. You can also set default settings for `run` for the entire workflow. For more information, see [`defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaultsrun).\n\nThese can be overriden at the `jobs.<job_id>.defaults.run` and `jobs.<job_id>.steps[*].run` levels.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\n## Example: Setting default `run` step options for a job\n```hljs yaml\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash\n        working-directory: ./scripts\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Setting a default shell and working directory?\n\nAssistant: Here are some code examples:\n\n### Example: Set the default shell and working directory\n```yaml\n```hljs yaml\ndefaults:\n  run:\n    shell: bash\n    working-directory: ./scripts\n```\n```\n\n### Example: Setting default `run` step options for a job\n```yaml\n```hljs yaml\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash\n        working-directory: ./scripts\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Setting a default shell and working directory?\n\nAssistant: Here are the recommended best practices:\n\n• When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Manually migrating to GitHub Actions?\n\nAssistant: Learn how to manually migrate your existing CI/CD workflows to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Migrating from Azure Pipelines to GitHub Actions\nGitHub Actions and Azure Pipelines share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\n## Migrating from CircleCI to GitHub Actions\nGitHub Actions and CircleCI share several similarities in configuration, which makes migration to GitHub Actions relatively straightforward.\n\n## Migrating from GitLab CI/CD to GitHub Actions\nGitHub Actions and GitLab CI/CD share several configuration similarities, which makes migrating to GitHub Actions relatively straightforward.\n\n## Migrating from Jenkins to GitHub Actions\nGitHub Actions and Jenkins share multiple similarities, which makes migration to GitHub Actions relatively straightforward.\n\n## Migrating from Travis CI to GitHub Actions\nGitHub Actions and Travis CI share multiple similarities, which helps make it relatively straightforward to migrate to GitHub Actions.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Commenting on an issue when a label is added?\n\nAssistant: You can use GitHub Actions to automatically comment on issues when a specific label is applied.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis tutorial demonstrates how to use the GitHub CLI to comment on an issue when a specific label is applied. For example, when the `help wanted` label is added to an issue, you can add a comment to encourage contributors to work on the issue. For more information about GitHub CLI, see [Using GitHub CLI in workflows](https://docs.github.com/en/actions/using-workflows/using-github-cli-in-workflows). In the tutorial, you will first make a workflow file that uses the `gh issue comment` command to comment on an issue. Then, you will customize the workflow to suit your needs.\n\n## Creating the workflow\n1. Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, see [Creating a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository).\n\n2. In your repository, create a file called `.github/workflows/YOUR_WORKFLOW.yml`, replacing `YOUR_WORKFLOW` with a name of your choice. This is a workflow file. For more information about creating new files on GitHub, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n3. Copy the following YAML contents into your workflow file.\n\n```hljs yaml\nname: Add comment\non:\n     issues:\n       types:\n      - labeled\njobs:\nadd-comment:\n    if: github.event.label.name == 'help wanted'\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Add comment\n        run: gh issue comment \"$NUMBER\" --body \"$BODY\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          BODY: >\n            This issue is available for anyone to work on.\n            **Make sure to reference this issue in your pull request.**\n            :sparkles: Thank you for your contribution! :sparkles:\n```\n\n4. Customize the parameters in your workflow file:\n   - Replace `help wanted` in `if: github.event.label.name == 'help wanted'` with the label that you want to act on. If you want to act on more than one label, separate the conditions with `||`. For example, `if: github.event.label.name == 'bug' || github.event.label.name == 'fix me'` will comment whenever the `bug` or `fix me` labels are added to an issue.\n   - Change the value for `BODY` to the comment that you want to add. GitHub flavored markdown is supported. For more information about markdown, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax).\n5. Commit your workflow file to the default branch of your repository. For more information, see [Creating new files](https://docs.github.com/en/repositories/working-with-files/managing-files/creating-new-files).\n\n## Testing the workflow\nEvery time an issue in your repository is labeled, this workflow will run. If the label that was added is one of the labels that you specified in your workflow file, the `gh issue comment` command will add the comment that you specified to the issue.\n\nTest your workflow by applying your specified label to an issue.\n\n1. Open an issue in your repository. For more information, see [Creating an issue](https://docs.github.com/en/issues/tracking-your-work-with-issues/creating-an-issue).\n2. Label the issue with the specified label in your workflow file. For more information, see [Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels#applying-labels-to-issues-and-pull-requests).\n3. To see the workflow run triggered by labeling the issue, view the history of your workflow runs. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).\n4. When the workflow completes, the issue that you labeled should have a comment added.\n\n## Next steps\n- To learn more about additional things you can do with the GitHub CLI, like editing existing comments, visit the [GitHub CLI Manual](https://cli.github.com/manual/).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Commenting on an issue when a label is added?\n\nAssistant: Here are some code examples:\n\n### Add comment workflow example\n```yaml\nname: Add comment\non:\n     issues:\n       types:\n      - labeled\njobs:\nadd-comment:\n    if: github.event.label.name == 'help wanted'\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Add comment\n        run: gh issue comment \"$NUMBER\" --body \"$BODY\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          BODY: >\n            This issue is available for anyone to work on.\n            **Make sure to reference this issue in your pull request.**\n            :sparkles: Thank you for your contribution! :sparkles:\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Commenting on an issue when a label is added?\n\nAssistant: Here are the recommended best practices:\n\n• Replace 'help wanted' with the label you want to act on.\n• Use '||' to act on multiple labels.\n• Customize the BODY parameter for your comment using GitHub flavored markdown.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing access to self-hosted runners using groups?\n\nAssistant: You can use policies to limit access to self-hosted runners that have been added to an organization.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nEnterprise accounts, organizations owned by enterprise accounts, and organizations using GitHub Team or GitHub Free plans can create and manage additional runner groups using self-hosted runners.\n\n## About runner groups\nTo control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them.\n\nWhen you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group.\n\nWhen new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, see Moving a runner to a group.\n\nFor information on how to route jobs to runners in a specific group, see Choosing the runner for a job.\n\n## Creating a self-hosted runner group for an organization\nWarning\n\nWe recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n\nFor more information, see About self-hosted runners.\n\nNote\n\nWhen creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, see Enforcing policies for GitHub Actions in your enterprise.\n\nAll organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups.\n\nIf no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, see Moving a runner to a group.\n\nFor information about how to create a runner group with the REST API, see REST API endpoints for GitHub Actions.\n\n1. On GitHub, navigate to the main page of the organization.\n\n2. Under your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\n\n3. In the left sidebar, click Actions, then click Runner groups.\n\n4. In the \"Runner groups\" section, click New runner group.\n\n5. Enter a name for your runner group.\n\n6. Assign a policy for repository access.\n\nYou can configure a runner group to be accessible to a specific list of repositories, or to all repositories in the organization. By default, only private repositories can access runners in a runner group, but you can override this. This setting can't be overridden if configuring an organization's runner group that was shared by an enterprise.\n\n7. Click Create group to create the group and apply the policy.\n\n## Changing which repositories can access a runner group\nWarning\n\nWe recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n\nFor more information, see About self-hosted runners.\n\nFor runner groups in an organization, you can change what repositories in the organization can access a runner group.\n\n1. Navigate to the main page of the organization where your runner groups are located.\n\n2. Click Settings.\n\n3. In the left sidebar, click Actions, then click Runner groups.\n\n4. In the list of groups, click the runner group you'd like to configure.\n\n5. Under \"Repository access,\" use the dropdown menu to click Selected repositories.\n1. To the right of the dropdown menu, click .\n2. In the popup, use the checkboxes to select repositories that can access this runner group.\n6. Click Save group.\n\n## Changing the name of a runner group\n1. Navigate to the main page of the organization where your runner groups are located.\n2. Click Settings.\n3. In the left sidebar, click Actions, then click Runner groups.\n4. In the list of groups, click the runner group you'd like to configure.\n5. Enter the new runner group name in the text field under \"Group name.\"\n6. Click Save.\n\n## Automatically adding a self-hosted runner to a group\nYou can use the configuration script to automatically add a new runner to a group. For example, this command registers a new runner and uses the `--runnergroup` parameter to add it to a group named `rg-runnergroup`.\n\n```shell\n./config.sh --url $org_or_enterprise_url --token $token --runnergroup rg-runnergroup\n```\n\nThe command will fail if the runner group doesn't exist:\n\n```shell\nCould not find any self-hosted runner group named \"rg-runnergroup\".\n```\n\n## Moving a self-hosted runner to a group\nIf you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group.\n\n1. On GitHub, navigate to the main page of the organization.\n\n2. Under your organization name, click Settings. If you cannot see the \"Settings\" tab, select the dropdown menu, then click Settings.\n\n3. In the left sidebar, click Actions, then click Runners.\n\n4. In the \"Runners\" list, click the runner that you want to configure.\n\n5. Select the **Runner group** drop-down.\n\n6. In \"Move runner to group\", choose a destination group for the runner.\n\n## Removing a self-hosted runner group\nIn order to remove a runner group, you must first move or remove all of the runners from the group.\n\n1. Navigate to the main page of the organization where your runner groups are located.\n2. Click Settings.\n3. In the left sidebar, click Actions, then click Runner groups.\n4. In the list of groups, to the right of the group you want to delete, click .\n5. To remove the group, click Remove group.\n6. Review the confirmation prompts, and click Remove this runner group.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Managing access to self-hosted runners using groups?\n\nAssistant: Here are some code examples:\n\n### Automatically adding a self-hosted runner to a group\n```yaml\n./config.sh --url $org_or_enterprise_url --token $token --runnergroup rg-runnergroup\n```\n\n### Error message when runner group doesn't exist\n```yaml\nCould not find any self-hosted runner group named \"rg-runnergroup\".\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Managing access to self-hosted runners using groups?\n\nAssistant: Here are the recommended best practices:\n\n• We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Go?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your Go project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to build, test, and publish a Go package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Go. For a full list of up-to-date software and the preinstalled versions of Go, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#preinstalled-software).\n\n## Prerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).\n\nWe recommend that you have a basic understanding of the Go language. For more information, see [Getting started with Go](https://golang.org/doc/tutorial/getting-started).\n\n## Using a Go workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a Go workflow template that should work for most Go projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. If you already have a workflow in your repository, click **New workflow**.\n\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"go\".\n\n5. Filter the selection of workflows by clicking **Continuous integration**.\n\n6. On the \"Go - by GitHub Actions\" workflow, click **Configure**.\n\n7. Edit the workflow as required. For example, change the version of Go.\n\n8. Click **Commit changes**.\n\nThe `go.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying a Go version\nThe easiest way to specify a Go version is by using the `setup-go` action provided by GitHub. For more information see, the [`setup-go` action](https://github.com/actions/setup-go/).\n\nTo use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to the `go-version` property of the `setup-go` action. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries to `PATH`. These changes will persist for the remainder of the job.\n\nThe `setup-go` action is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it to `PATH`.\n\n## Using multiple versions of Go\n```hljs yaml\nname: Go\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go ${{ matrix.go-version }}\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      # You can test your matrix by printing the current Go version\n      - name: Display Go version\n        run: go version\n```\n\n## Using a specific Go version\nYou can configure your job to use a specific version of Go, such as `1.20.8`. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest patch release of Go 1.21:\n\n```hljs yaml\n      - name: Setup Go 1.21.x\n        uses: actions/setup-go@v5\n        with:\n          # Semantic version range syntax or exact version of Go\n          go-version: '1.21.x'\n```\n\n## Installing dependencies\nYou can use `go get` to install dependencies:\n\n```hljs yaml\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: |\n          go get .\n          go get example.com/octo-examplemodule\n          go get example.com/octo-examplemodule@v1.3.4\n```\n\n## Caching dependencies\nYou can cache and restore dependencies using the [`setup-go` action](https://github.com/actions/setup-go). By default, caching is enabled when using the `setup-go` action.\n\nThe `setup-go` action searches for the dependency file, `go.sum`, in the repository root and uses the hash of the dependency file as a part of the cache key.\n\nYou can use the `cache-dependency-path` parameter for cases when multiple dependency files are used, or when they are located in different subdirectories.\n\n```hljs yaml\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.17'\n          cache-dependency-path: subdir/go.sum\n```\n\nIf you have a custom requirement or need finer controls for caching, you can use the [`cache` action](https://github.com/marketplace/actions/cache). For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to use `go build` and `go test` in a job:\n\n```hljs yaml\nname: Go\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: go get .\n      - name: Build\n        run: go build -v ./...\n      - name: Test with the Go CLI\n        run: go test\n```\n\n## Packaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the `upload-artifact` action to upload test results.\n\nFor more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).\n\n```hljs yaml\nname: Upload Go test results\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      - name: Install dependencies\n        run: go get .\n      - name: Test with Go\n        run: go test -json > TestResults-${{ matrix.go-version }}.json\n      - name: Upload Go test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: Go-results-${{ matrix.go-version }}\n          path: TestResults-${{ matrix.go-version }}.json\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Go?\n\nAssistant: Here are some code examples:\n\n### Using multiple versions of Go\n```yaml\n```hljs yaml\nname: Go\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go ${{ matrix.go-version }}\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      # You can test your matrix by printing the current Go version\n      - name: Display Go version\n        run: go version\n```\n```\n\n### Using a specific Go version\n```yaml\n```hljs yaml\n      - name: Setup Go 1.21.x\n        uses: actions/setup-go@v5\n        with:\n          # Semantic version range syntax or exact version of Go\n          go-version: '1.21.x'\n```\n```\n\n### Installing dependencies\n```yaml\n```hljs yaml\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: |\n          go get .\n          go get example.com/octo-examplemodule\n          go get example.com/octo-examplemodule@v1.3.4\n```\n```\n\n### Caching dependencies\n```yaml\n```hljs yaml\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.17'\n          cache-dependency-path: subdir/go.sum\n```\n```\n\n### Building and testing your code\n```yaml\n```hljs yaml\nname: Go\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: go get .\n      - name: Build\n        run: go build -v ./...\n      - name: Test with the Go CLI\n        run: go test\n```\n```\n\n### Packaging workflow data as artifacts\n```yaml\n```hljs yaml\nname: Upload Go test results\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      - name: Install dependencies\n        run: go get .\n      - name: Test with Go\n        run: go test -json > TestResults-${{ matrix.go-version }}.json\n      - name: Upload Go test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: Go-results-${{ matrix.go-version }}\n          path: TestResults-${{ matrix.go-version }}.json\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Publishing Java packages with Gradle?\n\nAssistant: You can use Gradle to publish Java packages to a registry as part of your continuous integration (CI) workflow.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that publishes Java packages to GitHub Packages and the Maven Central Repository. With a single workflow, you can publish packages to a single repository or to multiple repositories.\n\nWarning\n\nThe examples used in this guide refer to the Legacy OSSRH service. See Publishing in the Maven Central Repository documentation.\n\n## Prerequisites\nWe recommend that you have a basic understanding of workflow files and configuration options. For more information, see Writing workflows.\n\nFor more information about creating a CI workflow for your Java project with Gradle, see Building and testing Java with Gradle.\n\nYou may also find it helpful to have a basic understanding of the following:\n\n- Working with the Apache Maven registry\n- Store information in variables\n- Using secrets in GitHub Actions\n- Automatic token authentication\n\n## About package configuration\nThe `groupId` and `artifactId` fields in the `MavenPublication` section of the _build.gradle_ file create a unique identifier for your package that registries use to link your package to a registry. This is similar to the `groupId` and `artifactId` fields of the Maven _pom.xml_ file. For more information, see the Maven Publish Plugin in the Gradle documentation.\n\nThe _build.gradle_ file also contains configuration for the distribution management repositories that Gradle will publish packages to. Each repository must have a name, a deployment URL, and credentials for authentication.\n\n## Publishing packages to the Maven Central Repository\nEach time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the `release` event triggers with type `created`. The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on the `release` event, see Events that trigger workflows.\n\nYou can define a new Maven repository in the publishing block of your _build.gradle_ file that points to your package repository. For example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, your _build.gradle_ could specify a repository with the name \"OSSRH\".\n\n## Publishing packages to GitHub Packages\nEach time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the `release` event triggers with type `created`. The workflow publishes the package to GitHub Packages if CI tests pass. For more information on the `release` event, see Events that trigger workflows.\n\nYou can define a new Maven repository in the publishing block of your _build.gradle_ that points to GitHub Packages. In that repository configuration, you can also take advantage of environment variables set in your CI workflow run. You can use the `GITHUB_ACTOR` environment variable as a username, and you can set the `GITHUB_TOKEN` environment variable with your `GITHUB_TOKEN` secret.\n\n## Publishing packages to the Maven Central Repository and GitHub Packages\nYou can publish your packages to both the Maven Central Repository and GitHub Packages by configuring each in your _build.gradle_ file.\n\nEnsure your _build.gradle_ file includes a repository for both your GitHub repository and your Maven Central Repository provider.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Publishing Java packages with Gradle?\n\nAssistant: Here are some code examples:\n\n### Publishing to Maven Central Repository\n```yaml\nplugins {\n  ...\n  id 'maven-publish'\n}\n\npublishing {\n  ...\n\n  repositories {\n    maven {\n      name = \"OSSRH\"\n      url = \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\n      credentials {\n        username = System.getenv(\"MAVEN_USERNAME\")\n        password = System.getenv(\"MAVEN_PASSWORD\")\n      }\n    }\n  }\n}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Publishing Java packages with Gradle?\n\nAssistant: Here are the recommended best practices:\n\n• GitHub recommends pinning actions to a commit SHA.\n• To get a newer version, you will need to update the SHA.\n• You can also reference a tag or branch, but the action may change without warning.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying to Amazon Elastic Container Service?\n\nAssistant: You can deploy to Amazon Elastic Container Service (ECS) as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build a containerized application, push it to Amazon Elastic Container Registry (ECR), and deploy it to Amazon Elastic Container Service (ECS) when there is a push to the `main` branch.\n\nOn every new push to `main` in your GitHub repository, the GitHub Actions workflow builds and pushes a new container image to Amazon ECR, and then deploys a new task definition to Amazon ECS.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Amazon Web Services.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps for Amazon ECR and ECS:\n\n1. Create an Amazon ECR repository to store your images.\n\nFor example, using the AWS CLI:\n\n```bash\naws ecr create-repository \\\n       --repository-name MY_ECR_REPOSITORY \\\n       --region MY_AWS_REGION\n```\n\nEnsure that you use the same Amazon ECR repository name (represented here by `MY_ECR_REPOSITORY`) for the `ECR_REPOSITORY` variable in the workflow below.\n\nEnsure that you use the same AWS region value for the `AWS_REGION` (represented here by `MY_AWS_REGION`) variable in the workflow below.\n\n2. Create an Amazon ECS task definition, cluster, and service.\n\nFor details, follow the Getting started wizard on the Amazon ECS console, or the Getting started guide in the Amazon ECS documentation.\n\nEnsure that you note the names you set for the Amazon ECS service and cluster, and use them for the `ECS_SERVICE` and `ECS_CLUSTER` variables in the workflow below.\n\n3. Store your Amazon ECS task definition as a JSON file in your GitHub repository.\n\nThe format of the file should be the same as the output generated by:\n\n```bash\naws ecs register-task-definition --generate-cli-skeleton\n```\n\nEnsure that you set the `ECS_TASK_DEFINITION` variable in the workflow below as the path to the JSON file.\n\nEnsure that you set the `CONTAINER_NAME` variable in the workflow below as the container name in the `containerDefinitions` section of the task definition.\n\n4. Create GitHub Actions secrets named `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` to store the values for your Amazon IAM access key.\n\nFor more information on creating secrets for GitHub Actions, see Using secrets in GitHub Actions.\n\nSee the documentation for each action used below for the recommended IAM policies for the IAM user, and methods for handling the access key credentials.\n\n5. Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build a container image and push it to Amazon ECR. It then updates the task definition with the new image ID, and deploys the task definition to Amazon ECS.\n\nEnsure that you provide your own values for all the variables in the `env` key of the workflow.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n```yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Deploy to Amazon ECS\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  AWS_REGION: MY_AWS_REGION                   # set this to your preferred AWS region, e.g. us-west-1\n  ECR_REPOSITORY: MY_ECR_REPOSITORY           # set this to your Amazon ECR repository name\n  ECS_SERVICE: MY_ECS_SERVICE                 # set this to your Amazon ECS service name\n  ECS_CLUSTER: MY_ECS_CLUSTER                 # set this to your Amazon ECS cluster name\n  ECS_TASK_DEFINITION: MY_ECS_TASK_DEFINITION # set this to the path to your Amazon ECS task definition\n                                               # file, e.g. .aws/task-definition.json\n  CONTAINER_NAME: MY_CONTAINER_NAME           # set this to the name of the container in the\n                                               # containerDefinitions section of your task definition\n\njobs:\n  deploy:\n    name: Deploy\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: ${{ env.AWS_REGION }}\n\n      - name: Login to Amazon ECR\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@62f4f872db3836360b72999f4b87f1ff13310f3a\n\n      - name: Build, tag, and push image to Amazon ECR\n        id: build-image\n        env:\n          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n          IMAGE_TAG: ${{ github.sha }}\n        run: |\n          # Build a docker container and\n          # push it to ECR so that it can\n          # be deployed to ECS.\n          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .\n          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\n          echo \"image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\" >> $GITHUB_OUTPUT\n\n      - name: Fill in the new image ID in the Amazon ECS task definition\n        id: task-def\n        uses: aws-actions/amazon-ecs-render-task-definition@c804dfbdd57f713b6c079302a4c01db7017a36fc\n        with:\n          task-definition: ${{ env.ECS_TASK_DEFINITION }}\n          container-name: ${{ env.CONTAINER_NAME }}\n          image: ${{ steps.build-image.outputs.image }}\n\n      - name: Deploy Amazon ECS task definition\n        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a\n        with:\n          task-definition: ${{ steps.task-def.outputs.task-definition }}\n          service: ${{ env.ECS_SERVICE }}\n          cluster: ${{ env.ECS_CLUSTER }}\n          wait-for-service-stability: true\n```\n\n## Additional resources\nFor the original workflow template, see `aws.yml` in the GitHub Actions `starter-workflows` repository.\n\nFor more information on the services used in these examples, see the following documentation:\n\n- Security best practices in IAM in the Amazon AWS documentation.\n- Official AWS Configure AWS Credentials action.\n- Official AWS Amazon ECR \"Login\" action.\n- Official AWS Amazon ECS \"Render Task Definition\" action.\n- Official AWS Amazon ECS \"Deploy Task Definition\" action.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying to Amazon Elastic Container Service?\n\nAssistant: Here are some code examples:\n\n### Create an Amazon ECR repository\n```yaml\naws ecr create-repository \\\n       --repository-name MY_ECR_REPOSITORY \\\n       --region MY_AWS_REGION\n```\n\n### Register task definition skeleton\n```yaml\naws ecs register-task-definition --generate-cli-skeleton\n```\n\n### GitHub Actions workflow example\n```yaml\nname: Deploy to Amazon ECS\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  AWS_REGION: MY_AWS_REGION                   # set this to your preferred AWS region, e.g. us-west-1\n  ECR_REPOSITORY: MY_ECR_REPOSITORY           # set this to your Amazon ECR repository name\n  ECS_SERVICE: MY_ECS_SERVICE                 # set this to your Amazon ECS service name\n  ECS_CLUSTER: MY_ECS_CLUSTER                 # set this to your Amazon ECS cluster name\n  ECS_TASK_DEFINITION: MY_ECS_TASK_DEFINITION # set this to the path to your Amazon ECS task definition\n                                               # file, e.g. .aws/task-definition.json\n  CONTAINER_NAME: MY_CONTAINER_NAME           # set this to the name of the container in the\n                                               # containerDefinitions section of your task definition\n\njobs:\n  deploy:\n    name: Deploy\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: ${{ env.AWS_REGION }}\n\n      - name: Login to Amazon ECR\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@62f4f872db3836360b72999f4b87f1ff13310f3a\n\n      - name: Build, tag, and push image to Amazon ECR\n        id: build-image\n        env:\n          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n          IMAGE_TAG: ${{ github.sha }}\n        run: |\n          # Build a docker container and\n          # push it to ECR so that it can\n          # be deployed to ECS.\n          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .\n          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\n          echo \"image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\" >> $GITHUB_OUTPUT\n\n      - name: Fill in the new image ID in the Amazon ECS task definition\n        id: task-def\n        uses: aws-actions/amazon-ecs-render-task-definition@c804dfbdd57f713b6c079302a4c01db7017a36fc\n        with:\n          task-definition: ${{ env.ECS_TASK_DEFINITION }}\n          container-name: ${{ env.CONTAINER_NAME }}\n          image: ${{ steps.build-image.outputs.image }}\n\n      - name: Deploy Amazon ECS task definition\n        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a\n        with:\n          task-definition: ${{ steps.task-def.outputs.task-definition }}\n          service: ${{ env.ECS_SERVICE }}\n          cluster: ${{ env.ECS_CLUSTER }}\n          wait-for-service-stability: true\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying to Amazon Elastic Container Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Configuring OpenID Connect in Google Cloud Platform?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with Google Cloud Platform.\n\nHere's a detailed explanation:\n\n\n## Overview\nOpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Google Cloud Platform (GCP), without needing to store the GCP credentials as long-lived GitHub secrets.\n\nThis guide gives an overview of how to configure GCP to trust GitHub's OIDC as a federated identity, and includes a workflow example for the [`google-github-actions/auth`](https://github.com/google-github-actions/auth) action that uses tokens to authenticate to GCP and access resources.\n\n## Prerequisites\n- To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).\n\n- Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, you **must** define at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\n## Adding a Google Cloud Workload Identity Provider\nTo configure the OIDC identity provider in GCP, you will need to perform the following configuration. For instructions on making these changes, refer to [the GCP documentation](https://github.com/google-github-actions/auth).\n\n1. Create a new identity pool.\n2. Configure the mapping and add conditions.\n3. Connect the new pool to a service account.\n\nAdditional guidance for configuring the identity provider:\n\n- For security hardening, make sure you've reviewed [Configuring the OIDC trust with the cloud](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud). For an example, see [Configuring the subject in your cloud provider](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-subject-in-your-cloud-provider).\n- For the service account to be available for configuration, it needs to be assigned to the `roles/iam.workloadIdentityUser` role. For more information, see [the GCP documentation](https://cloud.google.com/iam/docs/workload-identity-federation?_ga=2.114275588.-285296507.1634918453#conditions).\n- The Issuer URL to use: `https://token.actions.githubusercontent.com`.\n\n## Updating your GitHub Actions workflow\nTo update your workflows for OIDC, you will need to make two changes to your YAML:\n\n1. Add permissions settings for the token.\n2. Use the [`google-github-actions/auth`](https://github.com/google-github-actions/auth) action to exchange the OIDC token (JWT) for a cloud access token.\n\nNote\n\nWhen environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#deployment-protection-rules).\n\n## Adding permissions settings\nThe job or workflow run requires a `permissions` setting with [`id-token: write`](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token) to allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if the `permissions` for `id-token` is not set to `write`, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect#configuring-the-oidc-trust-with-the-cloud).\n\nThe `id-token: write` setting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:\n\n- Using environment variables on the runner ( `ACTIONS_ID_TOKEN_REQUEST_URL` and `ACTIONS_ID_TOKEN_REQUEST_TOKEN`).\n- Using `getIDToken()` from the Actions toolkit.\n\nIf you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n\nIf you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:\n\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n\nYou may need to specify additional permissions here, depending on your workflow's requirements.\n\nFor reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, the `permissions` setting for `id-token` should be explicitly set to `write` at the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended.\n\nFor more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).\n\n## Requesting the access token\nThe `google-github-actions/auth` action receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCP [documentation](https://github.com/google-github-actions/auth).\n\nThis example has a job called `Get_OIDC_ID_token` that uses actions to request a list of services from GCP.\n\n- `WORKLOAD-IDENTITY-PROVIDER`: Replace this with the path to your identity provider in GCP. For example, `projects/example-project-id/locations/global/workloadIdentityPools/name-of-pool/providers/name-of-provider`\n- `SERVICE-ACCOUNT`: Replace this with the name of your service account in GCP.\n\nThis action exchanges a GitHub OIDC token for a Google Cloud access token, using [Workload Identity Federation](https://cloud.google.com/iam/docs/workload-identity-federation).\n\n```hljs yaml\nname: List services in GCP\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  id-token: write\n\njobs:\n  Get_OIDC_ID_token:\n    runs-on: ubuntu-latest\n    steps:\n    - id: 'auth'\n      name: 'Authenticate to GCP'\n      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'\n      with:\n          create_credentials_file: 'true'\n          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'\n          service_account: 'SERVICE-ACCOUNT'\n    - id: 'gcloud'\n      name: 'gcloud'\n      run: |-\n        gcloud auth login --brief --cred-file=\"${{ steps.auth.outputs.credentials_file_path }}\"\n        gcloud services list\n```\n\n## Further reading\n- [Using OpenID Connect with reusable workflows](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows)\n\n- [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Configuring OpenID Connect in Google Cloud Platform?\n\nAssistant: Here are some code examples:\n\n### Adding permissions settings\n```yaml\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout\n```\n```\n\n### Adding permissions settings (job level)\n```yaml\n```hljs yaml\npermissions:\n  id-token: write # This is required for requesting the JWT\n```\n```\n\n### Requesting the access token\n```yaml\n```hljs yaml\nname: List services in GCP\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  id-token: write\n\njobs:\n  Get_OIDC_ID_token:\n    runs-on: ubuntu-latest\n    steps:\n    - id: 'auth'\n      name: 'Authenticate to GCP'\n      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'\n      with:\n          create_credentials_file: 'true'\n          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'\n          service_account: 'SERVICE-ACCOUNT'\n    - id: 'gcloud'\n      name: 'gcloud'\n      run: |-\n        gcloud auth login --brief --cred-file=\"${{ steps.auth.outputs.credentials_file_path }}\"\n        gcloud services list\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Configuring OpenID Connect in Google Cloud Platform?\n\nAssistant: Here are the recommended best practices:\n\n• When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security.\n• For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Migrating from Jenkins with GitHub Actions Importer?\n\nAssistant: Learn how to use GitHub Actions Importer to automate the migration of your Jenkins pipelines to GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## About migrating from Jenkins with GitHub Actions Importer\nThe instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Jenkins pipelines to GitHub Actions.\n\n## Prerequisites\n- A Jenkins account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.\n- Access to create a Jenkins personal API token for your account or organization.\n- An environment where you can run Linux-based containers, and can install the necessary tools.\n\n  - Docker is [installed](https://docs.docker.com/get-docker/) and running.\n  - [GitHub CLI](https://cli.github.com/) is installed.\n\nNote\n\nThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n\n## Limitations\nThere are some limitations when migrating from Jenkins to GitHub Actions with GitHub Actions Importer. For example, you must migrate the following constructs manually:\n\n- Mandatory build tools\n- Scripted pipelines\n- Secrets\n- Self-hosted runners\n- Unknown plugins\n\nFor more information on manual migrations, see [Migrating from Jenkins to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions).\n\n## Installing the GitHub Actions Importer CLI extension\n1. Install the GitHub Actions Importer CLI extension:\n\n```hljs bash\ngh extension install github/gh-actions-importer\n```\n\n2. Verify that the extension is installed:\n\n```hljs bash\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n## Configuring credentials\nThe `configure` CLI command is used to set required credentials and options for GitHub Actions Importer when working with Jenkins and GitHub.\n\n1. Create a GitHub personal access token (classic). For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic).\n\nYour token must have the `workflow` scope.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n2. Create a Jenkins API token. For more information, see [Authenticating scripted clients](https://www.jenkins.io/doc/book/system-administration/authenticating-scripted-clients/) in the Jenkins documentation.\n\nAfter creating the token, copy it and save it in a safe location for later use.\n\n3. In your terminal, run the GitHub Actions Importer `configure` CLI command:\n\n```hljs shell\ngh actions-importer configure\n```\n\nThe `configure` command will prompt you for the following information:\n\n   - For \"Which CI providers are you configuring?\", use the arrow keys to select `Jenkins`, press `Space` to select it, then press `Enter`.\n   - For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and press `Enter`.\n   - For \"Base url of the GitHub instance\", press `Enter` to accept the default value ( `https://github.com`).\n   - For \"Personal access token for Jenkins\", enter the value for the Jenkins personal API token that you created earlier, and press `Enter`.\n   - For \"Username of Jenkins user\", enter your Jenkins username and press `Enter`.\n   - For \"Base url of the Jenkins instance\", enter the URL of your Jenkins instance, and press `Enter`.\n\nAn example of the `configure` command is shown below:\n\n```hljs shell\n$ gh actions-importer configure\n✔ Which CI providers are you configuring?: Jenkins\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Jenkins: ***************\n✔ Username of Jenkins user: admin\n✔ Base url of the Jenkins instance: https://localhost\nEnvironment variables successfully updated.\n```\n\n4. In your terminal, run the GitHub Actions Importer `update` CLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:\n\n```hljs shell\ngh actions-importer update\n```\n\nThe output of the command should be similar to below:\n\n```hljs shell\nUpdating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date\n```\n\n## Perform an audit of Jenkins\nYou can use the `audit` command to get a high-level view of all pipelines in a Jenkins server.\n\nThe `audit` command performs the following steps:\n\n1. Fetches all of the projects defined in a Jenkins server.\n2. Converts each pipeline to its equivalent GitHub Actions workflow.\n3. Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer.\n\n## Running the audit command\nTo perform an audit of a Jenkins server, run the following command in your terminal:\n\n```hljs shell\ngh actions-importer audit jenkins --output-dir tmp/audit\n```\n\n## Inspecting the audit results\nThe files in the specified output directory contain the results of the audit. See the `audit_summary.md` file for a summary of the audit results.\n\nThe audit summary has the following sections.\n\n## Pipelines\nThe \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Pipelines\" section:\n\n- **Successful** pipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.\n- **Partially successful** pipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.\n- **Unsupported** pipelines are definition types that are not supported by GitHub Actions Importer.\n- **Failed** pipelines encountered a fatal error when being converted. This can occur for one of three reasons:\n\n  - The pipeline was originally misconfigured and not valid.\n  - GitHub Actions Importer encountered an internal error when converting it.\n  - There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.\n\n## Build steps\nThe \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer.\n\nListed below are some key terms that can appear in the \"Build steps\" section:\n\n- A **known** build step is a step that was automatically converted to an equivalent action.\n- An **unknown** build step is a step that was not automatically converted to an equivalent action.\n- An **unsupported** build step is a step that is either:\n  - Fundamentally not supported by GitHub Actions.\n  - Configured in a way that is incompatible with GitHub Actions.\n- An **action** is a list of the actions that were used in the converted workflows. This can be important for:\n  - If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.\n  - Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.\n\n## Manual tasks\nThe \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually.\n\nListed below are some key terms that can appear in the \"Manual tasks\" section:\n\n- A **secret** is a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n- A **self-hosted runner** refers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly.\n\n## Files\nThe final section of the audit report provides a manifest of all the files that were written to disk during the audit.\n\nEach pipeline file has a variety of files included in the audit, including:\n\n- The original pipeline as it was defined in GitHub.\n- Any network responses used to convert the pipeline.\n- The converted workflow file.\n- Stack traces that can be used to troubleshoot a failed pipeline conversion.\n\nAdditionally, the `workflow_usage.csv` file contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews.\n\n## Forecast potential build runner usage\nYou can use the `forecast` command to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Jenkins server.\n\n## Prerequisites for running the forecast command\nIn order to run the `forecast` command against a Jenkins instance, you must install the [`paginated-builds` plugin](https://plugins.jenkins.io/paginated-builds) on your Jenkins server. This plugin allows GitHub Actions Importer to efficiently retrieve historical build data for jobs that have a large number of builds. Because Jenkins does not provide a method to retrieve paginated build data, using this plugin prevents timeouts from the Jenkins server that can occur when fetching a large amount of historical data. The `paginated-builds` plugin is open source, and exposes a REST API endpoint to fetch build data in pages, rather than all at once.\n\nTo install the `paginated-builds` plugin:\n\n1. On your Jenkins instance, navigate to `https://<your-jenkins-instance>/pluginManager/available`.\n2. Search for the `paginated-builds` plugin.\n3. Check the box on the left and select **Install without restart**.\n\n## Running the forecast command\nTo perform a forecast of potential GitHub Actions, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report.\n\n```hljs shell\ngh actions-importer forecast jenkins --output-dir tmp/forecast\n```\n\n## Inspecting the forecast report\nThe `forecast_report.md` file in the specified output directory contains the results of the forecast.\n\nListed below are some key terms that can appear in the forecast report:\n\n- The **job count** is the total number of completed jobs.\n- The **pipeline count** is the number of unique pipelines used.\n- **Execution time** describes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.\n  - This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use the [GitHub Actions pricing calculator](https://github.com/pricing/calculator) to estimate the costs.\n- **Queue time** metrics describe the amount of time a job spent waiting for a runner to be available to execute it.\n- **Concurrent jobs** metrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure.\n\nAdditionally, these metrics are defined for each queue of runners in Jenkins. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners.\n\n## Perform a dry-run migration of a Jenkins pipeline\nYou can use the `dry-run` command to convert a Jenkins pipeline to its equivalent GitHub Actions workflow.\n\n## Running the dry-run command\nYou can use the `dry-run` command to convert a Jenkins pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline.\n\nTo perform a dry run of migrating your Jenkins pipelines to GitHub Actions, run the following command in your terminal, replacing `my-jenkins-project` with the URL of your Jenkins job.\n\n```hljs shell\ngh actions-importer dry-run jenkins --source-url my-jenkins-project --output-dir tmp/dry-run\n```\n\n## Inspecting the converted workflows\nYou can view the logs of the dry run and the converted workflow files in the specified output directory.\n\nIf there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, see [Extending GitHub Actions Importer with custom transformers](https://docs.github.com/en/actions/migrating-to-github-actions/automated-migrations/extending-github-actions-importer-with-custom-transformers).\n\n## Perform a production migration of a Jenkins pipeline\nYou can use the `migrate` command to convert a Jenkins pipeline and open a pull request with the equivalent GitHub Actions workflow.\n\n## Running the migrate command\nTo migrate a Jenkins pipeline to GitHub Actions, run the following command in your terminal, replacing the `target-url` value with the URL for your GitHub repository, and `my-jenkins-project` with the URL for your Jenkins job.\n\n```hljs shell\ngh actions-importer migrate jenkins --target-url https://github.com/:owner/:repo --output-dir tmp/migrate --source-url my-jenkins-project\n```\n\nThe command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:\n\n```hljs shell\n$ gh actions-importer migrate jenkins --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --source-url http://localhost:8080/job/monas_dev_work/job/monas_freestyle\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'\n```\n\n## Inspecting the pull request\nThe output from a successful run of the `migrate` command contains a link to the new pull request that adds the converted workflow to your repository.\n\nSome important elements of the pull request include:\n\n- In the pull request description, a section called **Manual steps**, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.\n- The converted workflows file. Select the **Files changed** tab in the pull request to view the workflow file that will be added to your GitHub repository.\n\nWhen you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository.\n\n## Reference\nThis section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Jenkins.\n\n## Using environment variables\nGitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using the `configure` command. For more information, see the [Configuring credentials](https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-jenkins-with-github-actions-importer#configuring-credentials) section.\n\nGitHub Actions Importer uses the following environment variables to connect to your Jenkins instance:\n\n- `GITHUB_ACCESS_TOKEN`: The personal access token (classic) used to create pull requests with a converted workflow (requires `repo` and `workflow` scopes).\n- `GITHUB_INSTANCE_URL`: The URL to the target GitHub instance (for example, `https://github.com`).\n- `JENKINS_ACCESS_TOKEN`: The Jenkins API token used to view Jenkins resources.\n\nNote\n\nThis token requires access to all jobs that you want to migrate or audit. In cases where a folder or job does not inherit access control lists from their parent, you must grant explicit permissions or full admin privileges.\n\n- `JENKINS_USERNAME`: The username of the user account that created the Jenkins API token.\n- `JENKINS_INSTANCE_URL`: The URL of the Jenkins instance.\n- `JENKINSFILE_ACCESS_TOKEN` (Optional) The API token used to retrieve the contents of a `Jenkinsfile` stored in the build repository. This requires the `repo` scope. If this is not provided, the `GITHUB_ACCESS_TOKEN` will be used instead.\n\nThese environment variables can be specified in a `.env.local` file that is loaded by GitHub Actions Importer when it is run.\n\n## Using optional arguments\nThere are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration.\n\n## --source-file-path\nYou can use the `--source-file-path` argument with the `forecast`, `dry-run`, or `migration` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--source-file-path` argument tells GitHub Actions Importer to use the specified source file path instead. You can use this option for Jenkinsfile and multibranch pipelines.\n\nIf you would like to supply multiple source files when running the `forecast` subcommand, you can use pattern matching in the file path value. For example, `gh forecast --source-file-path ./tmp/previous_forecast/jobs/*.json` supplies GitHub Actions Importer with any source files that match the `./tmp/previous_forecast/jobs/*.json` file path.\n\n## Jenkinsfile pipeline example\nIn this example, GitHub Actions Importer uses the specified Jenkinsfile as the source file to perform a dry run.\n\n```hljs shell\ngh actions-importer dry-run jenkins --output-dir path/to/output/ --source-file-path path/to/Jenkinsfile --source-url :url_to_jenkins_job\n```\n\n## --config-file-path\nYou can use the `--config-file-path` argument with the `audit`, `dry-run`, and `migrate` subcommands.\n\nBy default, GitHub Actions Importer fetches pipeline contents from source control. The `--config-file-path` argument tells GitHub Actions Importer to use the specified source files instead.\n\nWhen you use the `--config-file-path` option with the `dry-run` or `migrate` subcommands, GitHub Actions Importer matches the repository slug to the job represented by the `--source-url` option to select the pipeline. It uses the `config-file-path` to pull the specified source file.\n\n## Audit example\nIn this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit.\n\n```hljs shell\ngh actions-importer audit jenkins --output-dir path/to/output/ --config-file-path path/to/jenkins/config.yml\n```\n\nTo audit a Jenkins instance using a config file, the config file must be in the following format, and each `repository_slug` value must be unique:\n\n```hljs yaml\nsource_files:\n  - repository_slug: pipeline-name\n    path: path/to/Jenkinsfile\n  - repository_slug: multi-branch-pipeline-name\n    branches:\n      - branch: main\n        path: path/to/Jenkinsfile\n      - branch: node\n        path: path/to/Jenkinsfile\n```\n\n## Supported syntax for Jenkins pipelines\nThe following tables show the type of properties GitHub Actions Importer is currently able to convert. For more details about how Jenkins pipeline syntax aligns with GitHub Actions, see [Migrating from Jenkins to GitHub Actions](https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions).\n\nFor information about supported Jenkins plugins, see the [`github/gh-actions-importer` repository](https://github.com/github/gh-actions-importer/blob/main/docs/jenkins/index.md).\n\n## Supported syntax for Freestyle pipelines\n| Jenkins | GitHub Actions | Status |\n| :-- | :-- | :-- |\n| docker template | `jobs.<job_id>.container` | Supported |\n| build | `jobs` | Partially supported |\n| build environment | `env` | Partially supported |\n| build triggers | `on` | Partially supported |\n| general | `runners` | Partially supported |\n\n## Supported syntax for Jenkinsfile pipelines\n| Jenkins | GitHub Actions | Status |\n| :-- | :-- | :-- |\n| docker | `jobs.<job_id>.container` | Supported |\n| stage | `jobs.<job_id>` | Supported |\n| agent | `runners` | Partially supported |\n| environment | `env` | Partially supported |\n| stages | `jobs` | Partially supported |\n| steps | `jobs.<job_id>.steps` | Partially supported |\n| triggers | `on` | Partially supported |\n| when | `jobs.<job_id>.if` | Partially supported |\n| inputs | `inputs` | Unsupported |\n| matrix | `jobs.<job_id>.strategy.matrix` | Unsupported |\n| options | `jobs.<job_id>.strategy` | Unsupported |\n| parameters | `inputs` | Unsupported |\n\n## Environment variables syntax\nGitHub Actions Importer uses the mapping in the table below to convert default Jenkins environment variables to the closest equivalent in GitHub Actions.\n\n| Jenkins | GitHub Actions |\n| :-- | :-- |\n| `${BUILD_ID}` | `${{ github.run_id }}` |\n| `${BUILD_NUMBER}` | `${{ github.run_id }}` |\n| `${BUILD_TAG}` | `${{ github.workflow }}-${{ github.run_id }}` |\n| `${BUILD_URL}` | `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}` |\n| `${JENKINS_URL}` | `${{ github.server_url }}` |\n| `${JOB_NAME}` | `${{ github.workflow }}` |\n| `${WORKSPACE}` | `${{ github.workspace }}` |\n\n## Legal notice\nPortions have been adapted from [https://github.com/github/gh-actions-importer/](https://github.com/github/gh-actions-importer/) under the MIT license:\n\n```hljs text\nMIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nauthors or copyright holders be liable for any claim, damages or other\nliability, whether in an action of contract, tort or otherwise, arising from,\nout of or in connection with the Software or the use or other dealings in the\nSoftware.\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Migrating from Jenkins with GitHub Actions Importer?\n\nAssistant: Here are some code examples:\n\n### Installing the GitHub Actions Importer CLI extension\n```yaml\ngh extension install github/gh-actions-importer\n```\n\n### Verifying the extension is installed\n```yaml\n$ gh actions-importer -h\nOptions:\n     -?, -h, --help  Show help and usage information\n\nCommands:\n     update     Update to the latest version of GitHub Actions Importer.\n     version    Display the version of GitHub Actions Importer.\n     configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n     audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n     forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n     dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n     migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n```\n\n### Configuring credentials\n```yaml\ngh actions-importer configure\n```\n\n### Running the audit command\n```yaml\ngh actions-importer audit jenkins --output-dir tmp/audit\n```\n\n### Running the forecast command\n```yaml\ngh actions-importer forecast jenkins --output-dir tmp/forecast\n```\n\n### Running the dry-run command\n```yaml\ngh actions-importer dry-run jenkins --source-url my-jenkins-project --output-dir tmp/dry-run\n```\n\n### Running the migrate command\n```yaml\ngh actions-importer migrate jenkins --target-url https://github.com/:owner/:repo --output-dir tmp/migrate --source-url my-jenkins-project\n```\n\n### Using the --source-file-path argument\n```yaml\ngh actions-importer dry-run jenkins --output-dir path/to/output/ --source-file-path path/to/Jenkinsfile --source-url :url_to_jenkins_job\n```\n\n### Using the --config-file-path argument\n```yaml\ngh actions-importer audit jenkins --output-dir path/to/output/ --config-file-path path/to/jenkins/config.yml\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Migrating from Jenkins with GitHub Actions Importer?\n\nAssistant: Here are the recommended best practices:\n\n• The GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.\n• Ensure that your Jenkins API token has access to all jobs that you want to migrate or audit.\n• Use the `paginated-builds` plugin to efficiently retrieve historical build data for jobs with a large number of builds.\n• Review the audit summary to understand the conversion rate and identify any manual tasks required after migration.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Adding a workflow status badge?\n\nAssistant: You can display a status badge in your repository to indicate the status of your workflows.\n\nHere's a detailed explanation:\n\n\n## In this article\nNote\n\nWorkflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site.\n\nA status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the `README.md` file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the `branch` and `event` query parameters in the URL.\n\n![Screenshot of a workflow status badge. From right to left it shows: the GitHub logo, workflow name (\"GitHub Actions Demo\"), and status (\"passing\").](https://docs.github.com/assets/cb-16218/images/help/repository/actions-workflow-status-badge.png)\n\nTo add a workflow status badge to your `README.md` file, first find the URL for the status badge you would like to display. Then you can use Markdown to display the badge as an image in your `README.md` file. For more information about image markup in Markdown, see [Basic writing and formatting syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#images).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Adding a workflow status badge?\n\nAssistant: Here are some code examples:\n\n### Using the workflow file name\n```yaml\nhttps://github.com/OWNER/REPOSITORY/actions/workflows/WORKFLOW-FILE/badge.svg\n```\n\n### Example for workflow file name\n```yaml\n![example workflow](https://github.com/github/docs/actions/workflows/main.yml/badge.svg)\n```\n\n### Using the branch parameter\n```yaml\n![example branch parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?branch=feature-1)\n```\n\n### Using the event parameter\n```yaml\n![example event parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?event=push)\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Adding a workflow status badge?\n\nAssistant: Here are the recommended best practices:\n\n• Workflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site.\n• Badges display the status of your default branch by default, but can be customized for specific branches or events using query parameters.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Dockerfile support for GitHub Actions?\n\nAssistant: When creating a Dockerfile for a Docker container action, you should be aware of how some Docker instructions interact with GitHub Actions and an action's metadata file.\n\nHere's a detailed explanation:\n\n\n## About Dockerfile instructions\nA Dockerfile contains instructions and arguments that define the contents and startup behavior of a Docker container. For more information about the instructions Docker supports, see Dockerfile reference in the Docker documentation.\n\n## Dockerfile instructions and overrides\nSome Docker instructions interact with GitHub Actions, and an action's metadata file can override some Docker instructions. Ensure that you are familiar with how your Dockerfile interacts with GitHub Actions to prevent any unexpected behavior.\n\n## USER\nDocker actions must be run by the default Docker user (root). Do not use the USER instruction in your Dockerfile, because you won't be able to access the GITHUB_WORKSPACE directory. For more information, see Store information in variables and USER reference in the Docker documentation.\n\n## FROM\nThe first instruction in the Dockerfile must be FROM, which selects a Docker base image. For more information, see the FROM reference in the Docker documentation.\n\nThese are some best practices when setting the FROM argument:\n\n- It's recommended to use official Docker images. For example, python or ruby.\n- Use a version tag if it exists, preferably with a major version. For example, use node:10 instead of node:latest.\n- It's recommended to use Docker images based on the Debian operating system.\n\n## WORKDIR\nGitHub sets the working directory path in the GITHUB_WORKSPACE environment variable. It's recommended to not use the WORKDIR instruction in your Dockerfile. Before the action executes, GitHub will mount the GITHUB_WORKSPACE directory on top of anything that was at that location in the Docker image and set GITHUB_WORKSPACE as the working directory. For more information, see Store information in variables and the WORKDIR reference in the Docker documentation.\n\n## ENTRYPOINT\nIf you define entrypoint in an action's metadata file, it will override the ENTRYPOINT defined in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.\n\nThe Docker ENTRYPOINT instruction has a shell form and exec form. The Docker ENTRYPOINT documentation recommends using the exec form of the ENTRYPOINT instruction. For more information about exec and shell form, see the ENTRYPOINT reference in the Docker documentation.\n\nYou should not use WORKDIR to specify your entrypoint in your Dockerfile. Instead, you should use an absolute path. For more information, see WORKDIR.\n\nIf you configure your container to use the exec form of the ENTRYPOINT instruction, the args configured in the action's metadata file won't run in a command shell. If the action's args contain an environment variable, the variable will not be substituted. For example, using the following exec format will not print the value stored in $GITHUB_SHA, but will instead print \"$GITHUB_SHA\".\n\n```dockerfile\nENTRYPOINT [\"echo $GITHUB_SHA\"]\n```\n\nIf you want variable substitution, then either use the shell form or execute a shell directly. For example, using the following exec format, you can execute a shell to print the value stored in the GITHUB_SHA environment variable.\n\n```dockerfile\nENTRYPOINT [\"sh\", \"-c\", \"echo $GITHUB_SHA\"]\n```\n\nTo supply args defined in the action's metadata file to a Docker container that uses the exec form in the ENTRYPOINT, we recommend creating a shell script called entrypoint.sh that you call from the ENTRYPOINT instruction.\n\n## Example Dockerfile\n```dockerfile\n# Container image that runs your code\nFROM debian:9.5-slim\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Executes `entrypoint.sh` when the Docker container starts up\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n## Example entrypoint.sh file\nUsing the example Dockerfile above, GitHub will send the args configured in the action's metadata file as arguments to entrypoint.sh. Add the #!/bin/sh shebang at the top of the entrypoint.sh file to explicitly use the system's POSIX-compliant shell.\n\n```shell\n#!/bin/sh\n\n# `$#` expands to the number of arguments and `$@` expands to the supplied `args`\nprintf '%d args:' \"$#\"\nprintf \" '%s'\" \"$@\"\nprintf '\\n'\n```\n\nYour code must be executable. Make sure the entrypoint.sh file has execute permissions before using it in a workflow. You can modify the permission from your terminal using this command:\n\n```shell\nchmod +x entrypoint.sh\n```\n\nWhen an ENTRYPOINT shell script is not executable, you'll receive an error similar to this:\n\n```shell\nError response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused \"exec: \"/entrypoint.sh\": permission denied\": unknown\n```\n\n## CMD\nIf you define args in the action's metadata file, args will override the CMD instruction specified in the Dockerfile. For more information, see Metadata syntax for GitHub Actions.\n\nIf you use CMD in your Dockerfile, follow these guidelines:\n\n1. Document required arguments in the action's README and omit them from the CMD instruction.\n2. Use defaults that allow using the action without specifying any args.\n3. If the action exposes a --help flag, or something similar, use that to make your action self-documenting.\n\n## Supported Linux capabilities\nGitHub Actions supports the default Linux capabilities that Docker supports. Capabilities can't be added or removed. For more information about the default Linux capabilities that Docker supports, see Linux kernel capabilities in the Docker documentation. To learn more about Linux capabilities, see Overview of Linux capabilities in the Linux man-pages.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Dockerfile support for GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### ENTRYPOINT example without variable substitution\n```yaml\nENTRYPOINT [\"echo $GITHUB_SHA\"]\n```\n\n### ENTRYPOINT example with variable substitution\n```yaml\nENTRYPOINT [\"sh\", \"-c\", \"echo $GITHUB_SHA\"]\n```\n\n### Example Dockerfile\n```yaml\n# Container image that runs your code\nFROM debian:9.5-slim\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Executes `entrypoint.sh` when the Docker container starts up\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n### Example entrypoint.sh file\n```yaml\n#!/bin/sh\n\n# `$#` expands to the number of arguments and `$@` expands to the supplied `args`\nprintf '%d args:' \"$#\"\nprintf \" '%s'\" \"$@\"\nprintf '\\n'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Dockerfile support for GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• It's recommended to use official Docker images. For example, python or ruby.\n• Use a version tag if it exists, preferably with a major version. For example, use node:10 instead of node:latest.\n• It's recommended to use Docker images based on the Debian operating system.\n• Document required arguments in the action's README and omit them from the CMD instruction.\n• Use defaults that allow using the action without specifying any args.\n• If the action exposes a --help flag, or something similar, use that to make your action self-documenting.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing?\n\nAssistant: You can automatically build and test your projects with GitHub Actions.\n\nHere's a detailed explanation:\n\n\n## Building and testing Go\nYou can create a continuous integration (CI) workflow to build and test your Go project.\n\n## Building and testing Java with Ant\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Ant.\n\n## Building and testing Java with Gradle\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.\n\n## Building and testing Java with Maven\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Maven.\n\n## Building and testing .NET\nYou can create a continuous integration (CI) workflow to build and test your .NET project.\n\n## Building and testing Node.js\nYou can create a continuous integration (CI) workflow to build and test your Node.js project.\n\n## Building and testing PowerShell\nYou can create a continuous integration (CI) workflow to build and test your PowerShell project.\n\n## Building and testing Python\nYou can create a continuous integration (CI) workflow to build and test your Python project.\n\n## Building and testing Ruby\nYou can create a continuous integration (CI) workflow to build and test your Ruby project.\n\n## Building and testing Rust\nYou can create a continuous integration (CI) workflow to build and test your Rust project.\n\n## Building and testing Swift\nYou can create a continuous integration (CI) workflow to build and test your Swift project.\n\n## Building and testing Xamarin applications\nYou can create a continuous integration (CI) workflow in GitHub Actions to build and test your Xamarin application.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Controlling permissions for GITHUB_TOKEN?\n\nAssistant: Modify the default permissions granted to GITHUB_TOKEN.\n\nHere's a detailed explanation:\n\n\n## Overview\nYou can use `permissions` to modify the default permissions granted to the `GITHUB_TOKEN`, adding or removing access as required, so that you only allow the minimum required access. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).\n\nYou can use `permissions` either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the `permissions` key within a specific job, all actions and run commands within that job that use the `GITHUB_TOKEN` gain the access rights you specify. For more information, see [`jobs.<job_id>.permissions`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idpermissions).\n\nFor each of the available permissions, shown in the table below, you can assign one of the access levels: `read` (if applicable), `write`, or `none`. `write` includes `read`. If you specify the access for any of these permissions, all of those that are not specified are set to `none`.\n\nAvailable permissions and details of what each allows an action to do:\n\n| Permission | Allows an action using `GITHUB_TOKEN` to |\n| --- | --- |\n| `actions` | Work with GitHub Actions. For example, `actions: write` permits an action to cancel a workflow run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-actions). |\n| `attestations` | Work with artifact attestations. For example, `attestations: write` permits an action to generate an artifact attestation for a build. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) |\n| `checks` | Work with check runs and check suites. For example, `checks: write` permits an action to create a check run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-checks). |\n| `contents` | Work with the contents of the repository. For example, `contents: read` permits an action to list the commits, and `contents: write` allows the action to create a release. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-contents). |\n| `deployments` | Work with deployments. For example, `deployments: write` permits an action to create a new deployment. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-deployments). |\n| `discussions` | Work with GitHub Discussions. For example, `discussions: write` permits an action to close or delete a discussion. For more information, see [Using the GraphQL API for Discussions](https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions). |\n| `id-token` | Fetch an OpenID Connect (OIDC) token. This requires `id-token: write`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#updating-your-actions-for-oidc) |\n| `issues` | Work with issues. For example, `issues: write` permits an action to add a comment to an issue. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-issues). |\n| `packages` | Work with GitHub Packages. For example, `packages: write` permits an action to upload and publish packages on GitHub Packages. For more information, see [About permissions for GitHub Packages](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages#about-scopes-and-permissions-for-package-registries). |\n| `pages` | Work with GitHub Pages. For example, `pages: write` permits an action to request a GitHub Pages build. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pages). |\n| `pull-requests` | Work with pull requests. For example, `pull-requests: write` permits an action to add a label to a pull request. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pull-requests). |\n| `repository-projects` | Work with GitHub projects (classic). For example, `repository-projects: write` permits an action to add a column to a project (classic). For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-projects). |\n| `security-events` | Work with GitHub code scanning and Dependabot alerts. For example, `security-events: read` permits an action to list the Dependabot alerts for the repository, and `security-events: write` allows an action to update the status of a code scanning alert. For more information, see [Repository permissions for 'Code scanning alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-code-scanning-alerts) and [Repository permissions for 'Dependabot alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-dependabot-alerts) in \"Permissions required for GitHub Apps.\" |\n| `statuses` | Work with commit statuses. For example, `statuses:read` permits an action to list the commit statuses for a given reference. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-commit-statuses). |\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Controlling permissions for GITHUB_TOKEN?\n\nAssistant: Here are some code examples:\n\n### Defining access for the `GITHUB_TOKEN` permissions\n```yaml\npermissions:\n  actions: read|write|none\n  attestations: read|write|none\n  checks: read|write|none\n  contents: read|write|none\n  deployments: read|write|none\n  id-token: write|none\n  issues: read|write|none\n  discussions: read|write|none\n  packages: read|write|none\n  pages: read|write|none\n  pull-requests: read|write|none\n  repository-projects: read|write|none\n  security-events: read|write|none\n  statuses: read|write|none\n\nIf you specify the access for any of these permissions, all of those that are not specified are set to `none`.\n```\n\n### Setting the `GITHUB_TOKEN` permissions for an entire workflow\n```yaml\nname: \"My workflow\"\n\non: [ push ]\n\npermissions: read-all\n\njobs:\n  ...\n```\n\n### Setting the `GITHUB_TOKEN` permissions for one job in a workflow\n```yaml\njobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n      - uses: actions/stale@v9\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Controlling permissions for GITHUB_TOKEN?\n\nAssistant: Here are the recommended best practices:\n\n• You can use the `permissions` key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the **Send write tokens to workflows from pull requests** option in the GitHub Actions settings.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Security hardening for GitHub Actions?\n\nAssistant: Good security practices for using GitHub Actions features.\n\nHere's a detailed explanation:\n\n\n## Overview\nThis guide explains how to configure security hardening for certain GitHub Actions features. If the GitHub Actions concepts are unfamiliar, see Understanding GitHub Actions.\n\n## Using secrets\nSensitive values should never be stored as plaintext in workflow files, but rather as secrets. Secrets can be configured at the organization, repository, or environment level, and allow you to store sensitive information in GitHub.\n\nSecrets use Libsodium sealed boxes, so that they are encrypted before reaching GitHub. This occurs when the secret is submitted using the UI or through the REST API. This client-side encryption helps minimize the risks related to accidental logging (for example, exception logs and request logs, among others) within GitHub's infrastructure. Once the secret is uploaded, GitHub is then able to decrypt it so that it can be injected into the workflow runtime.\n\nTo help prevent accidental disclosure, GitHub uses a mechanism that attempts to redact any secrets that appear in run logs. This redaction looks for exact matches of any configured secrets used within the job, as well as common encodings of the values, such as Base64. However, because there are multiple ways a secret value can be transformed, this redaction is not guaranteed. Additionally, the runner can only redact secrets used within the current job. As a result, there are certain proactive steps and good practices you should follow to help ensure secrets are redacted, and to limit other risks associated with secrets:\n\n- **Never use structured data as a secret**\n  - Structured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.\n- **Register all secrets used within workflows**\n  - If a secret is used to generate another sensitive value within a workflow, that generated value should be formally registered as a secret, so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.\n  - Registering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.\n- **Audit how secrets are handled**\n  - Audit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.\n  - View the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors to STDOUT and STDERR, and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, see Using workflow run logs.\n- **Use credentials that are minimally scoped**\n  - Make sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.\n  - Actions can use the GITHUB_TOKEN by accessing it from the github.token context. For more information, see Accessing contextual information about workflow runs. You should therefore make sure that the GITHUB_TOKEN is granted the minimum required permissions. It's good security practice to set the default permission for the GITHUB_TOKEN to read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, see Automatic token authentication.\n- **Audit and rotate registered secrets**\n  - Periodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.\n  - Rotate secrets periodically to reduce the window of time during which a compromised secret is valid.\n- **Consider requiring review for access to secrets**\n  - You can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, see Using secrets in GitHub Actions and Managing environments for deployment.\n\nWarning\n\nAny user with write access to your repository has read access to all secrets configured in your repository. Therefore, you should ensure that the credentials being used within workflows have the least privileges required.\n\n## Using CODEOWNERS to monitor changes\nYou can use the CODEOWNERS feature to control how changes are made to your workflow files. For example, if all your workflow files are stored in .github/workflows, you can add this directory to the code owners list, so that any proposed changes to these files will first require approval from a designated reviewer.\n\n## Understanding the risk of script injections\nWhen creating workflows, custom actions, and composite actions, you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner.\n\nAttackers can add their own malicious content to the github context, which should be treated as potentially untrusted input. These contexts typically end with body, default_branch, email, head_ref, label, message, name, page_name, ref, and title. For example: github.event.issue.title, or github.event.pull_request.body.\n\nYou should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions.\n\nIn addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, zzz\";echo${IFS}\"hello\";# would be a valid branch name and would be a possible attack vector for a target repository.\n\n## Example of a script injection attack\nA script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:\n\n```yaml\n      - name: Check PR title\n        run: |\n          title=\"${{ github.event.pull_request.title }}\"\n          if [[ $title =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n\nThis example is vulnerable to script injection because the run command executes within a temporary shell script on the runner. Before the shell script is run, the expressions inside `${{ }}` are evaluated and then substituted with the resulting values, which can make it vulnerable to shell command injection.\n\nTo inject commands into this workflow, the attacker could create a pull request with a title of a\"; ls $GITHUB_WORKSPACE\":\n\n![Screenshot of the title of a pull request in edit mode. A new title has been entered in the field: a\"; ls $GITHUB_WORKSPACE\".](https://docs.github.com/assets/cb-25700/images/help/actions/example-script-injection-pr-title.png)\n\nIn this example, the \" character is used to interrupt the title=\"${{ github.event.pull_request.title }}\" statement, allowing the ls command to be executed on the runner. You can see the output of the ls command in the log:\n\n```shell\nRun title=\"a\"; ls $GITHUB_WORKSPACE\"\"\nREADME.md\ncode.yml\nexample.js\n```\n\n## Good practices for mitigating script injection attacks\nThere are a number of different approaches available to help you mitigate the risk of script injection:\n\n### Using an action instead of an inline script (recommended)\nThe recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:\n\n```yaml\nuses: fakeaction/checktitle@v3\nwith:\n    title: ${{ github.event.pull_request.title }}\n```\n\n### Using an intermediate environment variable\nFor inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable.\n\nThe following example uses Bash to process the github.event.pull_request.title value as an environment variable:\n\n```yaml\n      - name: Check PR title\n        env:\n          TITLE: ${{ github.event.pull_request.title }}\n        run: |\n          if [[ \"$TITLE\" =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n\nIn this example, the attempted script injection is unsuccessful, which is reflected by the following lines in the log:\n\n```shell\n   env:\n     TITLE: a\"; ls $GITHUB_WORKSPACE\"\nPR title did not start with 'octocat'\n```\n\nWith this approach, the value of the `${{ github.event.issue.title }}` expression is stored in memory and used as a variable, and doesn't interact with the script generation process. In addition, consider using double quote shell variables to avoid word splitting, but this is one of many general recommendations for writing shell scripts, and is not specific to GitHub Actions.\n\n## Using workflow templates for code scanning\nNote\n\nWorkflow templates for Advanced Security have been consolidated in a \"Security\" category in the Actions tab of a repository.\nCode scanning allows you to find security vulnerabilities before they reach production. GitHub provides workflow templates for code scanning. You can use these suggested workflows to construct your code scanning workflows, instead of starting from scratch. GitHub's workflow, the CodeQL analysis workflow, is powered by CodeQL. There are also third-party workflow templates available.\n\n## Restricting permissions for tokens\nTo help mitigate the risk of an exposed token, consider restricting the assigned permissions. For more information, see Automatic token authentication.\n\n## Using OpenID Connect to access cloud resources\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits.\n\n## Using third-party actions\nThe individual jobs in a workflow can interact with (and compromise) other jobs. For example, a job querying the environment variables used by a later job, writing files to a shared directory that a later job processes, or even more directly by interacting with the Docker socket and inspecting other running containers and executing commands in them.\n\nThis means that a compromise of a single action within a workflow can be very significant, as that compromised action would have access to all secrets configured on your repository, and may be able to use the GITHUB_TOKEN to write to the repository. Consequently, there is significant risk in sourcing actions from third-party repositories on GitHub. You can help mitigate this risk by following these good practices:\n\n- **Pin actions to a full length commit SHA**\n\nPinning an action to a full length commit SHA is currently the only way to use an action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\n\n- **Audit the source code of the action**\n\nEnsure that the action is handling the content of your repository and secrets as expected. For example, check that secrets are not sent to unintended hosts, or are not inadvertently logged.\n\n- **Pin actions to a tag only if you trust the creator**\n\nAlthough pinning to a commit SHA is the most secure option, specifying a tag is more convenient and is widely used. If you’d like to specify a tag, then be sure that you trust the action's creators. The ‘Verified creator’ badge on GitHub Marketplace is a useful signal, as it indicates that the action was written by a team whose identity has been verified by GitHub. Note that there is risk to this approach even if you trust the author, because a tag can be moved or deleted if a bad actor gains access to the repository storing the action.\n\n## Reusing third-party workflows\nThe same principles described above for using third-party actions also apply to using third-party workflows. You can help mitigate the risks associated with reusing workflows by following the same good practices outlined above.\n\n## Using Dependabot version updates to keep actions up to date\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable.\n\n## Preventing GitHub Actions from creating or approving pull requests\nYou can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests. Allowing workflows, or any other automation, to create or approve pull requests could be a security risk if the pull request is merged without proper oversight.\n\n## Using code scanning to secure workflows\nNote\n\nThe ability to use code scanning to find vulnerabilities in GitHub Actions workflows is currently in public preview and subject to change.\n\n## Using OpenSSF Scorecards to secure workflow dependencies\nScorecards is an automated security tool that flags risky supply chain practices. You can use the Scorecards action and workflow template to follow best security practices.\n\n## Potential impact of a compromised runner\nThese sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner.\n\n## Accessing secrets\nWorkflows triggered from a forked repository using the pull_request event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as issue_comment, issues, push and pull_request from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's GITHUB_TOKEN.\n\n- If the secret or token is set to an environment variable, it can be directly accessed through the environment using printenv.\n\n- If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible.\n\n- For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:\n\n```yaml\nuses: fakeaction/publish@v3\nwith:\n      key: ${{ secrets.PUBLISH_KEY }}\n```\n\nAlthough GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the GITHUB_TOKEN and any referenced secrets can be harvested by a determined attacker.\n\n## Exfiltrating data from a runner\nAn attacker can exfiltrate any stolen secrets or other data from the runner. To help prevent accidental secret disclosure, GitHub Actions automatically redact secrets printed to the log, but this is not a true security boundary because secrets can be intentionally sent to the log.\n\n## Stealing the job's GITHUB_TOKEN\nIt is possible for an attacker to steal a job's GITHUB_TOKEN. The GitHub Actions runner automatically receives a generated GITHUB_TOKEN with permissions that are limited to just the repository that contains the workflow, and the token expires after the job has completed.\n\n## Modifying the contents of a repository\nThe attacker server can use the GitHub API to modify repository content, including releases, if the assigned permissions of GITHUB_TOKEN are not restricted.\n\n## Considering cross-repository access\nGitHub Actions is intentionally scoped for a single repository at a time. The GITHUB_TOKEN grants the same level of access as a write-access user, because any write-access user can access this token by creating or modifying a workflow file, elevating the permissions of the GITHUB_TOKEN if necessary.\n\n## Hardening for GitHub-hosted runners\nGitHub-hosted runners take measures to help you mitigate security risks.\n\n## Reviewing the supply chain for GitHub-hosted runners\nFor GitHub-hosted runners created from images maintained by GitHub, you can view a software bill of materials (SBOM) to see what software was pre-installed on the runner.\n\n## Denying access to hosts\nGitHub-hosted runners are provisioned with an etc/hosts file that blocks network access to various cryptocurrency mining pools and malicious sites.\n\n## Hardening for self-hosted runners\nGitHub-hosted runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.\n\n## Using just-in-time runners\nTo improve runner registration security, you can use the REST API to create ephemeral, just-in-time (JIT) runners.\n\n## Planning your management strategy for self-hosted runners\nA self-hosted runner can be added to various levels in your GitHub hierarchy: the enterprise, organization, or repository level.\n\n## Authenticating to your cloud provider\nIf you are using GitHub Actions to deploy to a cloud provider, or intend to use HashiCorp Vault for secret management, then its recommended that you consider using OpenID Connect to create short-lived, well-scoped access tokens for your workflow runs.\n\n## Auditing GitHub Actions events\nYou can use the security log to monitor activity for your user account and the audit log to monitor activity in your organization.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Security hardening for GitHub Actions?\n\nAssistant: Here are some code examples:\n\n### Example of a script injection attack\n```yaml\n```yaml\n      - name: Check PR title\n        run: |\n          title=\"${{ github.event.pull_request.title }}\"\n          if [[ $title =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n```\n\n### Good practices for mitigating script injection attacks - Using an action instead of an inline script\n```yaml\n```yaml\nuses: fakeaction/checktitle@v3\nwith:\n    title: ${{ github.event.pull_request.title }}\n```\n```\n\n### Good practices for mitigating script injection attacks - Using an intermediate environment variable\n```yaml\n```yaml\n      - name: Check PR title\n        env:\n          TITLE: ${{ github.event.pull_request.title }}\n        run: |\n          if [[ \"$TITLE\" =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi\n```\n```\n\n### Accessing secrets\n```yaml\n```yaml\nuses: fakeaction/publish@v3\nwith:\n      key: ${{ secrets.PUBLISH_KEY }}\n```\n```\n\n### Using just-in-time runners\n```yaml\n```shell\n./run.sh --jitconfig ${encoded_jit_config}\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Security hardening for GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• Never use structured data as a secret\n• Register all secrets used within workflows\n• Audit how secrets are handled\n• Use credentials that are minimally scoped\n• Audit and rotate registered secrets\n• Consider requiring review for access to secrets\n• Pin actions to a full length commit SHA\n• Audit the source code of the action\n• Pin actions to a tag only if you trust the creator\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating a JavaScript action?\n\nAssistant: In this guide, you'll learn how to build a JavaScript action using the actions toolkit.\n\nHere's a detailed explanation:\n\n\n## Introduction\nIn this guide, you'll learn about the basic components needed to create and use a packaged JavaScript action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" in the logs or \"Hello [who-to-greet]\" if you provide a custom name.\n\nThis guide uses the GitHub Actions Toolkit Node.js module to speed up development. For more information, see the actions/toolkit repository.\n\nOnce you complete this project, you should understand how to build your own JavaScript action and test it in a workflow.\n\nTo ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image.\n\nWarning\n\nWhen creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.\n\n## Prerequisites\nBefore you begin, you'll need to download Node.js and create a public GitHub repository.\n\n1. Download and install Node.js 20.x, which includes npm.\n\nhttps://nodejs.org/en/download/\n\n2. Create a new public repository on GitHub and call it \"hello-world-javascript-action\". For more information, see Creating a new repository.\n\n3. Clone your repository to your computer. For more information, see Cloning a repository.\n\n4. From your terminal, change directories into your new repository.\n\n```shell\ncd hello-world-javascript-action\n```\n\n5. From your terminal, initialize the directory with npm to generate a `package.json` file.\n\n```shell\nnpm init -y\n```\n\n## Creating an action metadata file\nCreate a new file named `action.yml` in the `hello-world-javascript-action` directory with the following example code. For more information, see Metadata syntax for GitHub Actions.\n\n```yaml\nname: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'node20'\n  main: 'index.js'\n``` \n\nThis file defines the `who-to-greet` input and `time` output. It also tells the action runner how to start running this JavaScript action.\n\n## Adding actions toolkit packages\nThe actions toolkit is a collection of Node.js packages that allow you to quickly build JavaScript actions with more consistency.\n\nThe toolkit `@actions/core` package provides an interface to the workflow commands, input and output variables, exit statuses, and debug messages.\n\nThe toolkit also offers a `@actions/github` package that returns an authenticated Octokit REST client and access to GitHub Actions contexts.\n\nThe toolkit offers more than the `core` and `github` packages. For more information, see the actions/toolkit repository.\n\nAt your terminal, install the actions toolkit `core` and `github` packages.\n\n```shell\nnpm install @actions/core\nnpm install @actions/github\n```\n\nNow you should see a `node_modules` directory with the modules you just installed and a `package-lock.json` file with the installed module dependencies and the versions of each installed module.\n\n## Writing the action code\nThis action uses the toolkit to get the `who-to-greet` input variable required in the action's metadata file and prints \"Hello [who-to-greet]\" in a debug message in the log. Next, the script gets the current time and sets it as an output variable that actions running later in a job can use.\n\nGitHub Actions provide context information about the webhook event, Git refs, workflow, action, and the person who triggered the workflow. To access the context information, you can use the `github` package. The action you'll write will print the webhook event payload to the log.\n\nAdd a new file called `index.js`, with the following code.\n\n```javascript\nconst core = require('@actions/core');\nconst github = require('@actions/github');\n\ntry {\n  // `who-to-greet` input defined in action metadata file\n  const nameToGreet = core.getInput('who-to-greet');\n  console.log(`Hello ${nameToGreet}!`);\n  const time = (new Date()).toTimeString();\n  core.setOutput(\"time\", time);\n  // Get the JSON webhook payload for the event that triggered the workflow\n  const payload = JSON.stringify(github.context.payload, undefined, 2)\n  console.log(`The event payload: ${payload}`);\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n\nIf an error is thrown in the above `index.js` example, `core.setFailed(error.message);` uses the actions toolkit `@actions/core` package to log a message and set a failing exit code. For more information, see Setting exit codes for actions.\n\n## Creating a README\nTo let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action.\n\nIn your `hello-world-javascript-action` directory, create a `README.md` file that specifies the following information:\n\n- A detailed description of what the action does.\n- Required input and output arguments.\n- Optional input and output arguments.\n- Secrets the action uses.\n- Environment variables the action uses.\n- An example of how to use your action in a workflow.\n\n```markdown\n# Hello world javascript action\n\nThis action prints \"Hello World\" or \"Hello\" + the name of a person to greet to the log.\n\n## Inputs\n\n### `who-to-greet`\n\n**Required** The name of the person to greet. Default \"World\".\n\n## Outputs\n\n### `time`\n\nThe time we greeted you.\n\n## Example usage\n\n```yaml\nuses: actions/hello-world-javascript-action@e76147da8e5c81eaf017dede5645551d4b94427b\nwith:\nwho-to-greet: 'Mona the Octocat'\n```\n```\n\n## Commit, tag, and push your action\nGitHub downloads each action run in a workflow during runtime and executes it as a complete package of code before you can use workflow commands like `run` to interact with the runner machine. This means you must include any package dependencies required to run the JavaScript code. You'll need to check in the toolkit `core` and `github` packages to your action's repository.\n\nFrom your terminal, commit your `action.yml`, `index.js`, `node_modules`, `package.json`, `package-lock.json`, and `README.md` files. If you added a `.gitignore` file that lists `node_modules`, you'll need to remove that line to commit the `node_modules` directory.\n\nIt's best practice to also add a version tag for releases of your action. For more information on versioning your action, see About custom actions.\n\n```shell\ngit add action.yml index.js node_modules/* package.json package-lock.json README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tags\n```\n\nChecking in your `node_modules` directory can cause problems. As an alternative, you can use a tool called `@vercel/ncc` to compile your code and modules into one file used for distribution.\n\n1. Install `vercel/ncc` by running this command in your terminal.\n\n`npm i -g @vercel/ncc`\n\n2. Compile your `index.js` file.\n\n`ncc build index.js --license licenses.txt`\n\nYou'll see a new `dist/index.js` file with your code and the compiled modules. You will also see an accompanying `dist/licenses.txt` file containing all the licenses of the `node_modules` you are using.\n\n3. Change the `main` keyword in your `action.yml` file to use the new `dist/index.js` file.\n\n`main: 'dist/index.js'`\n\n4. If you already checked in your `node_modules` directory, remove it.\n\n`rm -rf node_modules/*`\n\n5. From your terminal, commit the updates to your `action.yml`, `dist/index.js`, and `node_modules` files.\n\n```shell\ngit add action.yml dist/index.js node_modules/*\ngit commit -m \"Use vercel/ncc\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tags\n```\n\n## Testing out your action in a workflow\nNow you're ready to test your action out in a workflow.\n\nPublic actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, see Managing GitHub Actions settings for a repository.\n\n### Example using a public action\n\nThis example demonstrates how your new public action can be run from within an external repository.\n\nCopy the following YAML into a new file at `.github/workflows/main.yml`, and update the `uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b` line with your username and the name of the public repository you created above. You can also replace the `who-to-greet` input with your name.\n\n```yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n```\n\nWhen this workflow is triggered, the runner will download the `hello-world-javascript-action` action from your public repository and then execute it.\n\n### Example using a private action\n\nCopy the workflow code into a `.github/workflows/main.yml` file in your action's repository. You can also replace the `who-to-greet` input with your name.\n\n**.github/workflows/main.yml**\n\n```yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      # To use this repository's private action,\n      # you must check out the repository\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Hello world action step\n        uses: ./ # Uses an action in the root directory\n        id: hello\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n```\n\nFrom your repository, click the **Actions** tab, and select the latest workflow run. Under **Jobs** or in the visualization graph, click **A job to say hello**.\n\nClick **Hello world action step**, and you should see \"Hello Mona the Octocat\" or the name you used for the `who-to-greet` input printed in the log. To see the timestamp, click **Get the output time**.\n\n## Template repositories for creating JavaScript actions\nGitHub provides template repositories for creating JavaScript and TypeScript actions. You can use these templates to quickly get started with creating a new action that includes tests, linting, and other recommended practices.\n\n- javascript-action template repository\n- typescript-action template repository\n\n## Example JavaScript actions on GitHub.com\nYou can find many examples of JavaScript actions on GitHub.com.\n\n- DevExpress/testcafe-action\n- duckduckgo/privacy-configuration\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating a JavaScript action?\n\nAssistant: Here are some code examples:\n\n### Creating an action metadata file\n```yaml\n```yaml\nname: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'node20'\n  main: 'index.js'\n```\n```\n\n### Writing the action code\n```yaml\n```javascript\nconst core = require('@actions/core');\nconst github = require('@actions/github');\n\ntry {\n  // `who-to-greet` input defined in action metadata file\n  const nameToGreet = core.getInput('who-to-greet');\n  console.log(`Hello ${nameToGreet}!`);\n  const time = (new Date()).toTimeString();\n  core.setOutput(\"time\", time);\n  // Get the JSON webhook payload for the event that triggered the workflow\n  const payload = JSON.stringify(github.context.payload, undefined, 2)\n  console.log(`The event payload: ${payload}`);\n} catch (error) {\n  core.setFailed(error.message);\n}\n```\n```\n\n### Creating a README\n```yaml\n```markdown\n# Hello world javascript action\n\nThis action prints \"Hello World\" or \"Hello\" + the name of a person to greet to the log.\n\n## Inputs\n\n### `who-to-greet`\n\n**Required** The name of the person to greet. Default \"World\".\n\n## Outputs\n\n### `time`\n\nThe time we greeted you.\n\n## Example usage\n\n```yaml\nuses: actions/hello-world-javascript-action@e76147da8e5c81eaf017dede5645551d4b94427b\nwith:\nwho-to-greet: 'Mona the Octocat'\n```\n```\n```\n\n### Commit, tag, and push your action\n```yaml\n```shell\ngit add action.yml index.js node_modules/* package.json package-lock.json README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tags\n```\n```\n\n### Testing out your action in a workflow\n```yaml\n```yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating a JavaScript action?\n\nAssistant: Here are the recommended best practices:\n\n• Always consider whether your code might execute untrusted input from possible attackers.\n• It's best practice to add a version tag for releases of your action.\n• Checking in your `node_modules` directory can cause problems. Use a tool like `@vercel/ncc` to compile your code and modules into one file used for distribution.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Enforcing artifact attestations with a Kubernetes admission controller?\n\nAssistant: Use an admission controller to enforce artifact attestations in your Kubernetes cluster.\n\nHere's a detailed explanation:\n\n\n## In this article\nNote\n\nBefore proceeding, ensure you have enabled build provenance for container images, including setting the `push-to-registry` attribute in the [`attest-build-provenance` action](https://github.com/actions/attest-build-provenance) as documented in [Generating build provenance for container images](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds#generating-build-provenance-for-container-images). This is required for the Policy Controller to verify the attestation.\n\n## About Kubernetes admission controller\n[Artifact attestations](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.\n\nKubernetes admission controllers are plugins that govern the behavior of the Kubernetes API server. They are commonly used to enforce security policies and best practices in a Kubernetes cluster.\n\nUsing the open source [Sigstore Policy Controller](https://docs.sigstore.dev/policy-controller/overview/) project you can add an admission controller to your Kubernetes cluster that can enforce artifact attestations. This way, you can ensure that only artifacts with valid attestations can be deployed.\n\nTo [install the controller](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller#getting-started-with-kubernetes-admission-controller), we offer [two Helm charts](https://github.com/github/artifact-attestations-helm-charts): one for deploying the Sigstore Policy Controller, and another for loading the GitHub trust root and a default policy.\n\n## About image verification\nWhen the Policy Controller is installed, it will intercept all image pull requests and verify the attestation for the image. The attestation must be stored in the image registry as an [OCI attached artifact](https://oras.land/docs/concepts/reftypes/) containing a [Sigstore Bundle](https://docs.sigstore.dev/about/bundle/) which contains the attestation and cryptographic material (e.g. certificates and signatures) used to verify the attestation. A verification process is then performed that ensures the image was built with the specified build provenance and matches any policies enabled by the cluster administrator.\n\nIn order for an image to be verifiable, it must have a valid provenance attestation in the registry, which can be done by enabling the `push-to-registry: true` attribute in the `actions/attest-build-provenance` action. See [Generating build provenance for container images](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds#generating-build-provenance-for-container-images) for more details on how to generate attestations for container images.\n\n## About trust roots and policies\nThe Sigstore Policy Controller is primarily configured with trust roots and policies, represented by the Custom Resources `TrustRoot` and `ClusterImagePolicy`. A `TrustRoot` represents a trusted distribution channel for the public key material used to verify attestations. A `ClusterImagePolicy` represents a policy for enforcing attestations on images.\n\nA `TrustRoot` may also contain a [TUF](https://theupdateframework.io/) repository root, making it possible for your cluster to continuously and securely receive updates to its trusted public key material. If left unspecified, a `ClusterImagePolicy` will by default use the open source Sigstore Public Good Instance's key material. When verifying attestations generated for private repositories, the `ClusterImagePolicy` must reference the GitHub `TrustRoot`.\n\n## Getting started with Kubernetes admission controller\nTo set up an admission controller for enforcing GitHub artifact attestations, you need to:\n\n1. [Deploy the Sigstore Policy Controller](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller#deploy-the-sigstore-policy-controller).\n2. [Add the GitHub `TrustRoot` and a `ClusterImagePolicy` to your cluster](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller#add-the-github-trustroot-and-a-clusterimagepolicy).\n3. [Enable the policy in your namespace](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller#enable-the-policy-in-your-namespace).\n\n## Deploy the Sigstore Policy Controller\nWe have packaged the Sigstore Policy Controller as a [GitHub distributed Helm chart](https://github.com/github/artifact-attestations-helm-charts). Before you begin, ensure you have the following prerequisites:\n\n- A Kubernetes cluster with version 1.27 or later\n- [Helm](https://helm.sh/docs/intro/install/) 3.0 or later\n- [kubectl](https://kubernetes.io/docs/tasks/tools/)\n\nFirst, install the Helm chart that deploys the Sigstore Policy Controller:\n\n```hljs bash\nhelm upgrade policy-controller --install --atomic \\\n  --create-namespace --namespace artifact-attestations \\\n  oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller \\\n  --version v0.12.0-github10\n``` \n\nThis installs the Policy Controller into the `artifact-attestations` namespace. At this point, no policies have been configured, and it will not enforce any attestations.\n\n## Add the GitHub `TrustRoot` and a `ClusterImagePolicy`\nOnce the policy controller has been deployed, you need to add the GitHub `TrustRoot` and a `ClusterImagePolicy` to your cluster. Use the Helm chart we provide to do this. Make sure to replace `MY-ORGANIZATION` with your GitHub organization's name (e.g., `github` or `octocat-inc`).\n\n```hljs bash\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION\n```\n\nYou've now installed the GitHub trust root, and an artifact attestation policy into your cluster. This policy will reject artifacts that have not originated from within your GitHub organization.\n\n## Enable the policy in your namespace\nWarning\n\nThis policy will not be enforced until you specify which namespaces it should apply to.\n\nEach namespace in your cluster can independently enforce policies. To enable enforcement in a namespace, you can add the following label to the namespace:\n\n```hljs yaml\nmetadata:\n  labels:\n    policy.sigstore.dev/include: \"true\"\n```\n\nAfter the label is added, the GitHub artifact attestation policy will be enforced in the namespace.\n\nAlternatively, you may run:\n\n```hljs bash\nkubectl label namespace MY-NAMESPACE policy.sigstore.dev/include=true\n```\n\n## Matching images\nBy default, the policy installed with the `trust-policies` Helm chart will verify attestations for all images before admitting them into the cluster. If you only intend to enforce attestations for a subset of images, you can use the Helm values `policy.images` and `policy.exemptImages` to specify a list of images to match against. These values can be set to a list of glob patterns that match the image names. The globbing syntax uses Go [filepath](https://pkg.go.dev/path/filepath#Match) semantics, with the addition of `**` to match any character sequence, including slashes.\n\nFor example, to enforce attestations for images that match the pattern `ghcr.io/MY-ORGANIZATION/*` and admit `busybox` without a valid attestation, you can run:\n\n```hljs bash\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION \\\n --set-json 'policy.exemptImages=[\"index.docker.io/library/busybox**\"]' \\\n --set-json 'policy.images=[\"ghcr.io/MY-ORGANIZATION/**\"]'\n```\n\nAll patterns must use the fully-qualified name, even if the images originate from Docker Hub. In this example, if we want to exempt the image `busybox`, we must provide the full name including the domain and double-star glob to match all image versions: `index.docker.io/library/busybox**`.\n\nNote that any image you intend to admit _must_ have a matching glob pattern in the `policy.images` list. If an image does not match any pattern, it will be rejected. Additionally, if an image matches both `policy.images` and `policy.exemptImages`, it will be rejected.\n\n## Advanced usage\nTo see the full set of options you may configure with the Helm chart, you can run either of the following commands.\nFor policy controller options:\n\n```hljs bash\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller --version v0.12.0-github10\n```\n\nFor trust policy options:\n\n```hljs bash\nhelm show values oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies --version v0.6.2\n```\n\nFor more information on the Sigstore Policy Controller, see the [Sigstore Policy Controller documentation](https://docs.sigstore.dev/policy-controller/overview/).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Enforcing artifact attestations with a Kubernetes admission controller?\n\nAssistant: Here are some code examples:\n\n### Deploy the Sigstore Policy Controller\n```yaml\nhelm upgrade policy-controller --install --atomic \\\n  --create-namespace --namespace artifact-attestations \\\n  oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller \\\n  --version v0.12.0-github10\n```\n\n### Add the GitHub `TrustRoot` and a `ClusterImagePolicy`\n```yaml\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION\n```\n\n### Enable the policy in your namespace\n```yaml\nmetadata:\n  labels:\n    policy.sigstore.dev/include: \"true\"\n```\n\n### Enable the policy in your namespace (kubectl)\n```yaml\nkubectl label namespace MY-NAMESPACE policy.sigstore.dev/include=true\n```\n\n### Matching images\n```yaml\nhelm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION \\\n --set-json 'policy.exemptImages=[\"index.docker.io/library/busybox**\"]' \\\n --set-json 'policy.images=[\"ghcr.io/MY-ORGANIZATION/**\"]'\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Enforcing artifact attestations with a Kubernetes admission controller?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure you have enabled build provenance for container images before proceeding.\n• Use the `push-to-registry: true` attribute in the `actions/attest-build-provenance` action to generate valid provenance attestations.\n• Specify which namespaces the policy should apply to by adding the appropriate label.\n• Use fully-qualified names for image patterns in the `policy.images` list.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Choosing what your workflow does?\n\nAssistant: Workflows automate tasks in your software development lifecycle. Many tasks that you manually complete can be converted to a GitHub Actions workflow.\n\nHere's a detailed explanation:\n\n\n## Using jobs in a workflow\nUse workflows to run multiple jobs.\n\n## Using pre-written building blocks in your workflow\nActions are the building blocks that power your workflow. A workflow can contain actions created by the community, or you can create your own actions directly within your application's repository. This guide will show you how to discover, use, and customize actions.\n\n## Using GitHub CLI in workflows\nYou can script with GitHub CLI in GitHub Actions workflows.\n\n## Workflow commands for GitHub Actions\nYou can use workflow commands when running shell commands in a workflow or in an action's code.\n\n## Adding scripts to your workflow\nYou can use GitHub Actions workflows to run scripts.\n\n## Controlling permissions for GITHUB_TOKEN\nModify the default permissions granted to `GITHUB_TOKEN`.\n\n## Evaluate expressions in workflows and actions\nYou can evaluate expressions in workflows and actions.\n\n## Store information in variables\nGitHub sets default variables for each GitHub Actions workflow run. You can also set custom variables for use in a single workflow or multiple workflows.\n\n## Accessing contextual information about workflow runs\nYou can access context information in workflows and actions.\n\n## Passing information between jobs\nYou can define outputs to pass information from one job to another.\n\n## Setting a default shell and working directory\nDefine the default settings that will apply to all jobs in the workflow, or all steps in a job.\n\n## Using environments for deployment\nSpecify a deployment environment in your workflow.\n\n## Control the concurrency of workflows and jobs\nRun a single job at a time.\n\n## Running variations of jobs in a workflow\nCreate a matrix to define variations for each job.\n\n## Caching dependencies to speed up workflows\nTo make your workflows faster and more efficient, you can create and use caches for dependencies and other commonly reused files.\n\n## Storing and sharing data from a workflow\nArtifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is About larger runners?\n\nAssistant: GitHub offers runners with advanced features to support more customized use cases.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nLarger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n\n## Overview of larger runners\nCustomers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than the standard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:\n\n- More RAM, CPU, and disk space\n- Static IP addresses\n- Azure private networking\n- The ability to group runners\n- Autoscaling to support concurrent workflows\n- GPU-powered and ARM-powered runners\n\nThese larger runners are hosted by GitHub and have the runner application and other tools preinstalled.\n\nGitHub offers larger runners with macOS, Ubuntu, or Windows operating systems, and different features and sizes are available depending on which operating system you use. For more information, see Additional features for larger runners.\n\n## About Ubuntu and Windows larger runners\nLarger runners with Ubuntu or Windows operating systems are configured in your organization or enterprise. When you add a larger runner, you are defining a type of machine from a selection of available hardware specifications and operating system images. GitHub will then create multiple instances of this runner that scale up and down to match the job demands of your organization, based on the autoscaling limits you define. For more information, see Managing larger runners.\n\nUbuntu and Windows larger runners offer autoscaling capabilities and the ability to assign the runners static IP addresses from a specific range. They can also be managed using runner groups, which enables you to control access to the larger runners.\n\n## About macOS larger runners\nLarger runners with a macOS operating system are used by updating the YAML workflow label to the desired runner image. To run your workflows on a macOS larger runner, update the `runs-on` key to use one of the GitHub-defined macOS larger runner labels. No additional configuration is required. For more information, see Running jobs on larger runners.\n\nThe following machines sizes are available for macOS larger runners.\n\n| Runner Size | Architecture | Processor (CPU) | Memory (RAM) | Storage (SSD) | Workflow label |\n| --- | --- | --- | --- | --- | --- |\n| Large | Intel | 12 | 30 GB | 14 GB | `macos-latest-large`, `macos-13-large`, `macos-14-large` [latest], `macos-15-large` [Public preview] |\n| XLarge | arm64 (M1) | 6 (+ 8 GPU hardware acceleration) | 14 GB | 14 GB | `macos-latest-xlarge`, `macos-13-xlarge`, `macos-14-xlarge` [latest], `macos-15-xlarge` [Public preview] |\n\n## Limitations for macOS larger runners\n- All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\n- Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\n- Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\n- The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically `4203018E-580F-C1B5-9525-B745CECA79EB`. If you are building and signing on the same host you plan to test the build on, you can sign with a development provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account.\n\n## Additional features for larger runners\nCompared to standard GitHub-hosted runners, larger runners have additional features, and their availability varies depending on the larger runner's operating system.\n\n|  | Ubuntu | Windows | macOS |\n| --- | --- | --- | --- |\n| Static IP addresses |  |  |  |\n| Azure private networking |  |  |  |\n| Autoscaling |  |  |  |\n| Runner groups |  |  |  |\n\nThese features can enhance your CI/CD pipelines in the following ways.\n\n- Assigning larger runners static IP addresses from a specific range enables you to use this range to configure a firewall allowlist. For more information, see Networking for larger runners.\n- Autoscaling enables larger runners to scale up to a maximum limit set by you, so your workflows can run concurrently. For more information, see Autoscaling larger runners.\n- Runner groups allow you to control access to larger runners for your organizations, repositories, and workflows. For more information, see Controlling access to larger runners.\n\n## Runner images\nLarger runners run on virtual machines (VMs), and GitHub installs a virtual hard disk (VHD) on this machine during the VM creation process. You can choose from different VM images to install on your runners.\n\n**GitHub-owned images:** These images are maintained by GitHub and are available for Linux x64, Windows x64, and macOS (x64 and arm) runners. For more information on these images and a full list of included tools for each runner operating system, see the GitHub Actions Runner Images repository.\n\n**Partner Images:** Partner images are not managed by GitHub and are pulled from the Azure Marketplace. For more information about the Windows 11 desktop image see Microsoft Windows 11 Desktop and for more information about the GPU runner compatible images, see NVIDIA GPU-Optimized VMI and Data Science Virtual Machine - Windows 2019. For more information about the images for ARM-powered runners, see the actions/partner-runner-images repository. This is also the place to provide feedback or report issues about third-party images.\n\n## Understanding billing\nLarger runners are not eligible for the use of included minutes on private repositories. For both private and public repositories, when larger runners are in use, they will always be billed at the per-minute rate.\n\nCompared to standard GitHub-hosted runners, larger runners are billed differently. Larger runners are only billed at the per-minute rate for the amount of time workflows are executed on them. There is no cost associated with creating a larger runner that is not being used by a workflow. For more information, see About billing for GitHub Actions.\n\n## Machine sizes for larger runners\nYou can choose from several specifications for larger runners.\n\n## Specifications for general larger runners\n| CPU | Memory (RAM) | Storage (SSD) | Architecture | Operating system (OS) |\n| --- | --- | --- | --- | --- |\n| 6 | 14 GB | 14 GB | arm64 | macOS |\n| 12 | 30 GB | 14 GB | x64 | macOS |\n| 2 | 8 GB | 75 GB | x64, arm64 | Ubuntu |\n| 4 | 16 GB | 150 GB | x64, arm64 | Ubuntu, Windows |\n| 8 | 32 GB | 300 GB | x64, arm64 | Ubuntu, Windows |\n| 16 | 64 GB | 600 GB | x64, arm64 | Ubuntu, Windows |\n| 32 | 128 GB | 1200 GB | x64, arm64 | Ubuntu, Windows |\n| 64 | 208 GB | 2040 GB | arm64 | Ubuntu, Windows |\n| 64 | 256 GB | 2040 GB | x64 | Ubuntu, Windows |\n\nNote: The 4-vCPU Windows runner only works with the Windows Server 2025 or Windows 11 Desktop image.\n\n## Specifications for GPU larger runners\n| CPU | GPU | GPU card | Memory (RAM) | GPU memory (VRAM) | Storage (SSD) | Operating system (OS) |\n| --- | --- | --- | --- | --- | --- | --- |\n| 4 | 1 | Tesla T4 | 28 GB | 16 GB | 176 GB | Ubuntu, Windows |\n\n## About runner groups\nOnly larger runners with Linux or Windows operating systems can be assigned to runner groups.\n\nRunner groups enable administrators to control access to runners at the organization and enterprise levels. With runner groups, you can collect sets of runners and create a security boundary around them. You can then decide which organizations or repositories are permitted to run jobs on those sets of machines. During the larger runner deployment process, the runner can be added to an existing group, otherwise it will join a default group.\n\n## Architectural overview of larger runners\nThis architecture diagram only applies to larger runners with Linux or Windows operating systems.\n\nLarger runners are managed at the organization level, where they are arranged into groups that can contain multiple instances of the runner. They can also be created at the enterprise level and shared with organizations in the hierarchy. Once you've created a group, you can then add a runner to the group and update your workflows to target either the group name or the label assigned to the larger runner.\n\n## Autoscaling larger runners\nAutoscaling is only available for larger runners with Linux or Windows operating systems.\n\nLarger runners can automatically scale to suit your needs. You can provision machines to run a specified maximum number of jobs when jobs are submitted for processing. Each machine only handles one job at a time, so these settings effectively determine the number of jobs that can be run concurrently.\n\n## Assigning static IP addresses to larger runners\nYou can assign static IP addresses only to larger runners that use Linux or Windows operating systems.\n\nStatic IP addresses assigned are all usable and are not in CIDR notation.\n\n## Networking for larger runners\nBy default, larger runners receive a dynamic IP address that changes for each job run. Optionally, GitHub Enterprise Cloud customers can configure their larger runners to receive static IP addresses from GitHub's IP address pool.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for About larger runners?\n\nAssistant: Here are the recommended best practices:\n\n• Larger runners are only available for organizations and enterprises using the GitHub Team or GitHub Enterprise Cloud plans.\n• All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.\n• Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.\n• Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Viewing job execution time?\n\nAssistant: You can view the execution time of a job, including the billable minutes that a job accrued.\n\nHere's a detailed explanation:\n\n\n## Overview\nBillable job execution minutes are only shown for jobs run on private repositories that use GitHub-hosted runners and are rounded up to the next minute. There are no billable minutes when using GitHub Actions in public repositories or for jobs run on self-hosted runners.\n\n## Steps to View Job Execution Time\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the run to see the workflow run summary.\n\n5. Under the job summary, you can view the job's execution time.\n\n6. To view details about the billable job execution time, in the left sidebar under \"Run details\", click **Usage**.\n\n## Notes\nThe billable time shown does not include any minute multipliers. To view your total GitHub Actions usage, including minute multipliers, see [Viewing your GitHub Actions usage](https://docs.github.com/en/billing/managing-billing-for-github-actions/viewing-your-github-actions-usage).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Managing deployments?\n\nAssistant: View your deployment history and configure rules to protect your deployments.\n\nHere's a detailed explanation:\n\n\n## Viewing deployment history\nView current and previous deployments for your repository.\n\n## Managing environments for deployment\nYou can create environments and secure those environments with deployment protection rules. A job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.\n\n## Reviewing deployments\nYou can approve or reject jobs awaiting review.\n\n## Creating custom deployment protection rules\nUse GitHub Apps to automate protecting deployments with third-party systems.\n\n## Configuring custom deployment protection rules\nUse GitHub Apps to automate protecting deployments with third-party systems.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying Python to Azure App Service?\n\nAssistant: You can deploy your Python project to Azure App Service as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a Python project to Azure App Service.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Azure.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create an Azure App Service plan.\n\nFor example, you can use the Azure CLI to create a new App Service plan:\n\n```hljs bash\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```  \n\nIn the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n\nSee the Azure documentation for more information on using the Azure CLI:\n   - For authentication, see Sign in with Azure CLI.\n   - If you need to create a new resource group, see az group.\n\n2. Create a web app.\n\nFor example, you can use the Azure CLI to create an Azure App Service web app with a Python runtime:\n\n```hljs bash\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"python|3.8\"\n```  \n\nIn the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n\n3. Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\n\nIn your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\n\n4. Add an app setting called `SCM_DO_BUILD_DURING_DEPLOYMENT` and set the value to `1`.\n\n5. Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a Python project to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created. If you use a version of Python other than `3.8`, change `PYTHON_VERSION` to the version that you use.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n```hljs yaml\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy Python app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  PYTHON_VERSION: '3.8'               # set this to the Python version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Create and start virtual environment\n        run: |\n          python -m venv venv\n          source venv/bin/activate\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      # Optional: Add a step to run tests here (PyTest, Django test suites, etc.)\n\n      - name: Upload artifact for deployment jobs\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-app\n          path: |\n            .\n            !venv/\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: python-app\n          path: .\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n```\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-webapps-python.yml` in the GitHub Actions `starter-workflows` repository.\n- The action used to deploy the web app is the official Azure `Azure/webapps-deploy` action.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying Python to Azure App Service?\n\nAssistant: Here are some code examples:\n\n### Create an Azure App Service plan\n```yaml\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```\n\n### Create an Azure App Service web app\n```yaml\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"python|3.8\"\n```\n\n### GitHub Actions workflow for deploying Python app\n```yaml\nname: Build and deploy Python app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  PYTHON_VERSION: '3.8'               # set this to the Python version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Create and start virtual environment\n        run: |\n          python -m venv venv\n          source venv/bin/activate\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      - name: Upload artifact for deployment jobs\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-app\n          path: |\n            .\n            !venv/\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: python-app\n          path: .\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying Python to Azure App Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using GitHub's security features to secure your use of GitHub Actions?\n\nAssistant: GitHub has several security features that can enhance the security of the actions you consume and publish.\n\nHere's a detailed explanation:\n\n\n## About GitHub's security features\nGitHub provides many features to make your code more secure. You can use GitHub's built-in features to understand the actions your workflows depend on, ensure you are notified about vulnerabilities in the actions you consume, or automate the process of keeping the actions in your workflows up to date. If you publish and maintain actions, you can use GitHub to communicate with your community about vulnerabilities and how to fix them. For more information about security features that GitHub offers, see GitHub security features. This article will explain how you can use some of GitHub's security features to increase the security of your use of GitHub Actions.\n\n## Understanding dependencies in your workflows\nYou can use the dependency graph to explore the actions that the workflows in your repository use. The dependency graph is a summary of the manifest and lock files stored in a repository. It also recognizes files in `./github/workflows/` as manifests, which means that any actions or workflows referenced using the syntax `jobs[*].steps[*].uses` or `jobs.<job_id>.uses` will be parsed as dependencies.\n\nThe dependency graph shows the following information about actions used in workflows:\n\n- The account or organization that owns the action.\n- The workflow file that references the action.\n- The version or SHA the action is pinned to.\n\nIn the dependency graph, dependencies are automatically sorted by vulnerability severity. If any of the actions you use have security advisories, they will display at the top of the list. You can navigate to the advisory from the dependency graph and access instructions for resolving the vulnerability.\n\nThe dependency graph is enabled for public repositories, and you can choose to enable it on private repositories. For more information about using the dependency graph, see Exploring the dependencies of a repository.\n\n## Being aware of security vulnerabilities in actions you use\nFor actions available on the marketplace, GitHub reviews related security advisories and then adds those advisories to the GitHub Advisory Database. You can search the database for actions that you use to find information about existing vulnerabilities and instructions for how to fix them. To streamline your search, use the GitHub Actions filter in the GitHub Advisory Database.\n\nYou can set up your repositories so that you:\n\n- Receive alerts when actions used in your workflows receive a vulnerability report. For more information, see Monitoring the actions in your workflows.\n- Are warned about existing advisories when you add or update an action in a workflow. For more information, see Screening actions for vulnerabilities in new or updated workflows.\n\n## Monitoring the actions in your workflows\nYou can use Dependabot to monitor the actions in your workflows and enable Dependabot alerts to notify you when an action you use has a reported vulnerability. Dependabot performs a scan of the default branch of the repositories where it is enabled to detect insecure dependencies. Dependabot generates Dependabot alerts when a new advisory is added to the GitHub Advisory Database or when an action you use is updated.\n\nNote\n\nDependabot only creates alerts for vulnerable actions that use semantic versioning and will not create alerts for actions pinned to SHA values.\n\nYou can enable Dependabot alerts for your personal account, for a repository, or for an organization. For more information, see Configuring Dependabot alerts.\n\nYou can view all open and closed Dependabot alerts and corresponding Dependabot security updates in your repository's Dependabot alerts tab. For more information, see Viewing and updating Dependabot alerts.\n\n## Screening actions for vulnerabilities in new or updated workflows\nWhen you open pull requests to update your workflows, it is good practice to use dependency review to understand the security impact of changes you've made to the actions you use. Dependency review helps you understand dependency changes and the security impact of these changes at every pull request. It provides an easily understandable visualization of dependency changes with a rich diff on the \"Files Changed\" tab of a pull request. Dependency review informs you of:\n\n- Which dependencies were added, removed, or updated, along with the release dates\n- How many projects use these components\n- Vulnerability data for these dependencies\n\nIf any of the changes you made to your workflows are flagged as vulnerable, you can avoid adding them to your project or update them to a secure version.\n\nFor more information about dependency review, see About dependency review.\n\nThe \"dependency review action\" refers to the specific action that can report on differences in a pull request within the GitHub Actions context. See dependency-review-action. You can use the dependency review action in your repository to enforce dependency reviews on your pull requests. The action scans for vulnerable versions of dependencies introduced by package version changes in pull requests, and warns you about the associated security vulnerabilities. This gives you better visibility of what's changing in a pull request, and helps prevent vulnerabilities being added to your repository. For more information, see About dependency review.\n\n## Keeping the actions in your workflows secure and up to date\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see Keeping your actions up to date with Dependabot and About Dependabot security updates.\n\nThe following features can automatically update the actions in your workflows.\n\n- **Dependabot version updates** open pull requests to update actions to the latest version when a new version is released.\n- **Dependabot security updates** open pull requests to update actions with reported vulnerabilities to the minimum patched version.\n\nNote\n\n- Dependabot only supports updates to GitHub Actions using the GitHub repository syntax, such as `actions/checkout@v4`. Dependabot will ignore actions or reusable workflows referenced locally (for example, `./.github/actions/foo.yml`).\n- Docker Hub and GitHub Packages Container registry URLs are currently not supported. For example, references to Docker container actions using `docker://` syntax aren't supported.\n- Dependabot supports both public and private repositories for GitHub Actions. For private registry configuration options, see \"git\" in Dependabot options reference.\n\nFor information on how to configure Dependabot version updates, see Configuring Dependabot version updates.\n\nFor information on how to configure Dependabot security updates, see Configuring Dependabot security updates.\n\n## Protecting actions you've created\nGitHub enables collaboration between people who publish and maintain actions and vulnerability reporters in order to promote code security. Repository security advisories allow maintainers of public repositories to privately discuss and fix a security vulnerability in a project. After collaborating on a fix, repository maintainers can publish the security advisory to publicly disclose the security vulnerability to the project's community. By publishing security advisories, repository maintainers make it easier for their community to update package dependencies and research the impact of the security vulnerabilities.\n\nIf you are someone who maintains an action that is used in other projects, you can use the following GitHub features to enhance the security of the actions you've published.\n\n- Use the dependants view in the Dependency graph to see which projects depend on your code. If you receive a vulnerability report, this will give you an idea of who you need to communicate with about the vulnerability and how to fix it. For more information, see Exploring the dependencies of a repository.\n- Use repository security advisories to create a security advisory, privately collaborate to fix the vulnerability in a temporary private fork, and publish a security advisory to alert your community of the vulnerability once a patch is released.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using GitHub's security features to secure your use of GitHub Actions?\n\nAssistant: Here are the recommended best practices:\n\n• Use the dependency graph to explore actions in your workflows.\n• Enable Dependabot alerts to monitor actions for vulnerabilities.\n• Use dependency review to understand security impacts of changes in pull requests.\n• Keep actions up to date with Dependabot version and security updates.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Connecting to a private network with GitHub-hosted runners?\n\nAssistant: You can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.\n\nHere's a detailed explanation:\n\n\n## About private networking with GitHub-hosted runners\nYou can connect GitHub-hosted runners to resources on a private network, including package registries, secret managers, and other on-premises services.\n\n## Using an API gateway with OIDC\nYou can use OpenID Connect (OIDC) tokens to authenticate your workflow.\n\n## Using WireGuard to create a network overlay\nYou can create an overlay network between your runner and a service in your private network.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Developing a third party CLI action?\n\nAssistant: Learn how to develop an action to set up a CLI on GitHub Actions runners.\n\nHere's a detailed explanation:\n\n\n## Introduction\nYou can write an action to provide a way for users to access your servers via a configured CLI environment on GitHub Actions runners.\n\nYour action should:\n\n- Make it simple for users to specify the version of the CLI to install\n- Support multiple operating systems\n- Run in an efficient fashion to minimize run-time and associated costs\n- Work across GitHub-hosted and self-hosted runners\n- Leverage community tooling when possible\n\nThis article will demonstrate how to write an action that retrieves a specific version of your CLI, installs it, adds it to the path, and (optionally) caches it. This type of action (an action that sets up a tool) is often named `setup-$TOOL`.\n\n## Prerequisites\nYou should have an understanding of how to write a custom action. For more information, see [About custom actions](https://docs.github.com/en/actions/creating-actions/about-custom-actions). For a more detailed guide on how to write a custom action, see [Creating a JavaScript action](https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action).\n\n## Example\nThe following script demonstrates how you can get a user-specified version as input, download and extract the specific version of your CLI, then add the CLI to the path.\n\nGitHub provides [`actions/toolkit`](https://github.com/actions/toolkit), which is a set of packages that helps you create actions. This example uses the [`actions/core`](https://github.com/actions/toolkit/tree/main/packages/core) and [`actions/tool-cache`](https://github.com/actions/toolkit/tree/main/packages/tool-cache) packages.\n\n## Further reading\nThis pattern is employed in several actions. For more examples, see:\n\n- [`ruby/setup-ruby`](https://github.com/ruby/setup-ruby)\n- [`google-github-actions/setup-gcloud`](https://github.com/google-github-actions/setup-gcloud)\n- [`hashicorp/setup-terraform`](https://github.com/hashicorp/setup-terraform)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Developing a third party CLI action?\n\nAssistant: Here are some code examples:\n\n### Setup CLI Action Example\n```yaml\nconst core = require('@actions/core');\nconst tc = require('@actions/tool-cache');\n\nasync function setup() {\n  // Get version of tool to be installed\n  const version = core.getInput('version');\n\n  // Download the specific version of the tool, e.g. as a tarball\n  const pathToTarball = await tc.downloadTool(getDownloadURL());\n\n  // Extract the tarball onto the runner\n  const pathToCLI = await tc.extractTar(pathToTarball);\n\n  // Expose the tool by adding it to the PATH\n  core.addPath(pathToCLI)\n}\n\nmodule.exports = setup\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Developing a third party CLI action?\n\nAssistant: Here are the recommended best practices:\n\n• Make it simple for users to specify the version of the CLI to install\n• Support multiple operating systems\n• Run in an efficient fashion to minimize run-time and associated costs\n• Work across GitHub-hosted and self-hosted runners\n• Leverage community tooling when possible\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using OpenID Connect with reusable workflows?\n\nAssistant: You can use reusable workflows with OIDC to standardize and security harden your deployment steps.\n\nHere's a detailed explanation:\n\n\n## About reusable workflows\nRather than copying and pasting deployment jobs from one workflow to another, you can create a reusable workflow that performs the deployment steps. A reusable workflow can be used by another workflow if it meets one of the access requirements described in Reusing workflows.\n\nYou should be familiar with the concepts described in Reusing workflows and About security hardening with OpenID Connect.\n\n## Defining the trust conditions\nWhen combined with OpenID Connect (OIDC), reusable workflows let you enforce consistent deployments across your repository, organization, or enterprise. You can do this by defining trust conditions on cloud roles based on reusable workflows. The available options will vary depending on your cloud provider:\n\n- **Using `job_workflow_ref`:**\n  - To create trust conditions based on reusable workflows, your cloud provider must support custom claims for `job_workflow_ref`. This allows your cloud provider to identify which repository the job originally came from.\n  - For clouds that only support the standard claims (audience ( `aud`) and subject ( `sub`)), you can use the API to customize the `sub` claim to include `job_workflow_ref`. For more information, see About security hardening with OpenID Connect. Support for custom claims is currently available for Google Cloud Platform and HashiCorp Vault.\n- **Customizing the token claims:**\n  - You can configure more granular trust conditions by customizing the subject ( `sub`) claim that's included with the JWT.\n\n## How the token works with reusable workflows\nDuring a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim called `job_workflow_ref` that contains information about the called workflow.\n\nFor example, the following OIDC token is for a job that was part of a called workflow. The `workflow`, `ref`, and other attributes describe the caller workflow, while `job_workflow_ref` refers to the called workflow:\n\n```hljs yaml\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n```\n\nIf your reusable workflow performs deployment steps, then it will typically need access to a specific cloud role, and you might want to allow any repository in your organization to call that reusable workflow. To permit this, you'll create the trust condition that allows any repository and any caller workflow, and then filter on the organization and the called workflow.\n\n## Examples\n**Filtering for reusable workflows within a specific repository**\n\nYou can configure a custom claim that filters for any reusable workflow in a specific repository. In this example, the workflow run must have originated from a job defined in a reusable workflow in the `octo-org/octo-automation` repository, and in any repository that is owned by the `octo-org` organization.\n\n- **Subject:**\n  - Syntax: `repo:ORG_NAME/*`\n  - Example: `repo:octo-org/*`\n- **Custom claim:**\n  - Syntax: `job_workflow_ref:ORG_NAME/REPO_NAME`\n  - Example: `job_workflow_ref:octo-org/octo-automation@*`\n\n**Filtering for a specific reusable workflow at a specific ref**\n\nYou can configure a custom claim that filters for a specific reusable workflow. In this example, the workflow run must have originated from a job defined in the reusable workflow `octo-org/octo-automation/.github/workflows/deployment.yml`, and in any repository that is owned by the `octo-org` organization.\n\n- **Subject:**\n  - Syntax: `repo:ORG_NAME/*`\n  - Example: `repo:octo-org/*`\n- **Custom claim:**\n  - Syntax: `job_workflow_ref:ORG_NAME/REPO_NAME/.github/workflows/WORKFLOW_FILE@ref`\n  - Example: `job_workflow_ref:octo-org/octo-automation/.github/workflows/deployment.yml@ 10040c56a8c0253d69db7c1f26a0d227275512e2`\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using OpenID Connect with reusable workflows?\n\nAssistant: Here are some code examples:\n\n### OIDC Token Example\n```yaml\n{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Monitoring your current jobs?\n\nAssistant: Monitor how GitHub-hosted runners are processing jobs in your organization or enterprise, and identify any related constraints.\n\nHere's a detailed explanation:\n\n\n## Viewing active jobs in your organization or enterprise\nYou can get a list of all jobs currently running on GitHub-hosted runners in your organization or enterprise.\n\n1. Navigate to the main page of the organization or repository.\n\n2. Click **Settings**.\n\n3. In the left sidebar, click **Actions**, then click **Runners**.\n\n4. In the \"Runners\" table, click the entry for **GitHub-hosted runners**. This entry will only be present if you're using GitHub-hosted runners.\n\n5. Review the \"Active jobs\" section, which contains a list of all jobs currently running on GitHub-hosted runners.\n\n## Viewing queued jobs in your organization or enterprise\nGitHub-hosted runners allow you to run jobs concurrently, and the maximum number of concurrent jobs will vary depending on your plan. If you reach the maximum number of concurrent jobs, any new jobs will start to enter a queue. To find out more about the number of concurrent jobs available to your plan, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration).\n\nThe following procedure demonstrates how to check the maximum number of concurrent jobs you can run.\n\n1. Navigate to the main page of the organization or repository.\n\n2. Click **Settings**.\n\n3. In the left sidebar, click **Actions**, then click **Runners**.\n\n4. In the \"Runners\" table, click the entry for **GitHub-hosted runners**. This entry will only be present if you're using GitHub-hosted runners.\n\n5. Review the \"All jobs usage\" section, which lists the number of active jobs and the maximum number of jobs you can run.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Xamarin applications?\n\nAssistant: You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Xamarin application.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Xamarin project. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy.\n\nFor a full list of available Xamarin SDK versions on the GitHub Actions-hosted macOS runners, see the README file for the version of macOS you want to use in the GitHub Actions Runner Images repository.\n\n## Prerequisites\nWe recommend that you have a basic understanding of Xamarin, .NET Core SDK, YAML, workflow configuration options, and how to create a workflow file. For more information, see:\n\n- Workflow syntax for GitHub Actions\n- Getting started with .NET\n- Learn Xamarin\n\n## Building Xamarin.iOS apps\nThe example below demonstrates how to change the default Xamarin SDK versions and build a Xamarin.iOS application.\n\n## Building Xamarin.Android apps\nThe example below demonstrates how to change default Xamarin SDK versions and build a Xamarin.Android application.\n\n## Specifying a .NET version\nTo use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the setup-dotnet action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to PATH. These changes will persist for the remainder of the job.\n\nThe setup-dotnet action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to PATH.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Xamarin applications?\n\nAssistant: Here are some code examples:\n\n### Build Xamarin.iOS app\n```yaml\nname: Build Xamarin.iOS app\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: macos-latest\n\n    steps:\n    - uses: actions/checkout@v4\n    - name: Set default Xamarin SDK versions\n      run: |\n        $VM_ASSETS/select-xamarin-sdk-v2.sh --mono=6.12 --ios=14.10\n\n    - name: Set default Xcode 12.3\n      run: |\n        XCODE_ROOT=/Applications/Xcode_12.3.0.app\n        echo \"MD_APPLE_SDK_ROOT=$XCODE_ROOT\" >> $GITHUB_ENV\n        sudo xcode-select -s $XCODE_ROOT\n\n    - name: Setup .NET Core SDK 5.0.x\n      uses: actions/setup-dotnet@v4\n      with:\n        dotnet-version: '5.0.x'\n\n    - name: Install dependencies\n      run: nuget restore <sln_file_path>\n\n    - name: Build\n      run: msbuild <csproj_file_path> /p:Configuration=Debug /p:Platform=iPhoneSimulator /t:Rebuild\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Enabling debug logging?\n\nAssistant: If the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging.\n\nHere's a detailed explanation:\n\n\n## In this article\nThese extra logs are enabled by setting secrets or variables in the repository containing the workflow, so the same permissions requirements will apply:\n\n- To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have `admin` access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\n- To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have `admin` access. For more information on environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n- Organization owners can create secrets or variables at the organization level.\n\nFor more information on setting secrets and variables, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions) and [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables).\n\nAdditionally, anyone who has access to run a workflow can enable runner diagnostic logging and step debug logging for a workflow re-run. For more information, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Enabling debug logging?\n\nAssistant: Here are some code examples:\n\n### Enabling runner diagnostic logging\n```yaml\n1. To enable runner diagnostic logging, set the following secret or variable in the repository that contains the workflow: `ACTIONS_RUNNER_DEBUG` to `true`. If both the secret and variable are set, the value of the secret takes precedence over the variable.\n2. To download runner diagnostic logs, download the log archive of the workflow run. The runner diagnostic logs are contained in the `runner-diagnostic-logs` folder.\n```\n\n### Enabling step debug logging\n```yaml\n1. To enable step debug logging, set the following secret or variable in the repository that contains the workflow: `ACTIONS_STEP_DEBUG` to `true`. If both the secret and variable are set, the value of the secret takes precedence over the variable.\n2. After setting the secret or variable, more debug events are shown in the step logs.\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Enabling debug logging?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure you have the necessary permissions to create secrets or variables in the repository.\n• Use the secret value over the variable value if both are set for enabling debug logging.\n• Download the log archive to access runner diagnostic logs after enabling them.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Canceling a workflow?\n\nAssistant: You can cancel a workflow run that is in progress. When you cancel a workflow run, GitHub cancels all jobs and steps that are a part of that workflow.\n\nHere's a detailed explanation:\n\n\n## In this article\nWrite access to the repository is required to perform these steps.\n\n## Canceling a workflow run\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. In the left sidebar, click the workflow you want to see.\n\n4. From the list of workflow runs, click the name of the `queued` or `in progress` run that you want to cancel.\n\n5. In the upper-right corner of the workflow, click **Cancel workflow**.\n\n## Steps GitHub takes to cancel a workflow run\nWhen canceling workflow run, you may be running other software that uses resources that are related to the workflow run. To help you free up resources related to the workflow run, it may help to understand the steps GitHub performs to cancel a workflow run.\n\n1. To cancel the workflow run, the server re-evaluates `if` conditions for all currently running jobs. If the condition evaluates to `true`, the job will not get canceled. For example, the condition `if: always()` would evaluate to true and the job continues to run. When there is no condition, that is the equivalent of the condition `if: success()`, which only runs if the previous step finished successfully.\n2. For jobs that need to be canceled, the server sends a cancellation message to all the runner machines with jobs that need to be canceled.\n3. For jobs that continue to run, the server re-evaluates `if` conditions for the unfinished steps. If the condition evaluates to `true`, the step continues to run. You can use the `cancelled` expression to apply a status check of `cancelled()`. For more information see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#cancelled).\n4. For steps that need to be canceled, the runner machine sends `SIGINT/Ctrl-C` to the step's entry process ( `node` for javascript action, `docker` for container action, and `bash/cmd/pwd` when using `run` in a step). If the process doesn't exit within 7500 ms, the runner will send `SIGTERM/Ctrl-Break` to the process, then wait for 2500 ms for the process to exit. If the process is still running, the runner kills the process tree.\n5. After the 5 minutes cancellation timeout period, the server will force terminate all jobs and steps that don't finish running or fail to complete the cancellation process.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using conditions to control job execution?\n\nAssistant: Prevent a job from running unless your conditions are met.\n\nHere's a detailed explanation:\n\n\n## Overview\nA job that is skipped will report its status as \"Success\". It will not prevent a pull request from merging, even if it is a required check.\n\nYou can use the `jobs.<job_id>.if` conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).\n\nThe `jobs.<job_id>.if` condition is evaluated before [`jobs.<job_id>.strategy.matrix`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix) is applied.\n\nWhen you use expressions in an `if` conditional, you can, optionally, omit the `${{ }}` expression syntax because GitHub Actions automatically evaluates the `if` conditional as an expression. However, this exception does not apply everywhere.\n\nYou must always use the `${{ }}` expression syntax or escape with `''`, `\"\", or `()` when the expression starts with `!`, since `!` is reserved notation in YAML format. For example:\n\n```hljs yaml\nif: ${{ ! startsWith(github.ref, 'refs/tags/') }}\n```\n\nFor more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Using conditions to control job execution?\n\nAssistant: Here are some code examples:\n\n### Example: Only run job for specific repository\n```yaml\nname: example-workflow\non: [push]\njobs:\n  production-deploy:\n    if: github.repository == 'octo-org/octo-repo-prod'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Using conditions to control job execution?\n\nAssistant: Here are the recommended best practices:\n\n• A job that is skipped will report its status as \"Success\" and will not prevent a pull request from merging, even if it is a required check.\n• The `jobs.<job_id>.if` condition is evaluated before `jobs.<job_id>.strategy.matrix` is applied.\n• You can omit the `${{ }}` expression syntax in some cases when using expressions in an `if` conditional, but not when the expression starts with `!`.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing Java with Maven?\n\nAssistant: You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Maven.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Maven software project management tool. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.\n\nGitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Maven. For a list of software and the pre-installed versions for JDK and Maven, see [Using GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).\n\n## Prerequisites\nYou should be familiar with YAML and the syntax for GitHub Actions. For more information, see:\n\n- [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)\n- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)\n\nWe recommend that you have a basic understanding of Java and the Maven framework. For more information, see the [Maven Getting Started Guide](https://maven.apache.org/guides/getting-started/index.html) in the Maven documentation.\n\n## Using a Maven workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n3. If you already have a workflow in your repository, click **New workflow**.\n\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Maven\".\n\n5. On the \"Java with Maven\" workflow, click **Configure**.\n\n6. Edit the workflow as required. For example, change the Java version.\n\n7. Click **Commit changes**.\n\nThe `maven.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying the Java version and architecture\nThe workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( `x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.\n\nFor example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code.\n\nThe workflow template will run the `package` target by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.\n\nIf you use different commands to build your project, or you want to use a different target, you can specify those.\n\n## Caching dependencies\nYou can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using the [`setup-java` action](https://github.com/marketplace/actions/setup-java-jdk) or can use [`cache` action](https://github.com/actions/cache) for custom and more advanced configuration.\n\n## Packaging workflow data as artifacts\nAfter your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing Java with Maven?\n\nAssistant: Here are some code examples:\n\n### Set up JDK 11 for x64\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64\n\n```\n\n### Run the Maven verify phase\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Maven verify phase\n    run: mvn --batch-mode --update-snapshots verify\n\n```\n\n### Caching dependencies with setup-java\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 17\n    uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n      cache: maven\n  - name: Build with Maven\n    run: mvn --batch-mode --update-snapshots verify\n\n```\n\n### Upload artifacts after build\n```yaml\nsteps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - run: mvn --batch-mode --update-snapshots verify\n  - run: mkdir staging && cp target/*.jar staging\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: staging\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing Java with Maven?\n\nAssistant: Here are the recommended best practices:\n\n• Familiarize yourself with YAML and GitHub Actions syntax before starting.\n• Understand the Maven framework for better customization of your workflow.\n• Use caching to speed up workflow runs by storing dependencies.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Using workflow templates?\n\nAssistant: GitHub provides workflow templates for a variety of languages and tooling.\n\nHere's a detailed explanation:\n\n\n## About workflow templates\nWorkflow templates are templates that help you to create your own GitHub Actions workflows for a repository. They offer an alternative to starting from a blank workflow file and are useful because some of the work will already have been done for you.\n\nGitHub offers workflow templates for a variety of languages and tooling. When you set up workflows in your repository, GitHub analyzes the code in your repository and recommends workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template file that installs your Node.js packages and runs your tests. You can search and filter to find relevant workflow templates.\n\nGitHub provides ready-to-use workflow templates for the following high level categories:\n\n- **Deployment (CD)**. For more information, see [About continuous deployment with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/about-continuous-deployment).\n\n- **Security**. For more information, see [Configuring advanced setup for code scanning](https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning#configuring-code-scanning-using-third-party-actions).\n\n- **Continuous Integration (CI)**. For more information, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).\n- **Automation**. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository.\n\nUse these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in the [actions/starter-workflows](https://github.com/actions/starter-workflows) repository. For more information, see [Using workflow templates](https://docs.github.com/en/actions/writing-workflows/using-starter-workflows).\n\nYou can also create your own workflow template to share with your organization. These workflow templates will appear alongside the GitHub-provided workflow templates. Anyone with write access to the organization's `.github` repository can set up a workflow template. For more information, see [Creating workflow templates for your organization](https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization).\n\n## Choosing and using a workflow template\n1. On GitHub, navigate to the main page of the repository.\n\n2. Under your repository name, click **Actions**.\n\n![Screenshot of the tabs for the \"github/docs\" repository. The \"Actions\" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)\n\n3. If you already have a workflow in your repository, click **New workflow**.\n\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Find the workflow template that you want to use, then click **Configure**. To help you find the workflow template that you want, you can search for keywords or filter by category.\n\n5. If the workflow template contains comments detailing additional setup steps, follow these steps.\n\nThere are guides to accompany many of the workflow templates for building and testing projects. For more information, see [Building and testing](https://docs.github.com/en/actions/automating-builds-and-tests).\n\n6. Some workflow templates use secrets. For example, `${{ secrets.npm_token }}`. If the workflow template uses a secret, store the value described in the secret name as a secret in your repository. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\n7. Optionally, make additional changes. For example, you might want to change the value of `on` to change when the workflow runs.\n\n8. Click **Start commit**.\n\n9. Write a commit message and decide whether to commit directly to the default branch or to open a pull request.\n\n## Further reading\n- [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration)\n\n- [Managing workflow runs and deployments](https://docs.github.com/en/actions/managing-workflow-runs)\n\n- [Monitoring and troubleshooting workflows](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/about-monitoring-and-troubleshooting)\n\n- [Managing billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Reviewing deployments?\n\nAssistant: You can approve or reject jobs awaiting review.\n\nHere's a detailed explanation:\n\n\n## Who can use this feature?\nEnvironments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories.\n\n## About required reviews in workflows\nJobs that reference an environment configured with required reviewers will wait for an approval before starting. While a job is awaiting approval, it has a status of \"Waiting\". If a job is not approved within 30 days, it will automatically fail.\n\nFor more information about environments and required approvals, see Managing environments for deployment. For information about how to review deployments with the REST API, see REST API endpoints for workflow runs.\n\n## Approving or rejecting a job\n1. Navigate to the workflow run that requires review. For more information about navigating to a workflow run, see Viewing workflow run history.\n2. If the run requires review, you will see a notification for the review request. On the notification, click **Review deployments**.\n3. Select the job environment(s) to approve or reject. Optionally, leave a comment.\n4. Approve or reject:\n   - To approve the job, click **Approve and deploy**. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.\n   - To reject the job, click **Reject**. If a job is rejected, the workflow will fail.\n\nNote\n\nIf the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated. For more information, see Managing environments for deployment.\n\n## Bypassing deployment protection rules\nIf you have configured deployment protection rules that control whether software can be deployed to an environment, you can bypass these rules and force all pending jobs referencing the environment to proceed.\n\nNote\n- You cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules. For more information, see Managing environments for deployment.\n- You can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a \"Pending\" state.\n\n1. Navigate to the workflow run. For more information about navigating to a workflow run, see Viewing workflow run history.\n2. To the right of **Deployment protection rules**, click **Start all waiting jobs**.\n3. In the pop-up window, select the environments for which you want to bypass deployment protection rules.\n4. Under **Leave a comment**, enter a description for bypassing the deployment protection rules.\n5. Click **I understand the consequences, start deploying**.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Reviewing deployments?\n\nAssistant: Here are the recommended best practices:\n\n• If the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated.\n• You cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules.\n• You can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a \"Pending\" state.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Security hardening your deployments?\n\nAssistant: Use OpenID Connect within your workflows to authenticate with your cloud provider.\n\nHere's a detailed explanation:\n\n\n## About security hardening with OpenID Connect\nOpenID Connect allows your workflows to exchange short-lived tokens directly from your cloud provider.\n\n## Configuring OpenID Connect in Amazon Web Services\nUse OpenID Connect within your workflows to authenticate with Amazon Web Services.\n\n## Configuring OpenID Connect in Azure\nUse OpenID Connect within your workflows to authenticate with Azure.\n\n## Configuring OpenID Connect in Google Cloud Platform\nUse OpenID Connect within your workflows to authenticate with Google Cloud Platform.\n\n## Configuring OpenID Connect in HashiCorp Vault\nUse OpenID Connect within your workflows to authenticate with HashiCorp Vault.\n\n## Configuring OpenID Connect in JFrog\nUse OpenID Connect within your workflows to authenticate with JFrog.\n\n## Configuring OpenID Connect in PyPI\nUse OpenID Connect within your workflows to authenticate with PyPI.\n\n## Configuring OpenID Connect in cloud providers\nUse OpenID Connect within your workflows to authenticate with cloud providers.\n\n## Using OpenID Connect with reusable workflows\nYou can use reusable workflows with OIDC to standardize and security harden your deployment steps.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Publishing Java packages with Maven?\n\nAssistant: You can use Maven to publish Java packages to a registry as part of your continuous integration (CI) workflow.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to create a workflow that publishes Java packages to GitHub Packages and the Maven Central Repository. With a single workflow, you can publish packages to a single repository or to multiple repositories.\n\nWarning\n\nThe examples used in this guide refer to the Legacy OSSRH service. See Publishing in the Maven Central Repository documentation.\n\n## Prerequisites\nWe recommend that you have a basic understanding of workflow files and configuration options. For more information, see Writing workflows.\n\nFor more information about creating a CI workflow for your Java project with Maven, see Building and testing Java with Maven.\n\nYou may also find it helpful to have a basic understanding of the following:\n\n- Working with the Apache Maven registry\n- Store information in variables\n- Using secrets in GitHub Actions\n- Automatic token authentication\n\n## About package configuration\nThe `groupId` and `artifactId` fields in the _pom.xml_ file create a unique identifier for your package that registries use to link your package to a registry. For more information see Guide to uploading artifacts to the Central Repository in the Apache Maven documentation.\n\nWarning\n\nYour Apache Maven package must follow the naming convention, and therefore the `artifactId` field should only contain lowercase letters, digits, or hyphens. For more information, see Naming convention of Maven coordinates in the maven.apache.org documentation. If you use uppercase letters in the artifact name, you'll get a _422 Unprocessable Entity_ response.\n\nThe _pom.xml_ file also contains configuration for the distribution management repositories that Maven will deploy packages to. Each repository must have a name and a deployment URL. Authentication for these repositories can be configured in the _.m2/settings.xml_ file in the home directory of the user running Maven.\n\nYou can use the `setup-java` action to configure the deployment repository as well as authentication for that repository. For more information, see `setup-java`.\n\n## Publishing packages to the Maven Central Repository\nEach time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the `release` event triggers with type `created`. The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on the `release` event, see Events that trigger workflows.\n\nIn this workflow, you can use the `setup-java` action. This action installs the given version of the JDK into the `PATH`, but it also configures a Maven _settings.xml_ for publishing packages. By default, the settings file will be configured for GitHub Packages, but it can be configured to deploy to another package registry, such as the Maven Central Repository. If you already have a distribution management repository configured in _pom.xml_, then you can specify that `id` during the `setup-java` action invocation.\n\nFor example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, your _pom.xml_ could specify a distribution management repository with the `id` of `ossrh`.\n\n## Publishing packages to GitHub Packages\nEach time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when the `release` event triggers with type `created`. The workflow publishes the package to GitHub Packages if CI tests pass. For more information on the `release` event, see Events that trigger workflows.\n\nIn this workflow, you can use the `setup-java` action. This action installs the given version of the JDK into the `PATH`, and also sets up a Maven _settings.xml_ for publishing the package to GitHub Packages. The generated _settings.xml_ defines authentication for a server with an `id` of `github`, using the `GITHUB_ACTOR` environment variable as the username and the `GITHUB_TOKEN` environment variable as the password. The `GITHUB_TOKEN` environment variable is assigned the value of the special `GITHUB_TOKEN` secret.\n\nThe `GITHUB_TOKEN` secret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for the `contents` permission and write access for the `packages` permission. For more information, see Automatic token authentication.\n\n## Publishing packages to the Maven Central Repository and GitHub Packages\nYou can publish your packages to both the Maven Central Repository and GitHub Packages by using the `setup-java` action for each registry.\n\nEnsure your _pom.xml_ file includes a distribution management repository for both your GitHub repository and your Maven Central Repository provider.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Publishing Java packages with Maven?\n\nAssistant: Here are some code examples:\n\n### Maven Central Repository Configuration\n```yaml\n<project ...>\n  ...\n  <distributionManagement>\n    <repository>\n      <id>ossrh</id>\n      <name>Central Repository OSSRH</name>\n      <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n    </repository>\n  </distributionManagement>\n</project>\n```\n\n### Publish package to the Maven Central Repository Workflow\n```yaml\nname: Publish package to the Maven Central Repository\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n      - name: Publish package\n        run: mvn --batch-mode deploy\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Publishing Java packages with Maven?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure your _pom.xml_ file includes a distribution management repository for both your GitHub repository and your Maven Central Repository provider.\n• Set the permissions for the `GITHUB_TOKEN` access token in the workflow file to grant read access for the `contents` permission and write access for the `packages` permission.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Store information in variables?\n\nAssistant: GitHub sets default variables for each GitHub Actions workflow run. You can also set custom variables for use in a single workflow or multiple workflows.\n\nHere's a detailed explanation:\n\n\n## About variables\nVariables provide a way to store and reuse non-sensitive configuration information. You can store any configuration data such as compiler flags, usernames, or server names as variables. Variables are interpolated on the runner machine that runs your workflow. Commands that run in actions or workflow steps can create, read, and modify variables.\n\nYou can set your own custom variables or use the default environment variables that GitHub sets automatically. For more information, see [Default environment variables](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables).\n\nYou can set a custom variable in two ways.\n\n- To define an environment variable for use in a single workflow, you can use the `env` key in the workflow file. For more information, see [Defining environment variables for a single workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#defining-environment-variables-for-a-single-workflow).\n- To define a configuration variable across multiple workflows, you can define it at the organization, repository, or environment level. For more information, see [Defining configuration variables for multiple workflows](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#defining-configuration-variables-for-multiple-workflows).\n\nWarning\n\nBy default, variables render unmasked in your build outputs. If you need greater security for sensitive information, such as passwords, use secrets instead. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).\n\n## Defining environment variables for a single workflow\nTo set a custom environment variable for a single workflow, you can define it using the `env` key in the workflow file. The scope of a custom variable set by this method is limited to the element in which it is defined. You can define variables that are scoped for:\n\n- The entire workflow, by using [`env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#env) at the top level of the workflow file.\n- The contents of a job within a workflow, by using [`jobs.<job_id>.env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenv).\n- A specific step within a job, by using [`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsenv).\n\n## Naming conventions for environment variables\nWhen you set an environment variable, you cannot use any of the default environment variable names. For a complete list of default environment variables, see [Default environment variables](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#default-environment-variables) below. If you attempt to override the value of one of these default variables, the assignment is ignored.\n\nNote\n\nYou can list the entire set of environment variables that are available to a workflow step by using `run: env` in a step and then examining the output for the step.\n\n## Defining configuration variables for multiple workflows\nYou can create configuration variables for use across multiple workflows, and can define them at either the [organization](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#creating-configuration-variables-for-an-organization), [repository](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#creating-configuration-variables-for-a-repository), or [environment](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#creating-configuration-variables-for-an-environment) level.\n\nFor example, you can use configuration variables to set default values for parameters passed to build tools at an organization level, but then allow repository owners to override these parameters on a case-by-case basis.\n\nWhen you define configuration variables, they are automatically available in the `vars` context. For more information, see [Using the `vars` context to access configuration variable values](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#using-the-vars-context-to-access-configuration-variable-values).\n\n## Configuration variable precedence\nIf a variable with the same name exists at multiple levels, the variable at the lowest level takes precedence. For example, if an organization-level variable has the same name as a repository-level variable, then the repository-level variable takes precedence. Similarly, if an organization, repository, and environment all have a variable with the same name, the environment-level variable takes precedence.\n\nFor reusable workflows, the variables from the caller workflow's repository are used. Variables from the repository that contains the called workflow are not made available to the caller workflow.\n\n## Creating configuration variables for a repository\nTo create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must have `admin` access. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the \"Security\" section of the sidebar, select **Secrets and variables**, then click **Actions**.\n4. Click the **Variables** tab.\n5. Click **New repository variable**.\n6. In the **Name** field, enter a name for your variable.\n7. In the **Value** field, enter the value for your variable.\n8. Click **Add variable**.\n\n## Creating configuration variables for an environment\nTo create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must have `admin` access. For more information on environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the left sidebar, click **Environments**.\n4. Click on the environment that you want to add a variable to.\n5. Under **Environment variables**, click **Add variable**.\n6. In the **Name** field, enter a name for your variable.\n7. In the **Value** field, enter the value for your variable.\n8. Click **Add variable**.\n\n## Creating configuration variables for an organization\nNote\n\nOrganization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, see [Upgrading your account's plan](https://docs.github.com/en/billing/managing-billing-for-your-github-account/upgrading-your-github-subscription).\n\nWhen creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.\n\nOrganization owners can create secrets or variables at the organization level.\n\n1. On GitHub, navigate to the main page of the organization.\n2. Under your organization name, click **Settings**. If you cannot see the \"Settings\" tab, select the  dropdown menu, then click **Settings**.\n3. In the \"Security\" section of the sidebar, select **Secrets and variables**, then click **Actions**.\n4. Click the **Variables** tab.\n5. Click **New organization variable**.\n6. In the **Name** field, enter a name for your variable.\n7. In the **Value** field, enter the value for your variable.\n8. From the **Repository access** dropdown list, choose an access policy.\n9. Click **Add variable**.\n\n## Limits for configuration variables\nIndividual variables are limited to 48 KB in size.\n\nYou can store up to 1,000 organization variables, 500 variables per repository, and 100 variables per environment. The total combined size limit for organization and repository variables is 256 KB per workflow run.\n\nA workflow created in a repository can access the following number of variables:\n\n- Up to 500 repository variables, if the total size of repository variables is less than 256 KB. If the total size of repository variables exceeds 256 KB, only the repository variables that fall below the limit will be available (as sorted alphabetically by variable name).\n- Up to 1,000 organization variables, if the total combined size of repository and organization variables is less than 256 KB. If the total combined size of organization and repository variables exceeds 256 KB, only the organization variables that fall below that limit will be available (after accounting for repository variables and as sorted alphabetically by variable name).\n- Up to 100 environment-level variables.\n\nNote\n\nEnvironment-level variables do not count toward the 256 KB total size limit. If you exceed the combined size limit for repository and organization variables and still need additional variables, you can use an environment and define additional variables in the environment.\n\n## Using contexts to access variable values\nContexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts). There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).\n\nYou can access environment variable values using the `env` context and configuration variable values using the `vars` context.\n\n## Using the `env` context to access environment variable values\nIn addition to runner environment variables, GitHub Actions allows you to set and read `env` key values using contexts. Environment variables and contexts are intended for use at different points in the workflow.\n\nThe `run` steps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example, `$NAME` for the bash shell on a Linux runner, or `$env:NAME` for PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax `${{ CONTEXT.PROPERTY }}`, to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner.\n\nHowever, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, an `if` conditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in an `if` conditional statement to access the value of an variable.\n\n## Using the `vars` context to access configuration variable values\nConfiguration variables can be accessed across the workflow using `vars` context. For more information, see [Accessing contextual information about workflow runs](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context).\n\nIf a configuration variable has not been set, the return value of a context referencing the variable will be an empty string.\n\n## Default environment variables\nThe default environment variables that GitHub sets are available to every step in a workflow.\n\nBecause default environment variables are set by GitHub and not defined in a workflow, they are not accessible through the `env` context. However, most of the default variables have a corresponding, and similarly named, context property. For example, the value of the `GITHUB_REF` variable can be read during workflow processing using the `${{ github.ref }}` context property.\n\nYou can't overwrite the value of the default environment variables named `GITHUB_*` and `RUNNER_*`. Currently you can overwrite the value of the `CI` variable. However, it's not guaranteed that this will always be possible. For more information about setting environment variables, see [Defining environment variables for a single workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables#defining-environment-variables-for-a-single-workflow) and [Workflow commands for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-environment-variable).\n\n## Detecting the operating system\nYou can write a single workflow file that can be used for different operating systems by using the `RUNNER_OS` default environment variable and the corresponding context property `${{ runner.os }}`.\n\n## Passing values between steps and jobs in a workflow\nIf you generate a value in one step of a job, you can use the value in subsequent steps of the same job by assigning the value to an existing or new environment variable and then writing this to the `GITHUB_ENV` environment file. The environment file can be used directly by an action, or from a shell command in the workflow file by using the `run` keyword.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Store information in variables?\n\nAssistant: Here are some code examples:\n\n### Greeting on variable day\n```yaml\nname: Greeting on variable day\n\non:\n  workflow_dispatch\n\nenv:\n  DAY_OF_WEEK: Monday\n\njobs:\n  greeting_job:\n    runs-on: ubuntu-latest\n    env:\n      Greeting: Hello\n    steps:\n      - name: \"Say Hello Mona it's Monday\"\n        run: echo \"$Greeting $First_Name. Today is $DAY_OF_WEEK!\"\n        env:\n          First_Name: Mona\n\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Store information in variables?\n\nAssistant: Here are the recommended best practices:\n\n• By default, variables render unmasked in your build outputs. If you need greater security for sensitive information, such as passwords, use secrets instead.\n• You can list the entire set of environment variables that are available to a workflow step by using `run: env` in a step and then examining the output for the step.\n• We strongly recommend that actions use variables to access the filesystem rather than using hardcoded file paths. GitHub sets variables for actions to use in all runner environments.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Creating a Docker container action?\n\nAssistant: This guide shows you the minimal steps required to build a Docker container action.\n\nHere's a detailed explanation:\n\n\n## Introduction\nIn this guide, you'll learn about the basic components needed to create and use a packaged Docker container action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" in the logs or \"Hello [who-to-greet]\" if you provide a custom name.\n\nOnce you complete this project, you should understand how to build your own Docker container action and test it in a workflow.\n\nSelf-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, see About self-hosted runners.\n\nWarning\n\nWhen creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, see Security hardening for GitHub Actions.\n\n## Prerequisites\n- You must create a repository on GitHub and clone it to your workstation. For more information, see Creating a new repository and Cloning a repository.\n- If your repository uses Git LFS, you must include the objects in archives of your repository. For more information, see Managing Git LFS objects in archives of your repository.\n- You may find it helpful to have a basic understanding of GitHub Actions, environment variables and the Docker container filesystem. For more information, see Store information in variables and Using GitHub-hosted runners.\n\n## Creating a Dockerfile\nIn your new `hello-world-docker-action` directory, create a new `Dockerfile` file. Make sure that your filename is capitalized correctly (use a capital `D` but not a capital `f`) if you're having issues. For more information, see Dockerfile support for GitHub Actions.\n\n**Dockerfile**\n\n```hljs dockerfile\n# Container image that runs your code\nFROM alpine:3.10\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Code file to execute when the docker container starts up (`entrypoint.sh`)\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n## Creating an action metadata file\nCreate a new `action.yml` file in the `hello-world-docker-action` directory you created above. For more information, see Metadata syntax for GitHub Actions.\n\n**action.yml**\n\n```hljs yaml\n# action.yml\nname: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - ${{ inputs.who-to-greet }}\n```\n\nThis metadata defines one `who-to-greet` input and one `time` output parameter. To pass inputs to the Docker container, you should declare the input using `inputs` and pass the input in the `args` keyword. Everything you include in `args` is passed to the container, but for better discoverability for users of your action, we recommended using inputs.\n\nGitHub will build an image from your `Dockerfile`, and run commands in a new container using this image.\n\n## Writing the action code\nYou can choose any base Docker image and, therefore, any language for your action. The following shell script example uses the `who-to-greet` input variable to print \"Hello [who-to-greet]\" in the log file.\n\nNext, the script gets the current time and sets it as an output variable that actions running later in a job can use. In order for GitHub to recognize output variables, you must write them to the `$GITHUB_OUTPUT` environment file: `echo \"<output name>=<value>\" >> $GITHUB_OUTPUT`. For more information, see Workflow commands for GitHub Actions.\n\n1. Create a new `entrypoint.sh` file in the `hello-world-docker-action` directory.\n\n2. Add the following code to your `entrypoint.sh` file.\n\n**entrypoint.sh**\n\n```hljs shell\n#!/bin/sh -l\necho \"Hello $1\"\ntime=$(date)\necho \"time=$time\" >> $GITHUB_OUTPUT\n``` \n\nIf `entrypoint.sh` executes without any errors, the action's status is set to `success`. You can also explicitly set exit codes in your action's code to provide an action's status. For more information, see Setting exit codes for actions.\n\n3. Make your `entrypoint.sh` file executable. Git provides a way to explicitly change the permission mode of a file so that it doesn’t get reset every time there is a clone/fork.\n\n```hljs shell\ngit add entrypoint.sh\ngit update-index --chmod=+x entrypoint.sh\n``` \n\n4. Optionally, to check the permission mode of the file in the git index, run the following command.\n\n```hljs shell\ngit ls-files --stage entrypoint.sh\n``` \n\nAn output like `100755 e69de29bb2d6434b8b29ae775ad8c2e48c5391 0       entrypoint.sh` means the file has the executable permission. In this example, `755` denotes the executable permission.\n\n## Creating a README\nTo let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action.\n\nIn your `hello-world-docker-action` directory, create a `README.md` file that specifies the following information:\n\n- A detailed description of what the action does.\n- Required input and output arguments.\n- Optional input and output arguments.\n- Secrets the action uses.\n- Environment variables the action uses.\n- An example of how to use your action in a workflow.\n\n**README.md**\n\n```hljs markdown\n# Hello world docker action\n\nThis action prints \"Hello World\" or \"Hello\" + the name of a person to greet to the log.\n\n## Inputs\n\n## `who-to-greet`\n\n**Required** The name of the person to greet. Default \"World\".\n\n## Outputs\n\n## `time`\n\nThe time we greeted you.\n\n## Example usage\n\nuses: actions/hello-world-docker-action@v2\nwith:\n  who-to-greet: 'Mona the Octocat'\n```\n\n## Commit, tag, and push your action\nFrom your terminal, commit your `action.yml`, `entrypoint.sh`, `Dockerfile`, and `README.md` files.\n\nIt's best practice to also add a version tag for releases of your action. For more information on versioning your action, see About custom actions.\n\n```hljs shell\ngit add action.yml entrypoint.sh Dockerfile README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1\ngit push --follow-tags\n```\n\n## Testing out your action in a workflow\nNow you're ready to test your action out in a workflow.\n\n- When an action is in a private repository, you can control who can access it. For more information, see Managing GitHub Actions settings for a repository.\n- When an action is in an internal repository, the action can only be used in workflows in the same repository.\n- Public actions can be used by workflows in any repository.\n\n### Example using a public action\n\nThe following workflow code uses the completed _hello world_ action in the public `actions/hello-world-docker-action` repository. Copy the following workflow example code into a `.github/workflows/main.yml` file, but replace the `actions/hello-world-docker-action` with your repository and action name. You can also replace the `who-to-greet` input with your name. Public actions can be used even if they're not published to GitHub Marketplace.\n\n**.github/workflows/main.yml**\n\n```hljs yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: actions/hello-world-docker-action@v2\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n``` \n\n### Example using a private action\n\nCopy the following example workflow code into a `.github/workflows/main.yml` file in your action's repository. You can also replace the `who-to-greet` input with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository.\n\n**.github/workflows/main.yml**\n\n```hljs yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      # To use this repository's private action,\n      # you must check out the repository\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Hello world action step\n        uses: ./ # Uses an action in the root directory\n        id: hello\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n``` \n\nFrom your repository, click the **Actions** tab, and select the latest workflow run. Under **Jobs** or in the visualization graph, click **A job to say hello**.\n\nClick **Hello world action step**, and you should see \"Hello Mona the Octocat\" or the name you used for the `who-to-greet` input printed in the log. To see the timestamp, click **Get the output time**.\n\n## Accessing files created by a container action\nWhen a container action runs, it will automatically map the default working directory ( `GITHUB_WORKSPACE`) on the runner with the `/github/workspace` directory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps.\n\n**workflow.yml**\n\n```hljs yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      # Output build artifacts to /github/workspace on the container.\n      - name: Containerized Build\n        uses: ./.github/actions/my-container-action\n\n      - name: Upload Build Artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: workspace_artifacts\n          path: ${{ github.workspace }}\n``` \n\nFor more information about uploading build output as an artifact, see Storing and sharing data from a workflow.\n\n## Example Docker container actions on GitHub.com\nYou can find many examples of Docker container actions on GitHub.com.\n\n- [github/issue-metrics](https://github.com/github/issue-metrics)\n- [microsoft/infersharpaction](https://github.com/microsoft/infersharpaction)\n- [microsoft/ps-docs](https://github.com/microsoft/ps-docs)\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Creating a Docker container action?\n\nAssistant: Here are some code examples:\n\n### Dockerfile\n```yaml\n# Container image that runs your code\nFROM alpine:3.10\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Code file to execute when the docker container starts up (`entrypoint.sh`)\nENTRYPOINT [\"/entrypoint.sh\"]\n```\n\n### action.yml\n```yaml\n# action.yml\nname: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - ${{ inputs.who-to-greet }}\n```\n\n### entrypoint.sh\n```yaml\n#!/bin/sh -l\necho \"Hello $1\"\ntime=$(date)\necho \"time=$time\" >> $GITHUB_OUTPUT\n```\n\n### Commit, tag, and push your action\n```yaml\ngit add action.yml entrypoint.sh Dockerfile README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1\ngit push --follow-tags\n```\n\n### Example using a public action\n```yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: actions/hello-world-docker-action@v2\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n```\n\n### Example using a private action\n```yaml\non: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      # To use this repository's private action,\n      # you must check out the repository\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Hello world action step\n        uses: ./ # Uses an action in the root directory\n        id: hello\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\"\n```\n\n### Accessing files created by a container action\n```yaml\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      # Output build artifacts to /github/workspace on the container.\n      - name: Containerized Build\n        uses: ./.github/actions/my-container-action\n\n      - name: Upload Build Artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: workspace_artifacts\n          path: ${{ github.workspace }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Creating a Docker container action?\n\nAssistant: Here are the recommended best practices:\n\n• Always consider whether your code might execute untrusted input from possible attackers.\n• It's best practice to add a version tag for releases of your action.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Building and testing .NET?\n\nAssistant: You can create a continuous integration (CI) workflow to build and test your .NET project.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide shows you how to build, test, and publish a .NET package.\n\nGitHub-hosted runners have a tools cache with preinstalled software, which includes the .NET Core SDK. For a full list of up-to-date software and the preinstalled versions of .NET Core SDK, see software installed on GitHub-hosted runners.\n\n## Prerequisites\nYou should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see Workflow syntax for GitHub Actions.\n\nWe recommend that you have a basic understanding of the .NET Core SDK. For more information, see Getting started with .NET.\n\n## Using a .NET workflow template\nTo get started quickly, add a workflow template to the `.github/workflows` directory of your repository.\n\nGitHub provides a workflow template for .NET that should work for most .NET projects. The subsequent sections of this guide give examples of how you can customize this workflow template.\n\n1. On GitHub, navigate to the main page of the repository.\n2. Under your repository name, click **Actions**.\n3. If you already have a workflow in your repository, click **New workflow**.\n4. The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"dotnet\".\n5. On the \".NET\" workflow, click **Configure**.\n6. Edit the workflow as required. For example, change the .NET version.\n7. Click **Commit changes**.\n\nThe `dotnet.yml` workflow file is added to the `.github/workflows` directory of your repository.\n\n## Specifying a .NET version\nTo use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use the `setup-dotnet` action. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries to `PATH`. These changes will persist for the remainder of the job.\n\nThe `setup-dotnet` action is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it to `PATH`. For more information, see the `setup-dotnet` action.\n\n## Using multiple .NET versions\n```hljs yaml\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup dotnet ${{ matrix.dotnet-version }}\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ matrix.dotnet-version }}\n      # You can test your matrix by printing the current dotnet version\n      - name: Display dotnet version\n        run: dotnet --version\n```\n\n## Using a specific .NET version\nYou can configure your job to use a specific version of .NET, such as `6.0.22`. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of .NET 6.\n\n```hljs yaml\n    - name: Setup .NET 6.x\n      uses: actions/setup-dotnet@v4\n      with:\n        # Semantic version range syntax or exact version of a dotnet version\n        dotnet-version: '6.x'\n```\n\n## Installing dependencies\nGitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs the `Newtonsoft` package.\n\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n\n## Caching dependencies\nYou can cache NuGet dependencies for future workflows using the optional `cache` input. For example, the YAML below caches the NuGet `global-packages` folder, and then installs the `Newtonsoft` package. A second optional input, `cache-dependency-path`, can be used to specify the path to a dependency file: `packages.lock.json`.\n\nFor more information, see Caching dependencies to speed up workflows.\n\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.x'\n    cache: true\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n\nNote\n\nDepending on the number of dependencies, it may be faster to use the dependency cache. Projects with many large dependencies should see a performance increase as it cuts down the time required for downloading. Projects with fewer dependencies may not see a significant performance increase and may even see a slight decrease due to how NuGet installs cached dependencies. The performance varies from project to project.\n\n## Building and testing your code\nYou can use the same commands that you use locally to build and test your code. This example demonstrates how to use `dotnet build` and `dotnet test` in a job:\n\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet restore\n- name: Build\n  run: dotnet build\n- name: Test with the dotnet CLI\n  run: dotnet test\n```\n\n## Packaging workflow data as artifacts\nAfter a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use the `upload-artifact` action to upload test results.\n\nFor more information, see Storing and sharing data from a workflow.\n\n```hljs yaml\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n      steps:\n        - uses: actions/checkout@v4\n        - name: Setup dotnet\n          uses: actions/setup-dotnet@v4\n          with:\n            dotnet-version: ${{ matrix.dotnet-version }}\n        - name: Install dependencies\n          run: dotnet restore\n        - name: Test with dotnet\n          run: dotnet test --logger trx --results-directory \"TestResults-${{ matrix.dotnet-version }}\"\n        - name: Upload dotnet test results\n          uses: actions/upload-artifact@v4\n          with:\n            name: dotnet-results-${{ matrix.dotnet-version }}\n            path: TestResults-${{ matrix.dotnet-version }}\n          # Use always() to always run this step to publish test results when there are test failures\n          if: ${{ always() }}\n```\n\n## Publishing to package registries\nYou can configure your workflow to publish your .NET package to a package registry when your CI tests pass. You can use repository secrets to store any tokens or credentials needed to publish your binary. The following example creates and publishes a package to GitHub Packages using `dotnet core cli`.\n\n```hljs yaml\nname: Upload dotnet package\n\non:\n  release:\n    types: [created]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '6.0.x' # SDK Version to use.\n          source-url: https://nuget.pkg.github.com/<owner>/index.json\n        env:\n          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}\n      - run: dotnet build --configuration Release <my project>\n      - name: Create the package\n        run: dotnet pack --configuration Release <my project>\n      - name: Publish the package to GPR\n        run: dotnet nuget push <my project>/bin/Release/*.nupkg\n```\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Building and testing .NET?\n\nAssistant: Here are some code examples:\n\n### Using multiple .NET versions\n```yaml\n```hljs yaml\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup dotnet ${{ matrix.dotnet-version }}\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ matrix.dotnet-version }}\n      # You can test your matrix by printing the current dotnet version\n      - name: Display dotnet version\n        run: dotnet --version\n```\n```\n\n### Using a specific .NET version\n```yaml\n```hljs yaml\n    - name: Setup .NET 6.x\n      uses: actions/setup-dotnet@v4\n      with:\n        # Semantic version range syntax or exact version of a dotnet version\n        dotnet-version: '6.x'\n```\n```\n\n### Installing dependencies\n```yaml\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n```\n\n### Caching dependencies\n```yaml\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.x'\n    cache: true\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1\n```\n```\n\n### Building and testing your code\n```yaml\n```hljs yaml\nsteps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet restore\n- name: Build\n  run: dotnet build\n- name: Test with the dotnet CLI\n  run: dotnet test\n```\n```\n\n### Packaging workflow data as artifacts\n```yaml\n```hljs yaml\nname: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n      steps:\n        - uses: actions/checkout@v4\n        - name: Setup dotnet\n          uses: actions/setup-dotnet@v4\n          with:\n            dotnet-version: ${{ matrix.dotnet-version }}\n        - name: Install dependencies\n          run: dotnet restore\n        - name: Test with dotnet\n          run: dotnet test --logger trx --results-directory \"TestResults-${{ matrix.dotnet-version }}\"\n        - name: Upload dotnet test results\n          uses: actions/upload-artifact@v4\n          with:\n            name: dotnet-results-${{ matrix.dotnet-version }}\n            path: TestResults-${{ matrix.dotnet-version }}\n          # Use always() to always run this step to publish test results when there are test failures\n          if: ${{ always() }}\n```\n```\n\n### Publishing to package registries\n```yaml\n```hljs yaml\nname: Upload dotnet package\n\non:\n  release:\n    types: [created]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '6.0.x' # SDK Version to use.\n          source-url: https://nuget.pkg.github.com/<owner>/index.json\n        env:\n          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}\n      - run: dotnet build --configuration Release <my project>\n      - name: Create the package\n        run: dotnet pack --configuration Release <my project>\n      - name: Publish the package to GPR\n        run: dotnet nuget push <my project>/bin/Release/*.nupkg\n```\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Building and testing .NET?\n\nAssistant: Here are the recommended best practices:\n\n• Familiarize yourself with YAML syntax and GitHub Actions.\n• Understand the .NET Core SDK basics before starting.\n• Use the `setup-dotnet` action for consistent behavior across runners.\n• Consider caching dependencies to speed up workflows, especially for projects with many large dependencies.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What is Deploying .NET to Azure App Service?\n\nAssistant: You can deploy your .NET project to Azure App Service as part of your continuous deployment (CD) workflows.\n\nHere's a detailed explanation:\n\n\n## Introduction\nThis guide explains how to use GitHub Actions to build and deploy a .NET project to Azure App Service.\n\nNote\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect and Configuring OpenID Connect in Azure.\n\n## Prerequisites\nBefore creating your GitHub Actions workflow, you will first need to complete the following setup steps:\n\n1. Create an Azure App Service plan.\n\nFor example, you can use the Azure CLI to create a new App Service plan:\n\n```hljs bash\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```\n\nIn the command above, replace `MY_RESOURCE_GROUP` with your pre-existing Azure Resource Group, and `MY_APP_SERVICE_PLAN` with a new name for the App Service plan.\n\nSee the Azure documentation for more information on using the Azure CLI:\n   - For authentication, see Sign in with Azure CLI.\n   - If you need to create a new resource group, see az group.\n\n2. Create a web app.\n\nFor example, you can use the Azure CLI to create an Azure App Service web app with a .NET runtime:\n\n```hljs bash\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"DOTNET|5.0\"\n```\n\nIn the command above, replace the parameters with your own values, where `MY_WEBAPP_NAME` is a new name for the web app.\n\n3. Configure an Azure publish profile and create an `AZURE_WEBAPP_PUBLISH_PROFILE` secret.\n\nGenerate your Azure deployment credentials using a publish profile. For more information, see Generate deployment credentials in the Azure documentation.\n\nIn your GitHub repository, create a secret named `AZURE_WEBAPP_PUBLISH_PROFILE` that contains the contents of the publish profile. For more information on creating secrets, see Using secrets in GitHub Actions.\n\n4. Optionally, configure a deployment environment. Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see Managing environments for deployment.\n\n## Creating the workflow\nOnce you've completed the prerequisites, you can proceed with creating the workflow.\n\nThe following example workflow demonstrates how to build and deploy a .NET project to Azure App Service when there is a push to the `main` branch.\n\nEnsure that you set `AZURE_WEBAPP_NAME` in the workflow `env` key to the name of the web app you created. If the path to your project is not the repository root, change `AZURE_WEBAPP_PACKAGE_PATH`. If you use a version of .NET other than `5`, change `DOTNET_VERSION`.\n\nIf you configured a deployment environment, change the value of `environment` to be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete the `environment` key.\n\n## Additional resources\nThe following resources may also be useful:\n\n- For the original workflow template, see `azure-webapps-dotnet-core.yml` in the GitHub Actions `starter-workflows` repository.\n- The action used to deploy the web app is the official Azure `Azure/webapps-deploy` action.\n- For more examples of GitHub Action workflows that deploy to Azure, see the actions-workflow-samples repository.\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: Can you show me some code examples for Deploying .NET to Azure App Service?\n\nAssistant: Here are some code examples:\n\n### Example Azure CLI command to create an App Service plan\n```yaml\naz appservice plan create \\\n      --resource-group MY_RESOURCE_GROUP \\\n      --name MY_APP_SERVICE_PLAN \\\n      --is-linux\n```\n\n### Example Azure CLI command to create a web app\n```yaml\naz webapp create \\\n       --name MY_WEBAPP_NAME \\\n       --plan MY_APP_SERVICE_PLAN \\\n       --resource-group MY_RESOURCE_GROUP \\\n       --runtime \"DOTNET|5.0\"\n```\n\n### Example GitHub Actions workflow\n```yaml\nname: Build and deploy ASP.Net Core app to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  DOTNET_VERSION: '5'                 # set this to the .NET Core version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up .NET Core\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: Set up dependency caching for faster builds\n        uses: actions/cache@v4\n        with:\n          path: ~/.nuget/packages\n          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-nuget-\n\n      - name: Build with dotnet\n        run: dotnet build --configuration Release\n\n      - name: dotnet publish\n        run: dotnet publish -c Release -o ${{env.DOTNET_ROOT}}/myapp\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: .net-app\n          path: ${{env.DOTNET_ROOT}}/myapp\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: .net-app\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}\n```\n\n"}
{"text": "System: You are a helpful GitHub Actions expert.\n\nUser: What are the best practices for Deploying .NET to Azure App Service?\n\nAssistant: Here are the recommended best practices:\n\n• If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), configure your workflows to authenticate directly to the cloud provider to avoid storing long-lived secrets.\n• GitHub recommends pinning actions to a commit SHA to ensure stability.\n"}
