{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Python Packaging User Guide\"?\n\nAssistant: Welcome to the Python Packaging User Guide, a collection of tutorials and references to help you distribute and install Python packages with modern tools.\n\nHere's a detailed explanation:\n\n\n## Overview and Flow\nBuilding your understanding of Python packaging is a journey. Patience and continuous improvement are key to success. The overview and flow sections provide a starting point for understanding the Python packaging ecosystem.\n\nThe Overview of Python Packaging explains Python packaging and its use when preparing and distributing projects. This section helps you build understanding about selecting the tools and processes that are most suitable for your use case. It includes what packaging is, the problems that it solves, and key considerations.\n\nTo get an overview of the workflow used to publish your code, see packaging flow.\n\n## Tutorials\nTutorials walk through the steps needed to complete a project for the first time. Tutorials aim to help you succeed and provide a starting point for future exploration.\n\nThe Tutorials section includes:\n\n- A tutorial on installing packages\n- A tutorial on managing application dependencies in a version controlled project\n- A tutorial on packaging and distributing your project\n\n## Guides\nGuides provide steps to perform a specific task. Guides are more focused on users who are already familiar with Python packaging and are looking for specific information.\n\nThe Guides section provides “how to” instructions in three major areas: package installation; building and distributing packages; miscellaneous topics.\n\n## Explanations and Discussions\nThe Discussions section for in-depth explanations and discussion about topics, such as:\n\n- Deploying Python applications\n- pip vs easy_install\n\n## Reference\nThe PyPA specifications section for packaging interoperability specifications.\n\nThe list of other projects maintained by members of the Python Packaging Authority.\n\nThe Glossary for definitions of terms used in Python packaging.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest", "title": "Python Packaging User Guide", "description": "Welcome to the Python Packaging User Guide, a collection of tutorials and references to help you distribute and install Python packages with modern tools.", "has_code_examples": false, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-27 22:50:29", "type": "overview", "page_metadata": {"favicon": "https://packaging.python.org/en/_static/py.png", "readthedocs-project-slug": "python-packaging-user-guide", "keywords": "python, packaging, guide, tutorial", "title": "Python Packaging User Guide", "readthedocs-http-status": "200", "language": "en", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "color-scheme": "light dark", "description": "The Python Packaging User Guide (PyPUG) is a collection of tutorials and guides for packaging Python software.", "readthedocs-version-slug": "latest", "readthedocs-resolver-filename": "/", "scrapeId": "2e0c182f-ca5d-4141-a4e4-65be0ea30f1a", "sourceURL": "https://packaging.python.org/en/latest", "url": "https://packaging.python.org/en/latest/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Python Packaging User Guide\"?\n\nAssistant: Here are the recommended best practices:\n\n• Building your understanding of Python packaging is a journey. Patience and continuous improvement are key to success.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest", "title": "Python Packaging User Guide", "description": "Welcome to the Python Packaging User Guide, a collection of tutorials and references to help you distribute and install Python packages with modern tools.", "has_code_examples": false, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-27 22:50:29", "type": "best_practices", "page_metadata": {"favicon": "https://packaging.python.org/en/_static/py.png", "readthedocs-project-slug": "python-packaging-user-guide", "keywords": "python, packaging, guide, tutorial", "title": "Python Packaging User Guide", "readthedocs-http-status": "200", "language": "en", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "color-scheme": "light dark", "description": "The Python Packaging User Guide (PyPUG) is a collection of tutorials and guides for packaging Python software.", "readthedocs-version-slug": "latest", "readthedocs-resolver-filename": "/", "scrapeId": "2e0c182f-ca5d-4141-a4e4-65be0ea30f1a", "sourceURL": "https://packaging.python.org/en/latest", "url": "https://packaging.python.org/en/latest/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"The Packaging Flow\"?\n\nAssistant: The document aims to outline the flow involved in publishing/distributing a distribution package, usually to the Python Package Index (PyPI). It is written for package publishers, who are assumed to be the package author.\n\nHere's a detailed explanation:\n\n\n## The source tree\nThe source tree contains the package source code, usually a checkout from a VCS. The particular version of the code used to create the build artifacts will typically be a checkout based on a tag associated with the version.\n\n## The configuration file\nThe configuration file depends on the tool used to create the build artifacts. The standard practice is to use a `pyproject.toml` file in the TOML format.\n\nAt a minimum, the `pyproject.toml` file needs a `[build-system]` table specifying your build tool. There are many build tools available, including but not limited to flit, hatch, pdm, poetry, Setuptools, trampolim, and whey. Each tool’s documentation will show what to put in the `[build-system]` table.\n\nFor example, here is a table for using hatch:\n\n```\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n```\n\nWith such a table in the `pyproject.toml` file, a “frontend” tool like build can run your chosen build tool’s “backend” to create the build artifacts. Your build tool may also provide its own frontend. An install tool like pip also acts as a frontend when it runs your build tool’s backend to install from a source distribution.\n\nThe particular build tool you choose dictates what additional information is required in the `pyproject.toml` file. For example, you might specify:\n\n- a `[project]` table containing project Core Metadata (name, version, author and so forth),\n- a `[tool]` table containing tool-specific configuration options.\n\nRefer to the pyproject.toml guide for a complete guide to `pyproject.toml` configuration.\n\n## Build artifacts\n### The source distribution (sdist)\nA source distribution contains enough to install the package from source in an end user’s Python environment. As such, it needs the package source, and may also include tests and documentation. These are useful for end users wanting to develop your sources, and for end user systems where some local compilation step is required (such as a C extension).\n\nThe build package knows how to invoke your build tool to create one of these:\n\n```\npython3 -m build --sdist source-tree-directory\n```\n\nOr, your build tool may provide its own interface for creating an sdist.\n\n### The built distributions (wheels)\nA built distribution contains only the files needed for an end user’s Python environment. No compilation steps are required during the install, and the wheel file can simply be unpacked into the `site-packages` directory. This makes the install faster and more convenient for end users.\n\nA pure Python package typically needs only one “generic” wheel. A package with compiled binary extensions needs a wheel for each supported combination of Python interpreter, operating system, and CPU architecture that it supports. If a suitable wheel file is not available, tools like pip will fall back to installing the source distribution.\n\nThe build package knows how to invoke your build tool to create one of these:\n\n```\npython3 -m build --wheel source-tree-directory\n```\n\nOr, your build tool may provide its own interface for creating a wheel.\n\nNote\nThe default behaviour of build is to make both an sdist and a wheel from the source in the current directory; the above examples are deliberately specific.\n\n## Upload to the package distribution service\nThe twine tool can upload build artifacts to PyPI for distribution, using a command like:\n\n```\ntwine upload dist/package-name-version.tar.gz dist/package-name-version-py3-none-any.whl\n```\n\nOr, your build tool may provide its own interface for uploading.\n\n## Download and install\nNow that the package is published, end users can download and install the package into their Python environment. Typically this is done with pip, using a command like:\n\n```\npython3 -m pip install package-name\n```\n\nEnd users may also use other tools like Pipenv, poetry, or pdm.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/flow", "title": "The Packaging Flow", "description": "The document aims to outline the flow involved in publishing/distributing a distribution package, usually to the Python Package Index (PyPI). It is written for package publishers, who are assumed to be the package author.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-27 22:51:07", "type": "overview", "page_metadata": {"readthedocs-resolver-filename": "/flow/", "color-scheme": "light dark", "readthedocs-project-slug": "python-packaging-user-guide", "language": "en", "readthedocs-version-slug": "latest", "title": "The Packaging Flow - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "0878b4f0-9b1a-492a-9c48-1daaf77a7622", "sourceURL": "https://packaging.python.org/en/latest/flow", "url": "https://packaging.python.org/en/latest/flow/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"The Packaging Flow\"?\n\nAssistant: Here are some code examples:\n\n### Creating a source distribution (sdist)\n```yaml\npython3 -m build --sdist source-tree-directory\n```\n\n### Creating a built distribution (wheel)\n```yaml\npython3 -m build --wheel source-tree-directory\n```\n\n### Uploading build artifacts to PyPI\n```yaml\ntwine upload dist/package-name-version.tar.gz dist/package-name-version-py3-none-any.whl\n```\n\n### Installing a package using pip\n```yaml\npython3 -m pip install package-name\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/flow", "title": "The Packaging Flow", "description": "The document aims to outline the flow involved in publishing/distributing a distribution package, usually to the Python Package Index (PyPI). It is written for package publishers, who are assumed to be the package author.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-27 22:51:07", "type": "code_examples", "page_metadata": {"readthedocs-resolver-filename": "/flow/", "color-scheme": "light dark", "readthedocs-project-slug": "python-packaging-user-guide", "language": "en", "readthedocs-version-slug": "latest", "title": "The Packaging Flow - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "0878b4f0-9b1a-492a-9c48-1daaf77a7622", "sourceURL": "https://packaging.python.org/en/latest/flow", "url": "https://packaging.python.org/en/latest/flow/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"The Packaging Flow\"?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure your source tree is a checkout from a version control system (VCS).\n• Maintain a `pyproject.toml` file in the source tree for package metadata and build configuration.\n• Use the appropriate build tool for your package and follow its documentation for configuration.\n• Create both source distributions and built distributions for better compatibility with end users.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/flow", "title": "The Packaging Flow", "description": "The document aims to outline the flow involved in publishing/distributing a distribution package, usually to the Python Package Index (PyPI). It is written for package publishers, who are assumed to be the package author.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-27 22:51:07", "type": "best_practices", "page_metadata": {"readthedocs-resolver-filename": "/flow/", "color-scheme": "light dark", "readthedocs-project-slug": "python-packaging-user-guide", "language": "en", "readthedocs-version-slug": "latest", "title": "The Packaging Flow - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "0878b4f0-9b1a-492a-9c48-1daaf77a7622", "sourceURL": "https://packaging.python.org/en/latest/flow", "url": "https://packaging.python.org/en/latest/flow/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Writing your `pyproject.toml`\"?\n\nAssistant: `pyproject.toml` is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.\n\nHere's a detailed explanation:\n\n\n## Declaring the build backend\nThe `[build-system]` table contains a `build-backend` key, which specifies the build backend to be used. It also contains a `requires` key, which is a list of dependencies needed to build the project – this is typically just the build backend package, but it may also contain additional dependencies. You can also constrain the versions, e.g., `requires = [\"setuptools >= 61.0\"]`.\n\nUsually, you’ll just copy what your build backend’s documentation suggests (after [choosing your build backend](https://packaging.python.org/en/latest/tutorials/packaging-projects/#choosing-build-backend)). Here are the values for some common build backends:\n\nHatchling\n\n```\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n```\n\nsetuptools\n\n```\n[build-system]\nrequires = [\"setuptools >= 61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n```\n\nFlit\n\n```\n[build-system]\nrequires = [\"flit_core >= 3.4\"]\nbuild-backend = \"flit_core.buildapi\"\n```\n\nPDM\n\n```\n[build-system]\nrequires = [\"pdm-backend\"]\nbuild-backend = \"pdm.backend\"\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "title": "Writing your `pyproject.toml`", "description": "`pyproject.toml` is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:51:36", "type": "overview", "page_metadata": {"title": "Writing your pyproject.toml - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "color-scheme": "light dark", "readthedocs-resolver-filename": "/guides/writing-pyproject-toml/", "readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "916cd821-7ee0-45be-a0af-4d1f9176efe0", "sourceURL": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"Writing your `pyproject.toml`\"?\n\nAssistant: Here are some code examples:\n\n### Hatchling Example\n```yaml\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n```\n\n### setuptools Example\n```yaml\n[build-system]\nrequires = [\"setuptools >= 61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n```\n\n### Flit Example\n```yaml\n[build-system]\nrequires = [\"flit_core >= 3.4\"]\nbuild-backend = \"flit_core.buildapi\"\n```\n\n### PDM Example\n```yaml\n[build-system]\nrequires = [\"pdm-backend\"]\nbuild-backend = \"pdm.backend\"\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "title": "Writing your `pyproject.toml`", "description": "`pyproject.toml` is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:51:36", "type": "code_examples", "page_metadata": {"title": "Writing your pyproject.toml - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "color-scheme": "light dark", "readthedocs-resolver-filename": "/guides/writing-pyproject-toml/", "readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "916cd821-7ee0-45be-a0af-4d1f9176efe0", "sourceURL": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Writing your `pyproject.toml`\"?\n\nAssistant: Here are the recommended best practices:\n\n• The `[build-system]` table should always be present, regardless of which build backend you use.\n• For new projects, use the `[project]` table, and keep `setup.py` only if some programmatic configuration is needed.\n• Consult your build backend’s documentation to learn how it computes dynamic fields.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "title": "Writing your `pyproject.toml`", "description": "`pyproject.toml` is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:51:36", "type": "best_practices", "page_metadata": {"title": "Writing your pyproject.toml - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "color-scheme": "light dark", "readthedocs-resolver-filename": "/guides/writing-pyproject-toml/", "readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "916cd821-7ee0-45be-a0af-4d1f9176efe0", "sourceURL": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml", "url": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Package Formats\"?\n\nAssistant: This page discusses the file formats that are used to distribute Python packages and the differences between them.\n\nHere's a detailed explanation:\n\n\n## What is a source distribution?\nConceptually, a source distribution is an archive of the source code in raw form. Concretely, an sdist is a `.tar.gz` archive containing the source code plus an additional special file called `PKG-INFO`, which holds the project metadata. The presence of this file helps packaging tools to be more efficient by not needing to compute the metadata themselves. The `PKG-INFO` file follows the format specified in [Core metadata specifications](https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata) and is not intended to be written by hand [1]. You can thus inspect the contents of an sdist by unpacking it using standard tools to work with tar archives, such as `tar -xvf` on UNIX platforms (like Linux and macOS), or [the command line interface of Python’s tarfile module](https://docs.python.org/3/library/tarfile.html#tarfile-commandline) on any platform. Sdists serve several purposes in the packaging ecosystem. When [pip](https://packaging.python.org/en/latest/key_projects/#pip), the standard Python package installer, cannot find a wheel to install, it will fall back on downloading a source distribution, compiling a wheel from it, and installing the wheel. Furthermore, sdists are often used as the package source by downstream packagers (such as Linux distributions, Conda, Homebrew and MacPorts on macOS, …), who, for various reasons, may prefer them over, e.g., pulling from a Git repository. A source distribution is recognized by its file name, which has the form `package_name-version.tar.gz`, e.g., `pip-23.3.1.tar.gz`. If you want technical details on the sdist format, read the [sdist specification](https://packaging.python.org/en/latest/specifications/source-distribution-format/#source-distribution-format).\n\n## What is a wheel?\nConceptually, a wheel contains exactly the files that need to be copied when installing the package. There is a big difference between sdists and wheels for packages with [extension modules](https://packaging.python.org/en/latest/glossary/#term-Extension-Module), written in compiled languages like C, C++ and Rust, which need to be compiled into platform-dependent machine code. With these packages, wheels do not contain source code (like C source files) but compiled, executable code (like `.so` files on Linux or DLLs on Windows). Furthermore, while there is only one sdist per version of a project, there may be many wheels. Again, this is most relevant in the context of extension modules. The compiled code of an extension module is tied to an operating system and processor architecture, and often also to the version of the Python interpreter (unless the [Python stable ABI](https://packaging.python.org/en/latest/guides/packaging-binary-extensions/#cpython-stable-abi) is used). For pure-Python packages, the difference between sdists and wheels is less marked. There is normally one single wheel, for all platforms and Python versions. Python is an interpreted language, which does not need ahead-of-time compilation, so wheels contain `.py` files just like sdists. If you are wondering about `.pyc` bytecode files: they are not included in wheels, since they are cheap to generate, and including them would unnecessarily force a huge number of packages to distribute one wheel per Python version instead of one single wheel. Instead, installers like [pip](https://packaging.python.org/en/latest/key_projects/#pip) generate them while installing the package. With that being said, there are still important differences between sdists and wheels, even for pure Python projects. Wheels are meant to contain exactly what is to be installed, and nothing more. In particular, wheels should never include tests and documentation, while sdists commonly do. Also, the wheel format is more complex than sdist. For example, it includes a special file – called `RECORD` – that lists all files in the wheel along with a hash of their content, as a safety check of the download’s integrity. At a glance, you might wonder if wheels are really needed for “plain and basic” pure Python projects. Keep in mind that due to the flexibility of sdists, installers like pip cannot install from sdists directly – they need to first build a wheel, by invoking the [build backend](https://packaging.python.org/en/latest/glossary/#term-Build-Backend) that the sdist specifies (the build backend may do all sorts of transformations while building the wheel, such as compiling C extensions). For this reason, even for a pure Python project, you should always upload _both_ an sdist and a wheel to PyPI or other package indices. This makes installation much faster for your users, since a wheel is directly installable. By only including files that must be installed, wheels also make for smaller downloads. On the technical level, a wheel is a ZIP archive (unlike sdists which are TAR archives). You can inspect its contents by unpacking it as a normal ZIP archive, e.g., using `unzip` on UNIX platforms like Linux and macOS, `Expand-Archive` in Powershell on Windows, or [the command line interface of Python’s zipfile module](https://docs.python.org/3/library/zipfile.html#zipfile-commandline). This can be very useful to check that the wheel includes all the files you need it to. Inside a wheel, you will find the package’s files, plus an additional directory called `package_name-version.dist-info`. This directory contains various files, including a `METADATA` file which is the equivalent of `PKG-INFO` in sdists, as well as `RECORD`. This can be useful to ensure no files are missing from your wheels. The file name of a wheel (ignoring some rarely used features) looks like this: `package_name-version-python_tag-abi_tag-platform_tag.whl`. This naming convention identifies which platforms and Python versions the wheel is compatible with. For example, the name `pip-23.3.1-py3-none-any.whl` means that: - ( `py3`) This wheel can be installed on any implementation of Python 3, whether CPython, the most widely used Python implementation, or an alternative implementation like [PyPy](https://pypy.org/); - ( `none`) It does not depend on the Python version; - ( `any`) It does not depend on the platform. The pattern `py3-none-any` is common for pure Python projects. Packages with extension modules typically ship multiple wheels with more complex tags. All technical details on the wheel format can be found in the [wheel specification](https://packaging.python.org/en/latest/specifications/binary-distribution-format/#binary-distribution-format).\n\n## What about eggs?\n“Egg” is an old package format that has been replaced with the wheel format. It should not be used anymore. Since August 2023, PyPI [rejects egg uploads](https://blog.pypi.org/posts/2023-06-26-deprecate-egg-uploads/). Here’s a breakdown of the important differences between wheel and egg. - The egg format was introduced by [Setuptools](https://packaging.python.org/en/latest/key_projects/#setuptools) in 2004, whereas the wheel format was introduced by [PEP 427](https://peps.python.org/pep-0427/) in 2012. - Wheel has an [official standard specification](https://packaging.python.org/en/latest/specifications/binary-distribution-format/). Egg did not. - Wheel is a [distribution](https://packaging.python.org/en/latest/glossary/#term-Distribution-Package) format, i.e a packaging format. [2] Egg was both a distribution format and a runtime installation format (if left zipped), and was designed to be importable. - Wheel archives do not include `.pyc` files. Therefore, when the distribution only contains Python files (i.e. no compiled extensions), and is compatible with Python 2 and 3, it’s possible for a wheel to be “universal”, similar to an [sdist](https://packaging.python.org/en/latest/glossary/#term-Source-Distribution-or-sdist). - Wheel uses standard [.dist-info directories](https://packaging.python.org/en/latest/specifications/recording-installed-packages/#recording-installed-packages). Egg used `.egg-info`. - Wheel has a [richer file naming convention](https://packaging.python.org/en/latest/specifications/binary-distribution-format/#wheel-file-name-spec). A single wheel archive can indicate its compatibility with a number of Python language versions and implementations, ABIs, and system architectures. - Wheel is versioned. Every wheel file contains the version of the wheel specification and the implementation that packaged it. - Wheel is internally organized by [sysconfig path type](https://docs.python.org/2/library/sysconfig.html#installation-paths), therefore making it easier to convert to other formats.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/package-formats", "title": "Package Formats", "description": "This page discusses the file formats that are used to distribute Python packages and the differences between them.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-27 22:52:19", "type": "overview", "page_metadata": {"viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-resolver-filename": "/discussions/package-formats/", "language": "en", "readthedocs-version-slug": "latest", "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "title": "Package Formats - Python Packaging User Guide", "color-scheme": "light dark", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "e4f649d2-9e7b-4f7c-a495-3781c7b43096", "sourceURL": "https://packaging.python.org/en/latest/discussions/package-formats", "url": "https://packaging.python.org/en/latest/discussions/package-formats/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"Package Formats\"?\n\nAssistant: Here are some code examples:\n\n### Inspecting an sdist\n```yaml\ntar -xvf pip-23.3.1.tar.gz\n```\n\n### Inspecting a wheel\n```yaml\nunzip pip-23.3.1-py3-none-any.whl\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/package-formats", "title": "Package Formats", "description": "This page discusses the file formats that are used to distribute Python packages and the differences between them.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-27 22:52:19", "type": "code_examples", "page_metadata": {"viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-resolver-filename": "/discussions/package-formats/", "language": "en", "readthedocs-version-slug": "latest", "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "title": "Package Formats - Python Packaging User Guide", "color-scheme": "light dark", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "e4f649d2-9e7b-4f7c-a495-3781c7b43096", "sourceURL": "https://packaging.python.org/en/latest/discussions/package-formats", "url": "https://packaging.python.org/en/latest/discussions/package-formats/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Package Formats\"?\n\nAssistant: Here are the recommended best practices:\n\n• Always upload both an sdist and one or more wheels when publishing a package on PyPI.\n• Wheels should never include tests and documentation, while sdists commonly do.\n• Inspect the contents of sdists and wheels to ensure all necessary files are included.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/package-formats", "title": "Package Formats", "description": "This page discusses the file formats that are used to distribute Python packages and the differences between them.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-27 22:52:19", "type": "best_practices", "page_metadata": {"viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-resolver-filename": "/discussions/package-formats/", "language": "en", "readthedocs-version-slug": "latest", "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "title": "Package Formats - Python Packaging User Guide", "color-scheme": "light dark", "favicon": "https://packaging.python.org/en/_static/py.png", "scrapeId": "e4f649d2-9e7b-4f7c-a495-3781c7b43096", "sourceURL": "https://packaging.python.org/en/latest/discussions/package-formats", "url": "https://packaging.python.org/en/latest/discussions/package-formats/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Building and Publishing\"?\n\nAssistant: Guidelines for building and publishing Python packages.\n\nHere's a detailed explanation:\n\n\n## Writing your `pyproject.toml`\nInstructions on how to write a `pyproject.toml` file for your Python project.\n\n## Packaging and distributing projects\nGuidelines for packaging and distributing Python projects using setuptools.\n\n## Dropping support for older Python versions\nBest practices for dropping support for older versions of Python.\n\n## Packaging binary extensions\nInstructions on how to package binary extensions for Python.\n\n## Packaging namespace packages\nGuidelines for packaging namespace packages.\n\n## Creating and packaging command-line tools\nInstructions for creating and packaging command-line tools.\n\n## Creating and discovering plugins\nGuidelines for creating and discovering plugins.\n\n## Using TestPyPI\nInstructions on how to use TestPyPI for testing package distributions.\n\n## Making a PyPI-friendly README\nBest practices for creating a README that is friendly for PyPI.\n\n## Publishing package distribution releases using GitHub Actions CI/CD workflows\nInstructions for publishing package distributions using GitHub Actions.\n\n## How to modernize a `setup.py` based project?\nGuidelines for modernizing projects that use `setup.py`.\n\n## Licensing examples and user scenarios\nExamples and scenarios for licensing your Python packages.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/section-build-and-publish", "title": "Building and Publishing", "description": "Guidelines for building and publishing Python packages.", "has_code_examples": false, "has_best_practices": true, "section_count": 12, "timestamp": "2025-02-27 22:52:30", "type": "overview", "page_metadata": {"language": "en", "title": "Building and Publishing - Python Packaging User Guide", "readthedocs-resolver-filename": "/guides/section-build-and-publish/", "color-scheme": "light dark", "readthedocs-project-slug": "python-packaging-user-guide", "favicon": "https://packaging.python.org/en/_static/py.png", "readthedocs-version-slug": "latest", "readthedocs-http-status": "200", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "scrapeId": "a7a212ed-eaf9-4577-a30a-b57b476b8d97", "sourceURL": "https://packaging.python.org/en/latest/guides/section-build-and-publish", "url": "https://packaging.python.org/en/latest/guides/section-build-and-publish/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Building and Publishing\"?\n\nAssistant: Here are the recommended best practices:\n\n• Ensure your `pyproject.toml` is correctly formatted to avoid build issues.\n• Use TestPyPI to test your package before publishing to the main PyPI.\n• Keep your README updated to reflect the latest changes in your package.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/section-build-and-publish", "title": "Building and Publishing", "description": "Guidelines for building and publishing Python packages.", "has_code_examples": false, "has_best_practices": true, "section_count": 12, "timestamp": "2025-02-27 22:52:30", "type": "best_practices", "page_metadata": {"language": "en", "title": "Building and Publishing - Python Packaging User Guide", "readthedocs-resolver-filename": "/guides/section-build-and-publish/", "color-scheme": "light dark", "readthedocs-project-slug": "python-packaging-user-guide", "favicon": "https://packaging.python.org/en/_static/py.png", "readthedocs-version-slug": "latest", "readthedocs-http-status": "200", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "scrapeId": "a7a212ed-eaf9-4577-a30a-b57b476b8d97", "sourceURL": "https://packaging.python.org/en/latest/guides/section-build-and-publish", "url": "https://packaging.python.org/en/latest/guides/section-build-and-publish/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Versioning\"?\n\nAssistant: This discussion covers all aspects of versioning Python packages.\n\nHere's a detailed explanation:\n\n\n## Valid version numbers\nDifferent Python projects may use different versioning schemes based on the needs of that particular project, but in order to be compatible with tools like pip, all of them are required to comply with a flexible format for version identifiers, for which the authoritative reference is the specification of version specifiers. Here are some examples of version numbers:\n\n- A simple version (final release): `1.2.0`\n- A development release: `1.2.0.dev1`\n- An alpha release: `1.2.0a1`\n- A beta release: `1.2.0b1`\n- A release candidate: `1.2.0rc1`\n- A post-release: `1.2.0.post1`\n- A post-release of an alpha release (possible, but discouraged): `1.2.0a1.post1`\n- A simple version with only two components: `23.12`\n- A simple version with just one component: `42`\n- A version with an epoch: `1!1.0`\n\nProjects can use a cycle of pre-releases to support testing by their users before a final release. In order, the steps are: alpha releases, beta releases, release candidates, final release. Pip and other modern Python package installers ignore pre-releases by default when deciding which versions of dependencies to install, unless explicitly requested (e.g., with `pip install pkg==1.1a3` or `pip install --pre pkg`).\n\nThe purpose of development releases is to support releases made early during a development cycle, for example, a nightly build, or a build from the latest source in a Linux distribution.\n\nPost-releases are used to address minor errors in a final release that do not affect the distributed software, such as correcting an error in the release notes. They should not be used for bug fixes; these should be done with a new final release (e.g., incrementing the third component when using semantic versioning).\n\nFinally, epochs, a rarely used feature, serve to fix the sorting order when changing the versioning scheme. For example, if a project is using calendar versioning, with versions like 23.12, and switches to semantic versioning, with versions like 1.0, the comparison between 1.0 and 23.12 will go the wrong way. To correct this, the new version numbers should have an explicit epoch, as in “1!1.0”, in order to be treated as more recent than the old version numbers.\n\n## Semantic versioning vs. calendar versioning\nA versioning scheme is a formalized way to interpret the segments of a version number, and to decide which should be the next version number for a new release of a package. Two versioning schemes are commonly used for Python packages, semantic versioning and calendar versioning.\n\nCaution\n\nThe decision which version number to choose is up to a project’s maintainer. This effectively means that version bumps reflect the maintainer’s view. That view may differ from the end-users’ perception of what said formalized versioning scheme promises them.\n\nThere are known exceptions for selecting the next version number. The maintainers may consciously choose to break the assumption that the last version segment only contains backwards-compatible changes. One such case is when security vulnerability needs to be addressed. Security releases often come in patch versions but contain breaking changes inevitably.\n\n## Semantic versioning\nThe idea of semantic versioning (or SemVer) is to use 3-part version numbers, major.minor.patch, where the project author increments:\n\n- major when they make incompatible API changes,\n- minor when they add functionality in a backwards-compatible manner, and\n- patch, when they make backwards-compatible bug fixes.\n\nA majority of Python projects use a scheme that resembles semantic versioning. However, most projects, especially larger ones, do not strictly adhere to semantic versioning, since many changes are technically breaking changes but affect only a small fraction of users. Such projects tend to increment the major number when the incompatibility is high, or to signal a shift in the project, rather than for any tiny incompatibility. Conversely, a bump of the major version number is sometimes used to signal significant but backwards-compatible new features.\n\nFor those projects that do use strict semantic versioning, this approach allows users to make use of compatible release version specifiers, with the `~=` operator. For example, `name ~= X.Y` is roughly equivalent to `name >= X.Y, == X.*`, i.e., it requires at least release X.Y, and allows any later release with greater Y as long as X is the same. Likewise, `name ~= X.Y.Z` is roughly equivalent to `name >= X.Y.Z, == X.Y.*`, i.e., it requires at least X.Y.Z and allows a later release with same X and Y but higher Z.\n\nPython projects adopting semantic versioning should abide by clauses 1-8 of the Semantic Versioning 2.0.0 specification. The popular Sphinx documentation generator is an example project that uses strict semantic versioning. The famous NumPy scientific computing package explicitly uses “loose” semantic versioning, where releases incrementing the minor version can contain backwards-incompatible API changes.\n\n## Calendar versioning\nSemantic versioning is not a suitable choice for all projects, such as those with a regular time based release cadence and a deprecation process that provides warnings for a number of releases prior to removal of a feature.\n\nA key advantage of date-based versioning, or calendar versioning (CalVer), is that it is straightforward to tell how old the base feature set of a particular release is given just the version number.\n\nCalendar version numbers typically take the form year.month (for example, 23.12 for December 2023). Pip, the standard Python package installer, uses calendar versioning.\n\n## Other schemes\nSerial versioning refers to the simplest possible versioning scheme, which consists of a single number incremented every release. While serial versioning is very easy to manage as a developer, it is the hardest to track as an end user, as serial version numbers convey little or no information regarding API backwards compatibility.\n\nCombinations of the above schemes are possible. For example, a project may combine date based versioning with serial versioning to create a year.serial numbering scheme that readily conveys the approximate age of a release, but doesn’t otherwise commit to a particular release cadence within the year.\n\n## Local version identifiers\nPublic version identifiers are designed to support distribution via PyPI. Python packaging tools also support the notion of a local version identifier, which can be used to identify local development builds not intended for publication, or modified variants of a release maintained by a redistributor.\n\nA local version identifier takes the form of a public version identifier, followed by “+” and a local version label. For example, a package with Fedora-specific patches applied could have the version “1.2.1+fedora.4”. Another example is versions computed by setuptools-scm, a setuptools plugin that reads the version from Git data. In a Git repository with some commits since the latest release, setuptools-scm generates a version like “0.5.dev1+gd00980f”, or if the repository has untracked changes, like “0.5.dev1+gd00980f.d20231217.”\n\n## Accessing version information at runtime\nVersion information for all distribution packages that are locally available in the current environment can be obtained at runtime using the standard library’s `importlib.metadata.version()` function:\n\n```\n>>> importlib.metadata.version(\"cryptography\")\n'41.0.7'\n```\n\nMany projects also choose to version their top level import packages by providing a package level `__version__` attribute:\n\n```\n>>> import cryptography\n>>> cryptography.__version__\n'41.0.7'\n```\n\nThis technique can be particularly valuable for CLI applications which want to ensure that version query invocations (such as `pip -V`) run as quickly as possible.\n\nPackage publishers wishing to ensure their reported distribution package and import package versions are consistent with each other can review the Single-sourcing the Project Version discussion for potential approaches to doing so.\n\nAs import packages and modules are not required to publish runtime version information in this way, the `__version__` attribute should either only be queried with interfaces that are known to provide it, or else the querying code should be designed to handle the case where the attribute is missing. Some projects may need to publish version information for external APIs that aren’t the version of the module itself. Such projects should define their own project-specific ways of obtaining the relevant information at runtime.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/versioning", "title": "Versioning", "description": "This discussion covers all aspects of versioning Python packages.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-27 22:53:16", "type": "overview", "page_metadata": {"readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "color-scheme": "light dark", "readthedocs-resolver-filename": "/discussions/versioning/", "readthedocs-project-slug": "python-packaging-user-guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "title": "Versioning - Python Packaging User Guide", "scrapeId": "1b41c316-7e7c-46a6-9696-f090eb639b72", "sourceURL": "https://packaging.python.org/en/latest/discussions/versioning", "url": "https://packaging.python.org/en/latest/discussions/versioning/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"Versioning\"?\n\nAssistant: Here are some code examples:\n\n### Accessing version information using importlib.metadata\n```yaml\n>>> importlib.metadata.version(\"cryptography\")\n'41.0.7'\n```\n\n### Accessing version information using __version__ attribute\n```yaml\n>>> import cryptography\n>>> cryptography.__version__\n'41.0.7'\n```\n\n### Accessing OpenSSL version information\n```yaml\n>>> ssl.OPENSSL_VERSION\n'OpenSSL 3.2.2 4 Jun 2024'\n>>> ssl.OPENSSL_VERSION_INFO\n(3, 2, 0, 2, 0)\n>>> hex(ssl.OPENSSL_VERSION_NUMBER)\n'0x30200020'\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/versioning", "title": "Versioning", "description": "This discussion covers all aspects of versioning Python packages.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-27 22:53:16", "type": "code_examples", "page_metadata": {"readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "color-scheme": "light dark", "readthedocs-resolver-filename": "/discussions/versioning/", "readthedocs-project-slug": "python-packaging-user-guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "title": "Versioning - Python Packaging User Guide", "scrapeId": "1b41c316-7e7c-46a6-9696-f090eb639b72", "sourceURL": "https://packaging.python.org/en/latest/discussions/versioning", "url": "https://packaging.python.org/en/latest/discussions/versioning/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Versioning\"?\n\nAssistant: Here are the recommended best practices:\n\n• Projects should comply with a flexible format for version identifiers to be compatible with tools like pip.\n• Use a cycle of pre-releases to support testing by users before a final release.\n• Post-releases should not be used for bug fixes; these should be done with a new final release.\n• For projects using semantic versioning, abide by clauses 1-8 of the Semantic Versioning 2.0.0 specification.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/versioning", "title": "Versioning", "description": "This discussion covers all aspects of versioning Python packages.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-27 22:53:16", "type": "best_practices", "page_metadata": {"readthedocs-http-status": "200", "readthedocs-version-slug": "latest", "language": "en", "color-scheme": "light dark", "readthedocs-resolver-filename": "/discussions/versioning/", "readthedocs-project-slug": "python-packaging-user-guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "title": "Versioning - Python Packaging User Guide", "scrapeId": "1b41c316-7e7c-46a6-9696-f090eb639b72", "sourceURL": "https://packaging.python.org/en/latest/discussions/versioning", "url": "https://packaging.python.org/en/latest/discussions/versioning/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Installation\"?\n\nAssistant: Guidelines for installing Python packages and tools.\n\nHere's a detailed explanation:\n\n\n## Install packages in a virtual environment using pip and venv\nInstructions on how to set up a virtual environment and install packages using pip.\n\n## Installing packages using virtualenv\nDetails on using virtualenv to create isolated Python environments for package installation.\n\n## Installing stand alone command line tools\nGuidelines for installing command line tools that operate independently.\n\n## Installing pip/setuptools/wheel with Linux Package Managers\nInstructions for installing essential Python packaging tools using Linux package managers.\n\n## Installing scientific packages\nGuidelines for installing scientific computing packages in Python.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/guides/section-install", "title": "Installation", "description": "Guidelines for installing Python packages and tools.", "has_code_examples": false, "has_best_practices": false, "section_count": 5, "timestamp": "2025-02-27 22:53:29", "type": "overview", "page_metadata": {"readthedocs-project-slug": "python-packaging-user-guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "language": "en", "readthedocs-version-slug": "latest", "title": "Installation - Python Packaging User Guide", "favicon": "https://packaging.python.org/en/_static/py.png", "color-scheme": "light dark", "readthedocs-resolver-filename": "/guides/section-install/", "readthedocs-http-status": "200", "scrapeId": "4bdc95ef-5531-4319-b352-c4adf008aa34", "sourceURL": "https://packaging.python.org/en/latest/guides/section-install", "url": "https://packaging.python.org/en/latest/guides/section-install/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Names and normalization\"?\n\nAssistant: This specification defines the format that names for packages and extras are required to follow. It also describes how to normalize them, which should be done before lookups and comparisons.\n\nHere's a detailed explanation:\n\n\n## Name format\nA valid name consists only of ASCII letters and numbers, period, underscore and hyphen. It must start and end with a letter or number. This means that valid project names are limited to those which match the following regex (run with [re.IGNORECASE](https://docs.python.org/3/library/re.html#re.IGNORECASE \"(in Python v3.13)\")): \n\n```\n^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/specifications/name-normalization", "title": "Names and normalization", "description": "This specification defines the format that names for packages and extras are required to follow. It also describes how to normalize them, which should be done before lookups and comparisons.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:53:40", "type": "overview", "page_metadata": {"color-scheme": "light dark", "readthedocs-resolver-filename": "/specifications/name-normalization/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "title": "Names and normalization - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-version-slug": "latest", "scrapeId": "52c2822b-3a68-47c3-b0b0-1d9b71ba9360", "sourceURL": "https://packaging.python.org/en/latest/specifications/name-normalization", "url": "https://packaging.python.org/en/latest/specifications/name-normalization/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"Names and normalization\"?\n\nAssistant: Here are some code examples:\n\n### Name normalization function\n```yaml\nimport re\n\ndef normalize(name):\n    return re.sub(r\"[-_.]+\", \"-\", name).lower()\n\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/specifications/name-normalization", "title": "Names and normalization", "description": "This specification defines the format that names for packages and extras are required to follow. It also describes how to normalize them, which should be done before lookups and comparisons.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:53:40", "type": "code_examples", "page_metadata": {"color-scheme": "light dark", "readthedocs-resolver-filename": "/specifications/name-normalization/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "title": "Names and normalization - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-version-slug": "latest", "scrapeId": "52c2822b-3a68-47c3-b0b0-1d9b71ba9360", "sourceURL": "https://packaging.python.org/en/latest/specifications/name-normalization", "url": "https://packaging.python.org/en/latest/specifications/name-normalization/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Names and normalization\"?\n\nAssistant: Here are the recommended best practices:\n\n• The name should be lowercased with all runs of the characters '.', '-', or '_' replaced with a single '-' character.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/specifications/name-normalization", "title": "Names and normalization", "description": "This specification defines the format that names for packages and extras are required to follow. It also describes how to normalize them, which should be done before lookups and comparisons.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-27 22:53:40", "type": "best_practices", "page_metadata": {"color-scheme": "light dark", "readthedocs-resolver-filename": "/specifications/name-normalization/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "title": "Names and normalization - Python Packaging User Guide", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-version-slug": "latest", "scrapeId": "52c2822b-3a68-47c3-b0b0-1d9b71ba9360", "sourceURL": "https://packaging.python.org/en/latest/specifications/name-normalization", "url": "https://packaging.python.org/en/latest/specifications/name-normalization/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"Is `setup.py` deprecated?\"?\n\nAssistant: This page discusses the deprecation status of `setup.py` and provides recommendations for using alternative commands and tools for packaging Python projects.\n\nHere's a detailed explanation:\n\n\n## Is `setup.py` deprecated?\nNo, `setup.py` and Setuptools are not deprecated. Setuptools is perfectly usable as a build backend for packaging Python projects. And `setup.py` is a valid configuration file for Setuptools that happens to be written in Python, instead of in TOML for example. However, `python setup.py` and the use of `setup.py` as a command line tool are deprecated. This means that commands such as the following MUST NOT be run anymore:\n\n- `python setup.py install`\n- `python setup.py develop`\n- `python setup.py sdist`\n- `python setup.py bdist_wheel`\n\n## What commands should be used instead?\n| Deprecated | Recommendation |\n| --- | --- |\n| `python setup.py install` | `python -m pip install .` |\n| `python setup.py develop` | `python -m pip install --editable .` |\n| `python setup.py sdist` | `python -m build` [1] |\n| `python setup.py bdist_wheel` |  \n\nIn order to install a setuptools based project, it was common to run `setup.py`’s `install` command such as: `python setup.py install`. Nowadays, the recommended method is to use pip directly with a command like this one: `python -m pip install .`. Where the dot `.` is actually a file system path, it is the path notation for the current directory. Indeed, pip accepts a path to a project’s source tree directory on the local filesystem as argument to its `install` sub-command. So this would also be a valid command: `python -m pip install path/to/project`. As for the installation in develop mode aka editable mode, instead of `python setup.py develop` one can use the `--editable` option of pip’s install sub-command: `python -m pip install --editable .`. One recommended, simple, and straightforward method of building source distributions and wheels is to use the build tool with a command like `python -m build` which triggers the generation of both distribution formats. If necessary the `--sdist` and `--wheel` options can be used to generate only one or the other. Note that the build tool needs to be installed separately. The command `python setup.py install` was deprecated in setuptools version 58.3.0.\n\n## What about other commands?\nWhat are some replacements for the other `python setup.py` commands?\n\n### `python setup.py test`\nThe recommendation is to use a test runner such as pytest.\n\n### `python setup.py check`, `python setup.py register`, and `python setup.py upload`\nA trusted replacement is twine:\n\n- `python -m twine check --strict dist/*`\n- `python -m twine register dist/*.whl` [2]\n- `python -m twine upload dist/*`\n\n### `python setup.py --version`\nA possible replacement solution (among others) is to rely on setuptools-scm:\n\n- `python -m setuptools_scm`\n\n### Remaining commands\nThis guide does not make suggestions of replacement solutions for those commands:\n\n|     |     |     |     |\n| --- | --- | --- | --- |\n| - `alias`<br>  <br>- `bdist`<br>  <br>- `bdist_dumb`<br>  <br>- `bdist_egg`<br>  <br>- `bdist_rpm`<br>  <br>- `build` | - `build_clib`<br>  <br>- `build_ext`<br>  <br>- `build_py`<br>  <br>- `build_scripts`<br>  <br>- `clean`<br>  <br>- `dist_info` | - `easy_install`<br>  <br>- `editable_wheel`<br>  <br>- `egg_info`<br>  <br>- `install_data`<br>  <br>- `install_egg_info`<br>  <br>- `install_headers` | - `install_lib`<br>  <br>- `install_scripts`<br>  <br>- `rotate`<br>  <br>- `saveopts`<br>  <br>- `setopt`<br>  <br>- `upload_docs` |\n\n## What about custom commands?\nLikewise, custom `setup.py` commands are deprecated. The recommendation is to migrate those custom commands to a task runner tool or any other similar tool. Some examples of such tools are: chuy, make, nox or tox, pydoit, pyinvoke, taskipy, and thx.\n\n## What about custom build steps?\nCustom build steps that for example either overwrite existing steps such as `build_py`, `build_ext`, and `bdist_wheel` or add new build steps are not deprecated. Those will be automatically called as expected.\n\n## Should `setup.py` be deleted?\nAlthough the usage of `setup.py` as an executable script is deprecated, its usage as a configuration file for setuptools is absolutely fine. There is likely no modification needed in `setup.py`.\n\n## Is `pyproject.toml` mandatory?\nWhile it is not technically necessary yet, it is STRONGLY RECOMMENDED for a project to have a `pyproject.toml` file at the root of its source tree with a content like this:\n\n```\n[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n```\n\nThe guide [How to modernize a setup.py based project?](https://packaging.python.org/en/latest/guides/modernize-setup-py-project/#modernize-setup-py-project) has more details about this. The standard fallback behavior for a build frontend in the absence of a `pyproject.toml` file and its `[build-system]` table is to assume that the build backend is setuptools.\n\n## Why? What does it all mean?\nOne way to look at it is that the scope of setuptools has now been reduced to the role of a build backend.\n\n## Where to read more about this?\n- [Why you shouldn’t invoke setup.py directly](https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html) by Paul Ganssle\n- [Running setuptools commands](https://setuptools.pypa.io/en/latest/deprecated/commands.html) (in setuptools v75.8.1.post20250225)\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "title": "Is `setup.py` deprecated?", "description": "This page discusses the deprecation status of `setup.py` and provides recommendations for using alternative commands and tools for packaging Python projects.", "has_code_examples": true, "has_best_practices": true, "section_count": 9, "timestamp": "2025-02-27 22:54:18", "type": "overview", "page_metadata": {"language": "en", "readthedocs-version-slug": "latest", "color-scheme": "light dark", "title": "Is setup.py deprecated? - Python Packaging User Guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-resolver-filename": "/discussions/setup-py-deprecated/", "readthedocs-http-status": "200", "scrapeId": "9b4252dd-0592-422f-a5a9-68e03d642ca5", "sourceURL": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"Is `setup.py` deprecated?\"?\n\nAssistant: Here are some code examples:\n\n### Recommended command for installation\n```yaml\npython -m pip install .\n```\n\n### Recommended command for editable installation\n```yaml\npython -m pip install --editable .\n```\n\n### Recommended command for building distributions\n```yaml\npython -m build\n```\n\n### Replacement for `python setup.py test`\n```yaml\npytest\n```\n\n### Replacement for `python setup.py check`\n```yaml\npython -m twine check --strict dist/*\n```\n\n### Replacement for `python setup.py register`\n```yaml\npython -m twine register dist/*.whl\n```\n\n### Replacement for `python setup.py upload`\n```yaml\npython -m twine upload dist/*\n```\n\n### Replacement for `python setup.py --version`\n```yaml\npython -m setuptools_scm\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "title": "Is `setup.py` deprecated?", "description": "This page discusses the deprecation status of `setup.py` and provides recommendations for using alternative commands and tools for packaging Python projects.", "has_code_examples": true, "has_best_practices": true, "section_count": 9, "timestamp": "2025-02-27 22:54:18", "type": "code_examples", "page_metadata": {"language": "en", "readthedocs-version-slug": "latest", "color-scheme": "light dark", "title": "Is setup.py deprecated? - Python Packaging User Guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-resolver-filename": "/discussions/setup-py-deprecated/", "readthedocs-http-status": "200", "scrapeId": "9b4252dd-0592-422f-a5a9-68e03d642ca5", "sourceURL": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"Is `setup.py` deprecated?\"?\n\nAssistant: Here are the recommended best practices:\n\n• It is strongly recommended to have a `pyproject.toml` file at the root of the source tree.\n• Use pip directly for installation instead of `setup.py`.\n• Migrate custom `setup.py` commands to task runner tools.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "title": "Is `setup.py` deprecated?", "description": "This page discusses the deprecation status of `setup.py` and provides recommendations for using alternative commands and tools for packaging Python projects.", "has_code_examples": true, "has_best_practices": true, "section_count": 9, "timestamp": "2025-02-27 22:54:18", "type": "best_practices", "page_metadata": {"language": "en", "readthedocs-version-slug": "latest", "color-scheme": "light dark", "title": "Is setup.py deprecated? - Python Packaging User Guide", "favicon": "https://packaging.python.org/en/_static/py.png", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-project-slug": "python-packaging-user-guide", "readthedocs-resolver-filename": "/discussions/setup-py-deprecated/", "readthedocs-http-status": "200", "scrapeId": "9b4252dd-0592-422f-a5a9-68e03d642ca5", "sourceURL": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated", "url": "https://packaging.python.org/en/latest/discussions/setup-py-deprecated/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What is \"src layout vs flat layout\"?\n\nAssistant: This page discusses the differences between the src layout and flat layout for organizing a Python project’s files.\n\nHere's a detailed explanation:\n\n\n## src layout vs flat layout\nThe “flat layout” refers to organising a project’s files in a folder or repository, such that the various configuration files and import packages are all in the top-level directory.\n\n```\n.\n├── README.md\n├── noxfile.py\n├── pyproject.toml\n├── setup.py\n├── awesome_package/\n│   ├── __init__.py\n│   └── module.py\n└── tools/\n    ├── generate_awesomeness.py\n    └── decrease_world_suck.py\n```\n\nThe “src layout” deviates from the flat layout by moving the code that is intended to be importable (i.e. `import awesome_package`, also known as import packages) into a subdirectory. This subdirectory is typically named `src/`, hence “src layout”.\n\n```\n.\n├── README.md\n├── noxfile.py\n├── pyproject.toml\n├── setup.py\n├── src/\n│    └── awesome_package/\n│       ├── __init__.py\n│       └── module.py\n└── tools/\n    ├── generate_awesomeness.py\n    └── decrease_world_suck.py\n```\n\nHere’s a breakdown of the important behaviour differences between the src layout and the flat layout:\n\n- The src layout requires installation of the project to be able to run its code, and the flat layout does not.\n\nThis means that the src layout involves an additional step in the development workflow of a project (typically, an editable installation is used for development and a regular installation is used for testing).\n\n- The src layout helps prevent accidental usage of the in-development copy of the code.\n\nThis is relevant since the Python interpreter includes the current working directory as the first item on the import path. This means that if an import package exists in the current working directory with the same name as an installed import package, the variant from the current working directory will be used. This can lead to subtle misconfiguration of the project’s packaging tooling, which could result in files not being included in a distribution.\n\nThe src layout helps avoid this by keeping import packages in a directory separate from the root directory of the project, ensuring that the installed copy is used.\n\n- The src layout helps enforce that an editable installation is only able to import files that were meant to be importable.\n\nThis is especially relevant when the editable installation is implemented using a path configuration file that adds the directory to the import path.\n\nThe flat layout would add the other project files (eg: `README.md`, `tox.ini`) and packaging/tooling configuration files (eg: `setup.py`, `noxfile.py`) on the import path. This would make certain imports work in editable installations but not regular installations.\n\n## Running a command-line interface from source with src-layout\nDue to the firstly mentioned specialty of the src layout, a command-line interface can not be run directly from the source tree, but requires installation of the package in Development Mode for testing purposes. Since this can be unpractical in some situations, a workaround could be to prepend the package folder to Python’s `sys.path` when called via its `__main__.py` file:\n\n```\nimport os\nimport sys\n\nif not __package__:\n    # Make CLI runnable from source tree with\n    #    python src/package\n    package_source_path = os.path.dirname(os.path.dirname(__file__))\n    sys.path.insert(0, package_source_path)\n```\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "title": "src layout vs flat layout", "description": "This page discusses the differences between the src layout and flat layout for organizing a Python project’s files.", "has_code_examples": true, "has_best_practices": true, "section_count": 2, "timestamp": "2025-02-27 22:54:56", "type": "overview", "page_metadata": {"readthedocs-version-slug": "latest", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-resolver-filename": "/discussions/src-layout-vs-flat-layout/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "color-scheme": "light dark", "title": "src layout vs flat layout - Python Packaging User Guide", "readthedocs-project-slug": "python-packaging-user-guide", "scrapeId": "b7cf27be-d78c-4e19-b726-fd00e5c38082", "sourceURL": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: Can you show me some code examples for \"src layout vs flat layout\"?\n\nAssistant: Here are some code examples:\n\n### Flat Layout Example\n```yaml\n```\n.\n├── README.md\n├── noxfile.py\n├── pyproject.toml\n├── setup.py\n├── awesome_package/\n│   ├── __init__.py\n│   └── module.py\n└── tools/\n    ├── generate_awesomeness.py\n    └── decrease_world_suck.py\n```\n```\n\n### Src Layout Example\n```yaml\n```\n.\n├── README.md\n├── noxfile.py\n├── pyproject.toml\n├── setup.py\n├── src/\n│    └── awesome_package/\n│       ├── __init__.py\n│       └── module.py\n└── tools/\n    ├── generate_awesomeness.py\n    └── decrease_world_suck.py\n```\n```\n\n### Command-Line Interface Workaround\n```yaml\n```\nimport os\nimport sys\n\nif not __package__:\n    # Make CLI runnable from source tree with\n    #    python src/package\n    package_source_path = os.path.dirname(os.path.dirname(__file__))\n    sys.path.insert(0, package_source_path)\n```\n```\n\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "title": "src layout vs flat layout", "description": "This page discusses the differences between the src layout and flat layout for organizing a Python project’s files.", "has_code_examples": true, "has_best_practices": true, "section_count": 2, "timestamp": "2025-02-27 22:54:56", "type": "code_examples", "page_metadata": {"readthedocs-version-slug": "latest", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-resolver-filename": "/discussions/src-layout-vs-flat-layout/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "color-scheme": "light dark", "title": "src layout vs flat layout - Python Packaging User Guide", "readthedocs-project-slug": "python-packaging-user-guide", "scrapeId": "b7cf27be-d78c-4e19-b726-fd00e5c38082", "sourceURL": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/", "statusCode": 200}}}
{"text": "System: You are a helpful Python Packaging expert.\n\nUser: What are the best practices for \"src layout vs flat layout\"?\n\nAssistant: Here are the recommended best practices:\n\n• The src layout requires installation of the project to be able to run its code, while the flat layout does not.\n• The src layout helps prevent accidental usage of the in-development copy of the code by keeping import packages in a separate directory.\n• The src layout enforces that an editable installation can only import files that were meant to be importable.\n", "metadata": {"source_url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "title": "src layout vs flat layout", "description": "This page discusses the differences between the src layout and flat layout for organizing a Python project’s files.", "has_code_examples": true, "has_best_practices": true, "section_count": 2, "timestamp": "2025-02-27 22:54:56", "type": "best_practices", "page_metadata": {"readthedocs-version-slug": "latest", "viewport": ["width=device-width,initial-scale=1", "width=device-width, initial-scale=1"], "readthedocs-http-status": "200", "readthedocs-resolver-filename": "/discussions/src-layout-vs-flat-layout/", "language": "en", "favicon": "https://packaging.python.org/en/_static/py.png", "color-scheme": "light dark", "title": "src layout vs flat layout - Python Packaging User Guide", "readthedocs-project-slug": "python-packaging-user-guide", "scrapeId": "b7cf27be-d78c-4e19-b726-fd00e5c38082", "sourceURL": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout", "url": "https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/", "statusCode": 200}}}
