{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what PostCSS Plugin Guidelines is in postcss?\n\nAssistant: Sure, I'd be happy to explain PostCSS Plugin Guidelines in postcss.\n\n# PostCSS Plugin Guidelines\n\nA PostCSS plugin is a function that receives and, usually, transforms a CSS AST from the PostCSS parser. The rules below are mandatory for all PostCSS plugins.Here's a quick rundown of what this is about:\n\n## 1. API\n\n### 1.1 Clear name with `postcss-` prefix\nThe plugin’s purpose should be clear just by reading its name. If you wrote a transpiler for CSS 4 Custom Media, `postcss-custom-media` would be a good name. If you wrote a plugin to support mixins, `postcss-mixins` would be a good name.\n\nThe prefix `postcss-` shows that the plugin is part of the PostCSS ecosystem.\n\nThis rule is not mandatory for plugins that can run as independent tools, without the user necessarily knowing that it is powered by PostCSS — for example, [RTLCSS](https://rtlcss.com/) and [Autoprefixer](https://github.com/postcss/autoprefixer).\n\n### 1.2. Do one thing, and do it well\nDo not create multitool plugins. Several small, one-purpose plugins bundled into a plugin pack is usually a better solution.\n\nFor example, [`postcss-preset-env`](https://preset-env.cssdb.org/) contains many small plugins, one for each W3C specification. And [`cssnano`](https://github.com/cssnano/cssnano) contains a separate plugin for each of its optimization.\n\n### 1.3. Do not use mixins\nPreprocessors libraries like Compass provide an API with mixins.\n\nPostCSS plugins are different. A plugin cannot be just a set of mixins for [`postcss-mixins`](https://github.com/postcss/postcss-mixins).\n\nTo achieve your goal, consider transforming valid CSS or using custom at-rules and custom properties.\n\n### 1.4. Keep `postcss` to `peerDependencies`\nAST can be broken because of different `postcss` version in different plugins. Different plugins could use a different node creators (like `postcss.decl()`).\n\n```json\n{\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  }\n}\n```\n\nIt is better even not to import `postcss`.\n\n```diff\n- const { list, decl } = require('postcss')\n  module.exports = opts => {\n    postcssPlugin: 'postcss-name',\n-   Once (root) {\n+   Once (root, { list, decl }) {\n      // Plugin code\n    }\n  }\n  module.exports.postcss = true\n```\n\n### 1.5. Set `plugin.postcssPlugin` with plugin name\nPlugin name will be used in error messages and warnings.\n\n```js\nmodule.exports = opts => {\n  return {\n    postcssPlugin: 'postcss-name',\n    Once (root) {\n      // Plugin code\n    }\n  }\n}\nmodule.exports.postcss = true\n\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs/postcss-plugin-guidelines", "title": "PostCSS Plugin Guidelines", "description": "A PostCSS plugin is a function that receives and, usually, transforms a CSS AST from the PostCSS parser. The rules below are mandatory for all PostCSS plugins.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-28 22:08:24", "type": "overview", "page_metadata": {"ogImage": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "language": "en", "twitter:card": "summary", "twitter:creator": "@postcss", "title": "PostCSS Plugin Guidelines", "og:type": "article", "scrapeId": "1da14ae0-2600-43c1-9b7f-d22dd6cced8a", "sourceURL": "https://postcss.org/docs/postcss-plugin-guidelines", "url": "https://postcss.org/docs/postcss-plugin-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 1. api in postcss?\n\nAssistant: To 1. api in postcss, here's what you do:\n### 1.1 Clear name with `postcss-` prefix\nThe plugin’s purpose should be clear just by reading its name. If you wrote a transpiler for CSS 4 Custom Media, `postcss-custom-media` would be a good name. If you wrote a plugin to support mixins, `postcss-mixins` would be a good name.\n\nThe prefix `postcss-` shows that the plugin is part of the PostCSS ecosystem.\n\nThis rule is not mandatory for plugins that can run as independent tools, without the user necessarily knowing that it is powered by PostCSS — for example, [RTLCSS](https://rtlcss.com/) and [Autoprefixer](https://github.com/postcss/autoprefixer).\n\n### 1.2. Do one thing, and do it well\nDo not create multitool plugins. Several small, one-purpose plugins bundled into a plugin pack is usually a better solution.\n\nFor example, [`postcss-preset-env`](https://preset-env.cssdb.org/) contains many small plugins, one for each W3C specification. And [`cssnano`](https://github.com/cssnano/cssnano) contains a separate plugin for each of its optimization.\n\n### 1.3. Do not use mixins\nPreprocessors libraries like Compass provide an API with mixins.\n\nPostCSS plugins are different. A plugin cannot be just a set of mixins for [`postcss-mixins`](https://github.com/postcss/postcss-mixins).\n\nTo achieve your goal, consider transforming valid CSS or using custom at-rules and custom properties.\n\n### 1.4. Keep `postcss` to `peerDependencies`\nAST can be broken because of different `postcss` version in different plugins. Different plugins could use a different node creators (like `postcss.decl()`).\n\n```json\n{\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  }\n}\n```\n\nIt is better even not to import `postcss`.\n\n```diff\n- const { list, decl } = require('postcss')\n  module.exports = opts => {\n    postcssPlugin: 'postcss-name',\n-   Once (root) {\n+   Once (root, { list, decl }) {\n      // Plugin code\n    }\n  }\n  module.exports.postcss = true\n```\n\n### 1.5. Set `plugin.postcssPlugin` with plugin name\nPlugin name will be used in error messages and warnings.\n\n```js\nmodule.exports = opts => {\n  return {\n    postcssPlugin: 'postcss-name',\n    Once (root) {\n      // Plugin code\n    }\n  }\n}\nmodule.exports.postcss = true\n.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-plugin-guidelines", "title": "PostCSS Plugin Guidelines", "description": "A PostCSS plugin is a function that receives and, usually, transforms a CSS AST from the PostCSS parser. The rules below are mandatory for all PostCSS plugins.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-28 22:08:24", "type": "section_detail", "page_metadata": {"ogImage": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "language": "en", "twitter:card": "summary", "twitter:creator": "@postcss", "title": "PostCSS Plugin Guidelines", "og:type": "article", "scrapeId": "1da14ae0-2600-43c1-9b7f-d22dd6cced8a", "sourceURL": "https://postcss.org/docs/postcss-plugin-guidelines", "url": "https://postcss.org/docs/postcss-plugin-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you give me some code examples for PostCSS Plugin Guidelines in postcss?\n\nAssistant: Absolutely! Here are some practical examples to help you out:\n\n**Peer Dependencies Example**:\n\n```yaml\n{\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  }\n}\n```\n\nThis snippet shows you how to peer dependencies example, which is an important aspect of postcss plugin guidelines.\n\n**Importing PostCSS Example**:\n\n```yaml\n```diff\n- const { list, decl } = require('postcss')\n  module.exports = opts => {\n    postcssPlugin: 'postcss-name',\n-   Once (root) {\n+   Once (root, { list, decl }) {\n      // Plugin code\n    }\n  }\n  module.exports.postcss = true\n```\n```\n\nThis snippet shows you how to importing postcss example, which is an important aspect of postcss plugin guidelines.\n\n**Setting Plugin Name Example**:\n\n```yaml\n```js\nmodule.exports = opts => {\n  return {\n    postcssPlugin: 'postcss-name',\n    Once (root) {\n      // Plugin code\n    }\n  }\n}\nmodule.exports.postcss = true\n```\n```\n\nThis snippet shows you how to setting plugin name example, which is an important aspect of postcss plugin guidelines.\n\n**Asynchronous Method Example**:\n\n```yaml\nlet { readFile } = require('fs').promises\n\nmodule.exports = opts => {\n  return {\n    postcssPlugin: 'plugin-inline',\n    async Decl (decl) {\n      const imagePath = findImage(decl)\n      if (imagePath) {\n        let imageFile = await readFile(imagePath)\n        decl.value = replaceUrl(decl.value, imageFile)\n      }\n    }\n  }\n}\nmodule.exports.postcss = true\n\n```\n\nThis snippet shows you how to asynchronous method example, which is an important aspect of postcss plugin guidelines.\n\n", "metadata": {"source_url": "https://postcss.org/docs/postcss-plugin-guidelines", "title": "PostCSS Plugin Guidelines", "description": "A PostCSS plugin is a function that receives and, usually, transforms a CSS AST from the PostCSS parser. The rules below are mandatory for all PostCSS plugins.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-28 22:08:24", "type": "code_examples", "page_metadata": {"ogImage": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "language": "en", "twitter:card": "summary", "twitter:creator": "@postcss", "title": "PostCSS Plugin Guidelines", "og:type": "article", "scrapeId": "1da14ae0-2600-43c1-9b7f-d22dd6cced8a", "sourceURL": "https://postcss.org/docs/postcss-plugin-guidelines", "url": "https://postcss.org/docs/postcss-plugin-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: What are some tips for using PostCSS Plugin Guidelines in postcss effectively?\n\nAssistant: Great question! Here are some tips to keep in mind:\n\nUse clear names with the `postcss-` prefix for plugins.\n\nCreate single-purpose plugins instead of multitool plugins.\n\nAvoid using mixins in PostCSS plugins.\n\nKeep `postcss` as a peer dependency to avoid version conflicts.\n\nSet `plugin.postcssPlugin` with the plugin name for error messages.\n\nTest plugins in different environments using CI services like Travis.\n\nUse asynchronous methods whenever possible for file operations.\n\nUtilize fast node scanning techniques for better performance.\n\nSet `node.source` for new nodes to ensure accurate source maps.\n\nUse only the public PostCSS API to avoid breaking changes.\n\nSpecify dependencies using messages in the result object.\n\nUse `node.error` for CSS relevant errors and `result.warn` for warnings.\n\nDocument plugins in English and include input/output examples in the README.\n\nMaintain a changelog for plugin releases and use SemVer for versioning.\n\nInclude the `postcss-plugin` keyword in `package.json` for npm packages.\n\nStick to these, and you'll avoid a lot of headaches!", "metadata": {"source_url": "https://postcss.org/docs/postcss-plugin-guidelines", "title": "PostCSS Plugin Guidelines", "description": "A PostCSS plugin is a function that receives and, usually, transforms a CSS AST from the PostCSS parser. The rules below are mandatory for all PostCSS plugins.", "has_code_examples": true, "has_best_practices": true, "section_count": 1, "timestamp": "2025-02-28 22:08:24", "type": "best_practices", "page_metadata": {"ogImage": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "language": "en", "twitter:card": "summary", "twitter:creator": "@postcss", "title": "PostCSS Plugin Guidelines", "og:type": "article", "scrapeId": "1da14ae0-2600-43c1-9b7f-d22dd6cced8a", "sourceURL": "https://postcss.org/docs/postcss-plugin-guidelines", "url": "https://postcss.org/docs/postcss-plugin-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what PostCSS Runner Guidelines is in postcss?\n\nAssistant: Sure, I'd be happy to explain PostCSS Runner Guidelines in postcss.\n\n# PostCSS Runner Guidelines\n\nA PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.Here's a quick rundown of what this is about:\n\n## 1. API\n\n### 1.1. Accept functions in plugin parameters\nIf your runner uses a config file, it must be written in JavaScript, so that it can support plugins which accept a function, such as [`postcss-assets`](https://github.com/borodean/postcss-assets):\n\n```code js\nmodule.exports = [\\\n  require('postcss-assets')({\\\n    cachebuster: function (file) {\\\n      return fs.statSync(file).mtime.getTime().toString(16)\\\n    }\\\n  })\\\n]\n```\n\n## 2. Processing\n\n### 2.1. Set `from` and `to` processing options\nTo ensure that PostCSS generates source maps and displays better syntax errors, runners must specify the `from` and `to` options. If your runner does not handle writing to disk (for example, a gulp transform), you should set both options to point to the same file:\n\n```code js\nprocessor.process({ from: file.path, to: file.path })\n```\n\n### 2.2. Use only the asynchronous API\nPostCSS runners must use only the asynchronous API. The synchronous API is provided only for debugging, is slower, and can’t work with asynchronous plugins.\n\n```code js\nprocessor.process(opts).then(result => {\n  // processing is finished\n});\n```\n\n### 2.3. Use only the public PostCSS API\nPostCSS runners must not rely on undocumented properties or methods, which may be subject to change in any minor release. The public API is described in [API docs](https://postcss.org/api/).\n\n## 3. Dependencies\n\n### 3.1. Rebuild when dependencies change\nPostCSS plugins may declare file or directory dependencies by attaching messages to the `result`. Runners should watch these and ensure that the CSS is rebuilt when they change.\n\n```code js\nfor (let message of result.messages) {\n  if (message.type === 'dependency') {\n    watcher.addFile(message.file)\n  } else if (message.type === 'dir-dependency' && message.glob) {\n    watcher.addPattern(file.join(message.dir, message.glob))\n  } else if (message.type === 'dir-dependency') {\n    watcher.addPattern(file.join(message.dir, '**', '*'))\n  }\n}\n```\n\nDirectories should be watched recursively by default, but `dir-dependency` messages may contain an optional `glob` property indicating which files within the directory are depended on (e.g. `**/*.css`). If `glob` is specified then runners should only watch files matching the glob pattern, where possible.\n\n## 4. Output\n\n### 4.1. Don’t show JS stack for `CssSyntaxError`\nPostCSS runners must not show a stack trace for CSS syntax errors, as the runner can be used by developers who are not familiar with JavaScript. Instead, handle such errors gracefully:\n\n```code js\nprocessor.process(opts).catch(error => {\n  if (error.name === 'CssSyntaxError') {\n    process.stderr.write(error.message + error.showSourceCode())\n  } else {\n    throw error\n  }\n})\n```\n\n### 4.2. Display `result.warnings()`\nPostCSS runners must output warnings from `result.warnings()`:\n\n```code js\nresult.warnings().forEach(warn => {\n  process.stderr.write(warn.toString())\n})\n```\n\nSee also [postcss-log-warnings](https://github.com/davidtheclark/postcss-log-warnings) and [postcss-messages](https://github.com/postcss/postcss-messages) plugins.\n\n### 4.3. Allow the user to write source maps to different files\nPostCSS by default will inline source maps in the generated file; however, PostCSS runners must provide an option to save the source map in a different file:\n\n```code js\nif (result.map) {\n  fs.writeFile(opts.to + '.map', result.map.toString())\n}\n```\n\n## 5. Documentation\n\n### 5.1. Document your runner in English\nPostCSS runners must have their `README.md` written in English. Do not be afraid of your English skills, as the open source community will fix your errors.\n\nOf course, you are welcome to write documentation in other languages; just name them appropriately (e.g. `README.ja.md`).\n\n### 5.2. Maintain a changelog\nPostCSS runners must describe changes of all releases in a separate file, such as `ChangeLog.md`, `History.md`, or with [GitHub Releases](https://help.github.com/articles/creating-releases/). Visit [Keep A Changelog](https://keepachangelog.com/) for more information on how to write one of these.\n\nOf course, you should use [SemVer](https://semver.org/).\n\n### 5.3. `postcss-runner` keyword in `package.json`\nPostCSS runners written for npm must have the `postcss-runner` keyword in their `package.json`. This special keyword will be useful for feedback about the PostCSS ecosystem.\n\nFor packages not published to npm, this is not mandatory, but recommended if the package format is allowed to contain keywords.\n\n### 5.4. Keep `postcss` to `peerDependencies`\nAST can be broken because of different `postcss` version in different plugins. Different plugins could use a different node creators (like `postcss.decl()`).\n\n```code json\n{\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  }\n}\n```\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "overview", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 1. api in postcss?\n\nAssistant: To 1. api in postcss, here's what you do:\n### 1.1. Accept functions in plugin parameters\nIf your runner uses a config file, it must be written in JavaScript, so that it can support plugins which accept a function, such as [`postcss-assets`](https://github.com/borodean/postcss-assets):\n\n```code js\nmodule.exports = [\\\n  require('postcss-assets')({\\\n    cachebuster: function (file) {\\\n      return fs.statSync(file).mtime.getTime().toString(16)\\\n    }\\\n  })\\\n]\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "section_detail", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 2. processing in postcss?\n\nAssistant: To 2. processing in postcss, here's what you do:\n### 2.1. Set `from` and `to` processing options\nTo ensure that PostCSS generates source maps and displays better syntax errors, runners must specify the `from` and `to` options. If your runner does not handle writing to disk (for example, a gulp transform), you should set both options to point to the same file:\n\n```code js\nprocessor.process({ from: file.path, to: file.path })\n```\n\n### 2.2. Use only the asynchronous API\nPostCSS runners must use only the asynchronous API. The synchronous API is provided only for debugging, is slower, and can’t work with asynchronous plugins.\n\n```code js\nprocessor.process(opts).then(result => {\n  // processing is finished\n});\n```\n\n### 2.3. Use only the public PostCSS API\nPostCSS runners must not rely on undocumented properties or methods, which may be subject to change in any minor release. The public API is described in [API docs](https://postcss.org/api/)..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "section_detail", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 3. dependencies in postcss?\n\nAssistant: To 3. dependencies in postcss, here's what you do:\n### 3.1. Rebuild when dependencies change\nPostCSS plugins may declare file or directory dependencies by attaching messages to the `result`. Runners should watch these and ensure that the CSS is rebuilt when they change.\n\n```code js\nfor (let message of result.messages) {\n  if (message.type === 'dependency') {\n    watcher.addFile(message.file)\n  } else if (message.type === 'dir-dependency' && message.glob) {\n    watcher.addPattern(file.join(message.dir, message.glob))\n  } else if (message.type === 'dir-dependency') {\n    watcher.addPattern(file.join(message.dir, '**', '*'))\n  }\n}\n```\n\nDirectories should be watched recursively by default, but `dir-dependency` messages may contain an optional `glob` property indicating which files within the directory are depended on (e.g. `**/*.css`). If `glob` is specified then runners should only watch files matching the glob pattern, where possible..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "section_detail", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 4. output in postcss?\n\nAssistant: To 4. output in postcss, here's what you do:\n### 4.1. Don’t show JS stack for `CssSyntaxError`\nPostCSS runners must not show a stack trace for CSS syntax errors, as the runner can be used by developers who are not familiar with JavaScript. Instead, handle such errors gracefully:\n\n```code js\nprocessor.process(opts).catch(error => {\n  if (error.name === 'CssSyntaxError') {\n    process.stderr.write(error.message + error.showSourceCode())\n  } else {\n    throw error\n  }\n})\n```\n\n### 4.2. Display `result.warnings()`\nPostCSS runners must output warnings from `result.warnings()`:\n\n```code js\nresult.warnings().forEach(warn => {\n  process.stderr.write(warn.toString())\n})\n```\n\nSee also [postcss-log-warnings](https://github.com/davidtheclark/postcss-log-warnings) and [postcss-messages](https://github.com/postcss/postcss-messages) plugins.\n\n### 4.3. Allow the user to write source maps to different files\nPostCSS by default will inline source maps in the generated file; however, PostCSS runners must provide an option to save the source map in a different file:\n\n```code js\nif (result.map) {\n  fs.writeFile(opts.to + '.map', result.map.toString())\n}\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "section_detail", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I 5. documentation in postcss?\n\nAssistant: To 5. documentation in postcss, here's what you do:\n### 5.1. Document your runner in English\nPostCSS runners must have their `README.md` written in English. Do not be afraid of your English skills, as the open source community will fix your errors.\n\nOf course, you are welcome to write documentation in other languages; just name them appropriately (e.g. `README.ja.md`).\n\n### 5.2. Maintain a changelog\nPostCSS runners must describe changes of all releases in a separate file, such as `ChangeLog.md`, `History.md`, or with [GitHub Releases](https://help.github.com/articles/creating-releases/). Visit [Keep A Changelog](https://keepachangelog.com/) for more information on how to write one of these.\n\nOf course, you should use [SemVer](https://semver.org/).\n\n### 5.3. `postcss-runner` keyword in `package.json`\nPostCSS runners written for npm must have the `postcss-runner` keyword in their `package.json`. This special keyword will be useful for feedback about the PostCSS ecosystem.\n\nFor packages not published to npm, this is not mandatory, but recommended if the package format is allowed to contain keywords.\n\n### 5.4. Keep `postcss` to `peerDependencies`\nAST can be broken because of different `postcss` version in different plugins. Different plugins could use a different node creators (like `postcss.decl()`).\n\n```code json\n{\n  \"peerDependencies\": {\n    \"postcss\": \"^8.0.0\"\n  }\n}\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "section_detail", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you give me some code examples for PostCSS Runner Guidelines in postcss?\n\nAssistant: Absolutely! Here are some practical examples to help you out:\n\n**Accept functions in plugin parameters**:\n\n```yaml\nmodule.exports = [\\\n  require('postcss-assets')({\\\n    cachebuster: function (file) {\\\n      return fs.statSync(file).mtime.getTime().toString(16)\\\n    }\\\n  })\\\n]\n```\n\nThis snippet shows you how to accept functions in plugin parameters, which is an important aspect of postcss runner guidelines.\n\n**Set `from` and `to` processing options**:\n\n```yaml\nprocessor.process({ from: file.path, to: file.path })\n```\n\nThis snippet shows you how to set `from` and `to` processing options, which is an important aspect of postcss runner guidelines.\n\n**Use only the asynchronous API**:\n\n```yaml\nprocessor.process(opts).then(result => {\n  // processing is finished\n});\n```\n\nThis snippet shows you how to use only the asynchronous api, which is an important aspect of postcss runner guidelines.\n\n**Rebuild when dependencies change**:\n\n```yaml\nfor (let message of result.messages) {\n  if (message.type === 'dependency') {\n    watcher.addFile(message.file)\n  } else if (message.type === 'dir-dependency' && message.glob) {\n    watcher.addPattern(file.join(message.dir, message.glob))\n  } else if (message.type === 'dir-dependency') {\n    watcher.addPattern(file.join(message.dir, '**', '*'))\n  }\n}\n```\n\nThis snippet shows you how to rebuild when dependencies change, which is an important aspect of postcss runner guidelines.\n\n", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "code_examples", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: What are some tips for using PostCSS Runner Guidelines in postcss effectively?\n\nAssistant: Great question! Here are some tips to keep in mind:\n\nFor single-plugin tools, these rules are not mandatory but are highly recommended.\n\nDocument your runner in English and maintain a changelog.\n\nUse the `postcss-runner` keyword in `package.json` for npm packages.\n\nStick to these, and you'll avoid a lot of headaches!", "metadata": {"source_url": "https://postcss.org/docs/postcss-runner-guidelines", "title": "PostCSS Runner Guidelines", "description": "A PostCSS runner is a tool that processes CSS through a user-defined list of plugins; these rules are mandatory for any such runners.", "has_code_examples": true, "has_best_practices": true, "section_count": 5, "timestamp": "2025-02-28 22:08:47", "type": "best_practices", "page_metadata": {"og:url": "http://postcss.org/", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "language": "en", "twitter:card": "summary", "ogImage": "./base/og.jpg", "viewport": "width=device-width, initial-scale=1", "twitter:site": "@postcss", "og:type": "article", "twitter:creator": "@postcss", "og:image": "./base/og.jpg", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "title": "PostCSS Runner Guidelines", "ogUrl": "http://postcss.org/", "scrapeId": "1443ddf7-bb54-4d00-86fb-90525a191e31", "sourceURL": "https://postcss.org/docs/postcss-runner-guidelines", "url": "https://postcss.org/docs/postcss-runner-guidelines", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what How to Write Custom Syntax is in postcss?\n\nAssistant: Sure, I'd be happy to explain How to Write Custom Syntax in postcss.\n\n# How to Write Custom Syntax\n\nPostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.Here's a quick rundown of what this is about:\n\n## Syntax\n\nA good example of a custom syntax is [SCSS](https://github.com/postcss/postcss-scss). Some users may want to transform SCSS sources with PostCSS plugins, for example if they need to add vendor prefixes or change the property order. So this syntax should output SCSS from an SCSS input.\n\nThe syntax API is a very simple plain object, with `parse` & `stringify` functions:\n\n```code js\nmodule.exports = {\n  parse:     require('./parse'),\n  stringify: require('./stringify')\n}\n```\n\n\n## Parser\n\nA good example of a parser is [Safe Parser](https://github.com/postcss/postcss-safe-parser), which parses malformed/broken CSS. Because there is no point to generate broken output, this package only provides a parser.\n\nThe parser API is a function which receives a string & returns a [`Root`](https://postcss.org/api/#root) or [`Document`](https://postcss.org/api/#document) node. The second argument is a function which receives an object with PostCSS options.\n\n```code js\nconst postcss = require('postcss')\n\nmodule.exports = function parse (css, opts) {\n  const root = postcss.root()\n  // Add other nodes to root\n  return root\n}\n```\n\nFor open source parser npm package must have `postcss` in `peerDependencies`, not in direct `dependencies`.\n\n### Main Theory\n\nThere are many books about parsers; but do not worry because CSS syntax is very easy, and so the parser will be much simpler than a programming language parser.\n\nThe default PostCSS parser contains two steps:\n\n1. [Tokenizer](https://github.com/postcss/postcss/blob/main/lib/tokenize.js) which reads input string character by character and builds a tokens array. For example, it joins space symbols to a `['space', '\\n  ']` token, and detects strings to a `['string', '\"{\"']` token.\n2. [Parser](https://github.com/postcss/postcss/blob/main/lib/parser.js) which reads the tokens array, creates node instances and builds a tree.\n\n### Performance\n\nParsing input is often the most time consuming task in CSS processors. So it is very important to have a fast parser.\n\nThe main rule of optimization is that there is no performance without a benchmark. You can look at [PostCSS benchmarks](https://github.com/postcss/benchmark) to build your own.\n\nOf parsing tasks, the tokenize step will often take the most time, so its performance should be prioritized. Unfortunately, classes, functions and high level structures can slow down your tokenizer. Be ready to write dirty code with repeated statements. This is why it is difficult to extend the default [PostCSS tokenizer](https://github.com/postcss/postcss/blob/main/lib/tokenize.js); copy & paste will be a necessary evil.\n\nSecond optimization is using character codes instead of strings.\n\n```code js\n// Slow\nstring[i] === '{'\n\n// Fast\nconst OPEN_CURLY = 123 // `{'\nstring.charCodeAt(i) === OPEN_CURLY\n```\n\nThird optimization is “fast jumps”. If you find open quotes, you can find next closing quote much faster by `indexOf`:\n\n```code js\n// Simple jump\nnext = string.indexOf('\"', currentPosition + 1)\n\n// Jump by RegExp\nregexp.lastIndex = currentPosion + 1\nregexp.test(string)\nnext = regexp.lastIndex\n```\n\nThe parser can be a well written class. There is no need in copy-paste and hardcore optimization there. You can extend the default [PostCSS parser](https://github.com/postcss/postcss/blob/main/lib/parser.js).\n\n### Node Source\n\nEvery node should have `source` property to generate correct source map. This property contains `start` and `end` properties with `{ line, column }`, and `input` property with an [`Input`](https://github.com/postcss/postcss/blob/main/lib/input.js) instance.\n\nYour tokenizer should save the original position so that you can propagate the values to the parser, to ensure that the source map is correctly updated.\n\n### Raw Values\n\nA good PostCSS parser should provide all information (including spaces symbols) to generate byte-to-byte equal output. It is not so difficult, but respectful for user input and allow integration smoke tests.\n\nA parser should save all additional symbols to `node.raws` object. It is an open structure for you, you can add additional keys. For example, [SCSS parser](https://github.com/postcss/postcss-scss) saves comment types ( `/* */` or `//`) in `node.raws.inline`.\n\nThe default parser cleans CSS values from comments and spaces. It saves the original value with comments to `node.raws.value.raw` and uses it, if the node value was not changed.\n\n### Tests\n\nOf course, all parsers in the PostCSS ecosystem must have tests.\n\nIf your parser just extends CSS syntax (like [SCSS](https://github.com/postcss/postcss-scss) or [Safe Parser](https://github.com/postcss/postcss-safe-parser)), you can use the [PostCSS Parser Tests](https://github.com/postcss/postcss-parser-tests). It contains unit & integration tests.\n\n## Stringifier\n\nA style guide generator is a good example of a stringifier. It generates output HTML which contains CSS components. For this use case, a parser isn't necessary, so the package should just contain a stringifier.\n\nThe Stringifier API is little bit more complicated, than the parser API. PostCSS generates a source map, so a stringifier can’t just return a string. It must link every substring with its source node.\n\nA Stringifier is a function which receives [`Root`](https://postcss.org/api/#root) or [`Document`](https://postcss.org/api/#document) node and builder callback. Then it calls builder with every node’s string and node instance.\n\n```code js\nmodule.exports = function stringify (root, builder) {\n  // Some magic\n  const string = decl.prop + ':' + decl.value + ';'\n  builder(string, decl)\n  // Some science\n};\n```\n\n### Main Theory\n\nPostCSS [default stringifier](https://github.com/postcss/postcss/blob/main/lib/stringifier.js) is just a class with a method for each node type and many methods to detect raw properties.\n\nIn most cases it will be enough just to extend this class, like in [SCSS stringifier](https://github.com/postcss/postcss-scss/blob/main/lib/scss-stringifier.js).\n\n### Builder Function\n\nA builder function will be passed to `stringify` function as second argument. For example, the default PostCSS stringifier class saves it to `this.builder` property.\n\nBuilder receives output substring and source node to append this substring to the final output.\n\nSome nodes contain other nodes in the middle. For example, a rule has a `{` at the beginning, many declarations inside and a closing `}`.\n\nFor these cases, you should pass a third argument to builder function: `'start'` or `'end'` string:\n\n```code js\nthis.builder(rule.selector + '{', rule, 'start')\n// Stringify declarations inside\nthis.builder('}', rule, 'end')\n```\n\n### Raw Values\n\nA good PostCSS custom syntax saves all symbols and provide byte-to-byte equal output if there were no changes.\n\nThis is why every node has `node.raws` object to store space symbol, etc.\n\nAll data related to source code and not CSS structure, should be in `Node#raws`. For instance, `postcss-scss` keep in `Comment#raws.inline` boolean marker of inline comment ( `// comment` instead of `/* comment */`).\n\nBe careful, because sometimes these raw properties will not be present; some nodes may be built manually, or may lose their indentation when they are moved to another parent node.\n\nThis is why the default stringifier has a `raw()` method to autodetect raw properties by other nodes. For example, it will look at other nodes to detect indent size and them multiply it with the current node depth.\n\n### Tests\n\nA stringifier must have tests too.\n\nYou can use unit and integration test cases from [PostCSS Parser Tests](https://github.com/postcss/postcss-parser-tests). Just compare input CSS with CSS after your parser and stringifier.\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "overview", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I syntax in postcss?\n\nAssistant: To syntax in postcss, here's what you do:\nA good example of a custom syntax is [SCSS](https://github.com/postcss/postcss-scss). Some users may want to transform SCSS sources with PostCSS plugins, for example if they need to add vendor prefixes or change the property order. So this syntax should output SCSS from an SCSS input.\n\nThe syntax API is a very simple plain object, with `parse` & `stringify` functions:\n\n```code js\nmodule.exports = {\n  parse:     require('./parse'),\n  stringify: require('./stringify')\n}\n```\n.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "section_detail", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I parser in postcss?\n\nAssistant: To parser in postcss, here's what you do:\nA good example of a parser is [Safe Parser](https://github.com/postcss/postcss-safe-parser), which parses malformed/broken CSS. Because there is no point to generate broken output, this package only provides a parser.\n\nThe parser API is a function which receives a string & returns a [`Root`](https://postcss.org/api/#root) or [`Document`](https://postcss.org/api/#document) node. The second argument is a function which receives an object with PostCSS options.\n\n```code js\nconst postcss = require('postcss')\n\nmodule.exports = function parse (css, opts) {\n  const root = postcss.root()\n  // Add other nodes to root\n  return root\n}\n```\n\nFor open source parser npm package must have `postcss` in `peerDependencies`, not in direct `dependencies`.\n\n### Main Theory\n\nThere are many books about parsers; but do not worry because CSS syntax is very easy, and so the parser will be much simpler than a programming language parser.\n\nThe default PostCSS parser contains two steps:\n\n1. [Tokenizer](https://github.com/postcss/postcss/blob/main/lib/tokenize.js) which reads input string character by character and builds a tokens array. For example, it joins space symbols to a `['space', '\\n  ']` token, and detects strings to a `['string', '\"{\"']` token.\n2. [Parser](https://github.com/postcss/postcss/blob/main/lib/parser.js) which reads the tokens array, creates node instances and builds a tree.\n\n### Performance\n\nParsing input is often the most time consuming task in CSS processors. So it is very important to have a fast parser.\n\nThe main rule of optimization is that there is no performance without a benchmark. You can look at [PostCSS benchmarks](https://github.com/postcss/benchmark) to build your own.\n\nOf parsing tasks, the tokenize step will often take the most time, so its performance should be prioritized. Unfortunately, classes, functions and high level structures can slow down your tokenizer. Be ready to write dirty code with repeated statements. This is why it is difficult to extend the default [PostCSS tokenizer](https://github.com/postcss/postcss/blob/main/lib/tokenize.js); copy & paste will be a necessary evil.\n\nSecond optimization is using character codes instead of strings.\n\n```code js\n// Slow\nstring[i] === '{'\n\n// Fast\nconst OPEN_CURLY = 123 // `{'\nstring.charCodeAt(i) === OPEN_CURLY\n```\n\nThird optimization is “fast jumps”. If you find open quotes, you can find next closing quote much faster by `indexOf`:\n\n```code js\n// Simple jump\nnext = string.indexOf('\"', currentPosition + 1)\n\n// Jump by RegExp\nregexp.lastIndex = currentPosion + 1\nregexp.test(string)\nnext = regexp.lastIndex\n```\n\nThe parser can be a well written class. There is no need in copy-paste and hardcore optimization there. You can extend the default [PostCSS parser](https://github.com/postcss/postcss/blob/main/lib/parser.js).\n\n### Node Source\n\nEvery node should have `source` property to generate correct source map. This property contains `start` and `end` properties with `{ line, column }`, and `input` property with an [`Input`](https://github.com/postcss/postcss/blob/main/lib/input.js) instance.\n\nYour tokenizer should save the original position so that you can propagate the values to the parser, to ensure that the source map is correctly updated.\n\n### Raw Values\n\nA good PostCSS parser should provide all information (including spaces symbols) to generate byte-to-byte equal output. It is not so difficult, but respectful for user input and allow integration smoke tests.\n\nA parser should save all additional symbols to `node.raws` object. It is an open structure for you, you can add additional keys. For example, [SCSS parser](https://github.com/postcss/postcss-scss) saves comment types ( `/* */` or `//`) in `node.raws.inline`.\n\nThe default parser cleans CSS values from comments and spaces. It saves the original value with comments to `node.raws.value.raw` and uses it, if the node value was not changed.\n\n### Tests\n\nOf course, all parsers in the PostCSS ecosystem must have tests.\n\nIf your parser just extends CSS syntax (like [SCSS](https://github.com/postcss/postcss-scss) or [Safe Parser](https://github.com/postcss/postcss-safe-parser)), you can use the [PostCSS Parser Tests](https://github.com/postcss/postcss-parser-tests). It contains unit & integration tests..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "section_detail", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I stringifier in postcss?\n\nAssistant: To stringifier in postcss, here's what you do:\nA style guide generator is a good example of a stringifier. It generates output HTML which contains CSS components. For this use case, a parser isn't necessary, so the package should just contain a stringifier.\n\nThe Stringifier API is little bit more complicated, than the parser API. PostCSS generates a source map, so a stringifier can’t just return a string. It must link every substring with its source node.\n\nA Stringifier is a function which receives [`Root`](https://postcss.org/api/#root) or [`Document`](https://postcss.org/api/#document) node and builder callback. Then it calls builder with every node’s string and node instance.\n\n```code js\nmodule.exports = function stringify (root, builder) {\n  // Some magic\n  const string = decl.prop + ':' + decl.value + ';'\n  builder(string, decl)\n  // Some science\n};\n```\n\n### Main Theory\n\nPostCSS [default stringifier](https://github.com/postcss/postcss/blob/main/lib/stringifier.js) is just a class with a method for each node type and many methods to detect raw properties.\n\nIn most cases it will be enough just to extend this class, like in [SCSS stringifier](https://github.com/postcss/postcss-scss/blob/main/lib/scss-stringifier.js).\n\n### Builder Function\n\nA builder function will be passed to `stringify` function as second argument. For example, the default PostCSS stringifier class saves it to `this.builder` property.\n\nBuilder receives output substring and source node to append this substring to the final output.\n\nSome nodes contain other nodes in the middle. For example, a rule has a `{` at the beginning, many declarations inside and a closing `}`.\n\nFor these cases, you should pass a third argument to builder function: `'start'` or `'end'` string:\n\n```code js\nthis.builder(rule.selector + '{', rule, 'start')\n// Stringify declarations inside\nthis.builder('}', rule, 'end')\n```\n\n### Raw Values\n\nA good PostCSS custom syntax saves all symbols and provide byte-to-byte equal output if there were no changes.\n\nThis is why every node has `node.raws` object to store space symbol, etc.\n\nAll data related to source code and not CSS structure, should be in `Node#raws`. For instance, `postcss-scss` keep in `Comment#raws.inline` boolean marker of inline comment ( `// comment` instead of `/* comment */`).\n\nBe careful, because sometimes these raw properties will not be present; some nodes may be built manually, or may lose their indentation when they are moved to another parent node.\n\nThis is why the default stringifier has a `raw()` method to autodetect raw properties by other nodes. For example, it will look at other nodes to detect indent size and them multiply it with the current node depth.\n\n### Tests\n\nA stringifier must have tests too.\n\nYou can use unit and integration test cases from [PostCSS Parser Tests](https://github.com/postcss/postcss-parser-tests). Just compare input CSS with CSS after your parser and stringifier..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "section_detail", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you give me some code examples for How to Write Custom Syntax in postcss?\n\nAssistant: Absolutely! Here are some practical examples to help you out:\n\n**Syntax API Example**:\n\n```yaml\nmodule.exports = {\n  parse:     require('./parse'),\n  stringify: require('./stringify')\n}\n```\n\nThis snippet shows you how to syntax api example, which is an important aspect of how to write custom syntax.\n\n**Parser Example**:\n\n```yaml\nconst postcss = require('postcss')\n\nmodule.exports = function parse (css, opts) {\n  const root = postcss.root()\n  // Add other nodes to root\n  return root\n}\n```\n\nThis snippet shows you how to parser example, which is an important aspect of how to write custom syntax.\n\n**Character Code Optimization**:\n\n```yaml\n// Slow\nstring[i] === '{'\n\n// Fast\nconst OPEN_CURLY = 123 // `{'\nstring.charCodeAt(i) === OPEN_CURLY\n\n```\n\nThis snippet shows you how to character code optimization, which is an important aspect of how to write custom syntax.\n\n**Fast Jumps Optimization**:\n\n```yaml\n// Simple jump\nnext = string.indexOf('\"', currentPosition + 1)\n\n// Jump by RegExp\nregexp.lastIndex = currentPosion + 1\nregexp.test(string)\nnext = regexp.lastIndex\n\n```\n\nThis snippet shows you how to fast jumps optimization, which is an important aspect of how to write custom syntax.\n\n**Stringifier Example**:\n\n```yaml\nmodule.exports = function stringify (root, builder) {\n  // Some magic\n  const string = decl.prop + ':' + decl.value + ';'\n  builder(string, decl)\n  // Some science\n};\n\n```\n\nThis snippet shows you how to stringifier example, which is an important aspect of how to write custom syntax.\n\n**Builder Function Example**:\n\n```yaml\nthis.builder(rule.selector + '{', rule, 'start')\n// Stringify declarations inside\nthis.builder('}', rule, 'end')\n```\n\nThis snippet shows you how to builder function example, which is an important aspect of how to write custom syntax.\n\n", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "code_examples", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: What are some tips for using How to Write Custom Syntax in postcss effectively?\n\nAssistant: Great question! Here are some tips to keep in mind:\n\nFor open source parser npm package must have `postcss` in `peerDependencies`, not in direct `dependencies`.\n\nThe main rule of optimization is that there is no performance without a benchmark. You can look at [PostCSS benchmarks](https://github.com/postcss/benchmark) to build your own.\n\nBe ready to write dirty code with repeated statements for performance optimization.\n\nUse character codes instead of strings for faster performance.\n\nA good PostCSS parser should provide all information (including spaces symbols) to generate byte-to-byte equal output.\n\nA parser should save all additional symbols to `node.raws` object.\n\nIf your parser just extends CSS syntax, you can use the [PostCSS Parser Tests](https://github.com/postcss/postcss-parser-tests).\n\nStick to these, and you'll avoid a lot of headaches!", "metadata": {"source_url": "https://postcss.org/docs/how-to-write-custom-syntax", "title": "How to Write Custom Syntax", "description": "PostCSS can transform styles in any syntax, and is not limited to just CSS. By writing a custom syntax, you can transform styles in any desired format.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:13:41", "type": "best_practices", "page_metadata": {"twitter:card": "summary", "twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "og:type": "article", "og:url": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:image": "./base/og.jpg", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "title": "How to Write Custom Syntax", "language": "en", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "scrapeId": "1424a12a-dd9d-417a-8108-9063e016f877", "sourceURL": "https://postcss.org/docs/how-to-write-custom-syntax", "url": "https://postcss.org/docs/how-to-write-custom-syntax", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what PostCSS Documentation is in postcss?\n\nAssistant: Sure, I'd be happy to explain PostCSS Documentation in postcss.\n\n# PostCSS Documentation\n\nComprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.Here's a quick rundown of what this is about:\n\n## PostCSS Architecture\n\nOverview of the PostCSS architecture and its components.\n\n## PostCSS Plugins\n\nDetailed information on available PostCSS plugins and how to use them.\n\n## How to Write Custom Syntax\n\nGuidelines for creating custom syntax for PostCSS.\n\n## Writing a PostCSS Plugin\n\nInstructions on how to write your own PostCSS plugin.\n\n## PostCSS Plugin Guidelines\n\nBest practices and guidelines for developing PostCSS plugins.\n\n## PostCSS Runner Guidelines\n\nGuidelines for using the PostCSS runner.\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "overview", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I postcss architecture in postcss?\n\nAssistant: To postcss architecture in postcss, here's what you do:\nOverview of the PostCSS architecture and its components..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I postcss plugins in postcss?\n\nAssistant: To postcss plugins in postcss, here's what you do:\nDetailed information on available PostCSS plugins and how to use them..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I how to write custom syntax in postcss?\n\nAssistant: To how to write custom syntax in postcss, here's what you do:\nGuidelines for creating custom syntax for PostCSS..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I writing a postcss plugin in postcss?\n\nAssistant: To writing a postcss plugin in postcss, here's what you do:\nInstructions on how to write your own PostCSS plugin..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I postcss plugin guidelines in postcss?\n\nAssistant: To postcss plugin guidelines in postcss, here's what you do:\nBest practices and guidelines for developing PostCSS plugins..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I postcss runner guidelines in postcss?\n\nAssistant: To postcss runner guidelines in postcss, here's what you do:\nGuidelines for using the PostCSS runner..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs", "title": "PostCSS Documentation", "description": "Comprehensive guide to PostCSS architecture, plugins, and writing custom syntax and plugins.", "has_code_examples": false, "has_best_practices": false, "section_count": 6, "timestamp": "2025-02-28 22:14:12", "type": "section_detail", "page_metadata": {"og:image": "./base/og.jpg", "language": "en", "og:type": "article", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "ogImage": "./base/og.jpg", "twitter:card": "summary", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "ogUrl": "http://postcss.org/", "viewport": "width=device-width, initial-scale=1", "title": "PostCSS Documentation", "og:url": "http://postcss.org/", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "496569ee-9bba-4396-b970-f7e515b535eb", "sourceURL": "https://postcss.org/docs", "url": "https://postcss.org/docs/", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what PostCSS Architecture is in postcss?\n\nAssistant: Sure, I'd be happy to explain PostCSS Architecture in postcss.\n\n# PostCSS Architecture\n\nGeneral overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.Here's a quick rundown of what this is about:\n\n## Overview\n\nThis section describes ideas lying behind PostCSS\n\nBefore diving deeper into the development of PostCSS let's briefly describe what is PostCSS and what is not.\n\n**PostCSS**\n\n- _is **NOT** a style preprocessor like `Sass` or `Less`._\n\n  It does not define a custom syntax and semantics, it's not actually a language.\n  PostCSS works with CSS and can be easily integrated with the tools described above. That being said any valid CSS can be processed by PostCSS.\n\n- _is a tool for CSS syntax transformations_\n\n  It allows you to define custom CSS like syntax that could be understandable and transformed by plugins. That being said PostCSS is not strictly about CSS spec but about syntax definition manner of CSS. In such a way you can define custom syntax constructs like at-rule, that could be very helpful for tools build around PostCSS. PostCSS plays the role of a framework for building outstanding tools for CSS manipulations.\n\n- _is a big player in CSS ecosystem_\n\n  A Large amount of lovely tools like `Autoprefixer`, `Stylelint`, `CSSnano` were built on PostCSS ecosystem. There is a big chance that you already use it implicitly, just check your `node_modules` 😀\n\n## Workflow\n\nThis is a high-level overview of the whole PostCSS workflow\n\nAs you can see from the diagram above, PostCSS architecture is pretty straightforward but some parts of it could be misunderstood.\n\nYou can see a part called _Parser_, this construct will be described in details later on, just for now think about it as a structure that can understand your CSS like syntax and create an object representation of it.\n\nThat being said, there are few ways to write a parser.\n\n- _Write a single file with string to AST transformation_\n\n  This method is quite popular, for example, the [Rework analyzer](https://github.com/reworkcss/css/blob/master/lib/parse/index.js) was written in this style. But with a large code base, the code becomes hard to read and pretty slow.\n\n- _Split it into lexical analysis/parsing steps (source string → tokens → AST)_\n\n  This is the way of how we do it in PostCSS and also the most popular one.\n  A lot of parsers like [`@babel/parser` (parser behind Babel)](https://github.com/babel/babel/tree/master/packages/babel-parser), [`CSSTree`](https://github.com/csstree/csstree) were written in such way.\n  The main reasons to separate tokenization from parsing steps are performance and abstracting complexity.\n\nLet's think about why the second way is better for our needs.\n\nFirst of all, because string to tokens step takes more time than parsing step. We operate on large source string and process it char by char, this is why it is very inefficient operation in terms of performance and we should perform it only once.\n\nBut from other side tokens to AST transformation is logically more complex so with such separation we could write very fast tokenizer (but from this comes sometimes hard to read code) and easy to read (but slow) parser.\n\nSumming it up splitting into two steps improve performance and code readability.\n\nSo now let's look more closely on structures that play the main role in PostCSS workflow.\n\n## Core Structures\n\n- #### Tokenizer [`lib/tokenize.js`](https://github.com/postcss/postcss/blob/main/lib/tokenize.js)\n\n  Tokenizer (aka Lexer) plays important role in syntax analysis.\n\n  It accepts CSS string and returns a list of tokens.\n\n  Token is a simple structure that describes some part of syntax like `at-rule`, `comment` or `word`. It can also contain positional information for more descriptive errors.\n\n  For example, if we consider following CSS\n\n  ```code css\n  .className { color: #FFF; }\n  ```\n\n  corresponding tokens from PostCSS will be\n\n  ```code js\n  [\\\n      [\"word\", \".className\", 1, 1, 1, 10]\\\n      [\"space\", \" \"]\\\n      [\"{\", \"{\", 1, 12]\\\n      [\"space\", \" \"]\\\n      [\"word\", \"color\", 1, 14, 1, 18]\\\n      [\":\", \":\", 1, 19]\\\n      [\"space\", \" \"]\\\n      [\"word\", \"#FFF\" , 1, 21, 1, 23]\\\n      [\";\", \";\", 1, 24]\\\n      [\"space\", \" \"]\\\n      [\"}\", \"}\", 1, 26]\\\n  ]\n  ```\n\n  As you can see from the example above a single token represented as a list and also `space` token doesn't have positional information.\n\n  Let's look more closely on single token like `word`. As it was said each token represented as a list and follow such pattern.\n\n  ```code js\n  const token = [\\\n       // represents token type\\\n      'word',\\\n\\\n      // represents matched word\\\n      '.className',\\\n\\\n      // This two numbers represent start position of token.\\\n      // It is optional value as we saw in the example above,\\\n      // tokens like `space` don't have such information.\\\n\\\n      // Here the first number is line number and the second one is corresponding column.\\\n      1, 1,\\\n\\\n      // Next two numbers also optional and represent end position for multichar tokens like this one. Numbers follow same rule as was described above\\\n      1, 10\\\n  ]\n  ```\n\n  There are many patterns how tokenization could be done, PostCSS motto is performance and simplicity. Tokenization is a complex computing operation and takes a large amount of syntax analysis time ( ~90% ), that why PostCSS' Tokenizer looks dirty but it was optimized for speed. Any high-level constructs like classes could dramatically slow down tokenizer.\n\n  PostCSS' Tokenizer uses some sort of streaming/chaining API where you expose [`nextToken()`](https://github.com/postcss/postcss/blob/main/lib/tokenize.js#L48-L308) method to Parser. In this manner, we provide a clean interface for Parser and reduce memory usage by storing only a few tokens and not the whole list of tokens.\n\n- #### Parser [`lib/parse.js`](https://github.com/postcss/postcss/blob/main/lib/parse.js), [`lib/parser.js`](https://github.com/postcss/postcss/blob/main/lib/parser.js)\n\n  Parser is the main structure responsible for [syntax analysis](https://en.wikipedia.org/wiki/Parsing) of incoming CSS. Parser produces a structure called [Abstract Syntax Tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree) that could then be transformed by plugins later on.\n\n  Parser works in common with Tokenizer and operates over tokens, not source string, as it would be a very inefficient operation.\n\n  It uses mostly `nextToken` and `back` methods provided by Tokenizer for obtaining single or multiple tokens and then construct part of AST called `Node`.\n\n  There are multiple Node types that PostCSS could produce but all of them inherit from base Node [class](https://github.com/postcss/postcss/blob/main/lib/node.js#L34).\n\n- #### Processor [`lib/processor.js`](https://github.com/postcss/postcss/blob/main/lib/processor.js)\n\n  Processor is a very plain structure that initializes plugins and runs syntax transformations\n\n  It exposes only a few public API methods. Description of them could be found on [API](https://postcss.org/api/#processor)\n\n- #### Stringifier [`lib/stringify.js`](https://github.com/postcss/postcss/blob/main/lib/stringify.js), [`lib/stringifier.js`](https://github.com/postcss/postcss/blob/main/lib/stringifier.js)\n\n  Stringifier is a base class that translates modified AST to pure CSS string. Stringifier traverses AST starting from provided Node and generates a raw string representation of it calling corresponding methods.\n\n  The most essential method is [`Stringifier.stringify`](https://github.com/postcss/postcss/blob/main/lib/stringifier.js#L25-L27)\n  that accepts initial Node and semicolon indicator.\n  You can learn more by checking [stringifier.js](https://github.com/postcss/postcss/blob/main/lib/stringifier.js)\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "overview", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I overview in postcss?\n\nAssistant: To overview in postcss, here's what you do:\nThis section describes ideas lying behind PostCSS\n\nBefore diving deeper into the development of PostCSS let's briefly describe what is PostCSS and what is not.\n\n**PostCSS**\n\n- _is **NOT** a style preprocessor like `Sass` or `Less`._\n\n  It does not define a custom syntax and semantics, it's not actually a language.\n  PostCSS works with CSS and can be easily integrated with the tools described above. That being said any valid CSS can be processed by PostCSS.\n\n- _is a tool for CSS syntax transformations_\n\n  It allows you to define custom CSS like syntax that could be understandable and transformed by plugins. That being said PostCSS is not strictly about CSS spec but about syntax definition manner of CSS. In such a way you can define custom syntax constructs like at-rule, that could be very helpful for tools build around PostCSS. PostCSS plays the role of a framework for building outstanding tools for CSS manipulations.\n\n- _is a big player in CSS ecosystem_\n\n  A Large amount of lovely tools like `Autoprefixer`, `Stylelint`, `CSSnano` were built on PostCSS ecosystem. There is a big chance that you already use it implicitly, just check your `node_modules` 😀.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "section_detail", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I workflow in postcss?\n\nAssistant: To workflow in postcss, here's what you do:\nThis is a high-level overview of the whole PostCSS workflow\n\nAs you can see from the diagram above, PostCSS architecture is pretty straightforward but some parts of it could be misunderstood.\n\nYou can see a part called _Parser_, this construct will be described in details later on, just for now think about it as a structure that can understand your CSS like syntax and create an object representation of it.\n\nThat being said, there are few ways to write a parser.\n\n- _Write a single file with string to AST transformation_\n\n  This method is quite popular, for example, the [Rework analyzer](https://github.com/reworkcss/css/blob/master/lib/parse/index.js) was written in this style. But with a large code base, the code becomes hard to read and pretty slow.\n\n- _Split it into lexical analysis/parsing steps (source string → tokens → AST)_\n\n  This is the way of how we do it in PostCSS and also the most popular one.\n  A lot of parsers like [`@babel/parser` (parser behind Babel)](https://github.com/babel/babel/tree/master/packages/babel-parser), [`CSSTree`](https://github.com/csstree/csstree) were written in such way.\n  The main reasons to separate tokenization from parsing steps are performance and abstracting complexity.\n\nLet's think about why the second way is better for our needs.\n\nFirst of all, because string to tokens step takes more time than parsing step. We operate on large source string and process it char by char, this is why it is very inefficient operation in terms of performance and we should perform it only once.\n\nBut from other side tokens to AST transformation is logically more complex so with such separation we could write very fast tokenizer (but from this comes sometimes hard to read code) and easy to read (but slow) parser.\n\nSumming it up splitting into two steps improve performance and code readability.\n\nSo now let's look more closely on structures that play the main role in PostCSS workflow..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "section_detail", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I core structures in postcss?\n\nAssistant: To core structures in postcss, here's what you do:\n- #### Tokenizer [`lib/tokenize.js`](https://github.com/postcss/postcss/blob/main/lib/tokenize.js)\n\n  Tokenizer (aka Lexer) plays important role in syntax analysis.\n\n  It accepts CSS string and returns a list of tokens.\n\n  Token is a simple structure that describes some part of syntax like `at-rule`, `comment` or `word`. It can also contain positional information for more descriptive errors.\n\n  For example, if we consider following CSS\n\n  ```code css\n  .className { color: #FFF; }\n  ```\n\n  corresponding tokens from PostCSS will be\n\n  ```code js\n  [\\\n      [\"word\", \".className\", 1, 1, 1, 10]\\\n      [\"space\", \" \"]\\\n      [\"{\", \"{\", 1, 12]\\\n      [\"space\", \" \"]\\\n      [\"word\", \"color\", 1, 14, 1, 18]\\\n      [\":\", \":\", 1, 19]\\\n      [\"space\", \" \"]\\\n      [\"word\", \"#FFF\" , 1, 21, 1, 23]\\\n      [\";\", \";\", 1, 24]\\\n      [\"space\", \" \"]\\\n      [\"}\", \"}\", 1, 26]\\\n  ]\n  ```\n\n  As you can see from the example above a single token represented as a list and also `space` token doesn't have positional information.\n\n  Let's look more closely on single token like `word`. As it was said each token represented as a list and follow such pattern.\n\n  ```code js\n  const token = [\\\n       // represents token type\\\n      'word',\\\n\\\n      // represents matched word\\\n      '.className',\\\n\\\n      // This two numbers represent start position of token.\\\n      // It is optional value as we saw in the example above,\\\n      // tokens like `space` don't have such information.\\\n\\\n      // Here the first number is line number and the second one is corresponding column.\\\n      1, 1,\\\n\\\n      // Next two numbers also optional and represent end position for multichar tokens like this one. Numbers follow same rule as was described above\\\n      1, 10\\\n  ]\n  ```\n\n  There are many patterns how tokenization could be done, PostCSS motto is performance and simplicity. Tokenization is a complex computing operation and takes a large amount of syntax analysis time ( ~90% ), that why PostCSS' Tokenizer looks dirty but it was optimized for speed. Any high-level constructs like classes could dramatically slow down tokenizer.\n\n  PostCSS' Tokenizer uses some sort of streaming/chaining API where you expose [`nextToken()`](https://github.com/postcss/postcss/blob/main/lib/tokenize.js#L48-L308) method to Parser. In this manner, we provide a clean interface for Parser and reduce memory usage by storing only a few tokens and not the whole list of tokens.\n\n- #### Parser [`lib/parse.js`](https://github.com/postcss/postcss/blob/main/lib/parse.js), [`lib/parser.js`](https://github.com/postcss/postcss/blob/main/lib/parser.js)\n\n  Parser is the main structure responsible for [syntax analysis](https://en.wikipedia.org/wiki/Parsing) of incoming CSS. Parser produces a structure called [Abstract Syntax Tree (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree) that could then be transformed by plugins later on.\n\n  Parser works in common with Tokenizer and operates over tokens, not source string, as it would be a very inefficient operation.\n\n  It uses mostly `nextToken` and `back` methods provided by Tokenizer for obtaining single or multiple tokens and then construct part of AST called `Node`.\n\n  There are multiple Node types that PostCSS could produce but all of them inherit from base Node [class](https://github.com/postcss/postcss/blob/main/lib/node.js#L34).\n\n- #### Processor [`lib/processor.js`](https://github.com/postcss/postcss/blob/main/lib/processor.js)\n\n  Processor is a very plain structure that initializes plugins and runs syntax transformations\n\n  It exposes only a few public API methods. Description of them could be found on [API](https://postcss.org/api/#processor)\n\n- #### Stringifier [`lib/stringify.js`](https://github.com/postcss/postcss/blob/main/lib/stringify.js), [`lib/stringifier.js`](https://github.com/postcss/postcss/blob/main/lib/stringifier.js)\n\n  Stringifier is a base class that translates modified AST to pure CSS string. Stringifier traverses AST starting from provided Node and generates a raw string representation of it calling corresponding methods.\n\n  The most essential method is [`Stringifier.stringify`](https://github.com/postcss/postcss/blob/main/lib/stringifier.js#L25-L27)\n  that accepts initial Node and semicolon indicator.\n  You can learn more by checking [stringifier.js](https://github.com/postcss/postcss/blob/main/lib/stringifier.js).\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "section_detail", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you give me some code examples for PostCSS Architecture in postcss?\n\nAssistant: Absolutely! Here are some practical examples to help you out:\n\n**CSS Example**:\n\n```yaml\n.className { color: #FFF; }\n```\n\nThis snippet shows you how to css example, which is an important aspect of postcss architecture.\n\n**Token Example**:\n\n```yaml\n[\n    [\"word\", \".className\", 1, 1, 1, 10]\n    [\"space\", \" \"]\n    [\"{\", \"{\", 1, 12]\n    [\"space\", \" \"]\n    [\"word\", \"color\", 1, 14, 1, 18]\n    [\":\", \":\", 1, 19]\n    [\"space\", \" \"]\n    [\"word\", \"#FFF\" , 1, 21, 1, 23]\n    [\";\", \";\", 1, 24]\n    [\"space\", \" \"]\n    [\"}\", \"}\", 1, 26]\n]\n```\n\nThis snippet shows you how to token example, which is an important aspect of postcss architecture.\n\n**Token Structure Example**:\n\n```yaml\nconst token = [\n     // represents token type\n    'word',\n\n    // represents matched word\n    '.className',\n\n    // This two numbers represent start position of token.\n    // It is optional value as we saw in the example above,\n    // tokens like `space` don't have such information.\n\n    // Here the first number is line number and the second one is corresponding column.\n    1, 1,\n\n    // Next two numbers also optional and represent end position for multichar tokens like this one. Numbers follow same rule as was described above\n    1, 10\n]\n```\n\nThis snippet shows you how to token structure example, which is an important aspect of postcss architecture.\n\n", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "code_examples", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: What are some tips for using PostCSS Architecture in postcss effectively?\n\nAssistant: Great question! Here are some tips to keep in mind:\n\nPostCSS motto is performance and simplicity.\n\nTokenization is a complex computing operation and takes a large amount of syntax analysis time (~90%).\n\nSplitting into two steps improves performance and code readability.\n\nStick to these, and you'll avoid a lot of headaches!", "metadata": {"source_url": "https://postcss.org/docs/postcss-architecture", "title": "PostCSS Architecture", "description": "General overview of the PostCSS architecture. It can be useful for everyone who wishes to contribute to the core or develop a better understanding of the tool.", "has_code_examples": true, "has_best_practices": true, "section_count": 3, "timestamp": "2025-02-28 22:25:33", "type": "best_practices", "page_metadata": {"twitter:creator": "@postcss", "ogImage": "./base/og.jpg", "title": "PostCSS Architecture", "twitter:card": "summary", "og:image": "./base/og.jpg", "language": "en", "og:type": "article", "ogUrl": "http://postcss.org/", "twitter:site": "@postcss", "og:url": "http://postcss.org/", "description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "viewport": "width=device-width, initial-scale=1", "scrapeId": "14e01885-a333-4401-b030-c3353fb3d19d", "sourceURL": "https://postcss.org/docs/postcss-architecture", "url": "https://postcss.org/docs/postcss-architecture", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you explain what Writing a PostCSS Plugin is in postcss?\n\nAssistant: Sure, I'd be happy to explain Writing a PostCSS Plugin in postcss.\n\n# Writing a PostCSS Plugin\n\nThis documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.Here's a quick rundown of what this is about:\n\n## Links\n\nDocumentation:\n\n- [Plugin Boilerplate](https://github.com/postcss/postcss-plugin-boilerplate)\n- [Plugin Guidelines](https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md)\n- [PostCSS API](https://postcss.org/api/)\n- [AST playground](https://astexplorer.net/#/2uBU1BLuJ1)\n\nSupport:\n\n- [Ask questions](https://github.com/orgs/postcss/discussions)\n- [PostCSS twitter](https://twitter.com/postcss) with latest updates.\n\n## Step 1: Create an idea\n\nThere are many fields where writing new PostCSS plugin will help your work:\n\n- **Compatibility fixes:** if you always forget to add hack for browser compatibility, you can create PostCSS plugin to automatically insert this hack for you. [`postcss-flexbugs-fixes`](https://github.com/luisrudge/postcss-flexbugs-fixes) and [`postcss-100vh-fix`](https://github.com/postcss/postcss-100vh-fix) are good examples.\n- **Automate routine operations:** let’s computer do routine operations, free yourself for creative tasks. For instance, PostCSS with [RTLCSS](https://rtlcss.com/) can automatically convert a design to right-to-left languages (like Arabic or Hebrew) or with [postcss-dark-theme-class](https://github.com/postcss/postcss-dark-theme-class) can insert media queries for dark/light theme switcher.\n- **Preventing popular mistakes:** “if an error happened twice, it will happen again.” PostCSS plugin can check your source code for popular mistakes and save your time for unnecessary debugging. The best way to do it is to [write new Stylelint plugin](https://stylelint.io/developer-guide/plugins) (Stylelint uses PostCSS inside).\n- **Increasing code maintainability:** [CSS Modules](https://github.com/css-modules/css-modules) or [`postcss-autoreset`](https://github.com/maximkoretskiy/postcss-autoreset) are great example how PostCSS can increase code maintainability by isolation.\n- **Polyfills:** we already have a lot polyfills for CSS drafts in [`postcss-preset-env`](https://github.com/csstools/postcss-preset-env). If you find a new draft, you can add a new plugin and send it to this preset.\n- **New CSS syntax:** we recommend avoiding adding new syntax to CSS. If you want to add a new feature, it is always better to write a CSS draft proposal, send it to [CSSWG](https://github.com/w3c/csswg-drafts) and then implement polyfill. [`postcss-easing-gradients`](https://github.com/larsenwork/postcss-easing-gradients) with [this proposal](https://github.com/w3c/csswg-drafts/issues/1332) is a good example. However, there are a lot of cases when you can’t send a proposal. For instance, browser’s parser performance limited CSSWG nested syntax a lot and you may want to have non-official Sass-like syntax from [`postcss-nested`](https://github.com/postcss/postcss-nested).\n\n## Step 2: Create a project\n\nThere are two ways to write a plugin:\n\n- Create a **private** plugin. Use this way only if the plugin is related to specific things of projects. For instance, you want to automate a specific task for your unique UI library.\n- Publish a **public** plugin. It is always the recommended way. Remember that private front-end systems, even in Google, often became unmaintained. On the other hand, many popular plugins were created during the work on a closed source project.\n\nFor private plugin:\n\n1. Create a new file in `postcss/` folder with the name of your plugin.\n2. Copy [plugin template](https://github.com/postcss/postcss-plugin-boilerplate/blob/main/template/index.t.js) from our boilerplate.\n\nFor public plugins:\n\n1. Use the guide in [PostCSS plugin boilerplate](https://github.com/postcss/postcss-plugin-boilerplate/) to create a plugin directory.\n2. Create a repository on GitHub or GitLab.\n3. Publish your code there.\n\n```code js\nmodule.exports = (opts = {}) => {\n  // Plugin creator to check options or prepare shared state\n  return {\n    postcssPlugin: 'PLUGIN NAME'\n    // Plugin listeners\n  }\n}\nmodule.exports.postcss = true\n```\n\n## Step 3: Find nodes\n\nMost of the PostCSS plugins do two things:\n\n1. Find something in CSS (for instance, `will-change` property).\n2. Change found elements (for instance, insert `transform: translateZ(0)` before `will-change` as a polyfill for old browsers).\n\nPostCSS parses CSS to the tree of nodes (we call it AST). This tree may content:\n\n- [`Root`](https://postcss.org/api/#root): node of the top of the tree, which represent CSS file.\n- [`AtRule`](https://postcss.org/api/#atrule): statements begin with `@` like `@charset \"UTF-8\"` or `@media (screen) {}`.\n- [`Rule`](https://postcss.org/api/#rule): selector with declaration inside. For instance `input, button {}`.\n- [`Declaration`](https://postcss.org/api/#declaration): key-value pair like `color: black`;\n- [`Comment`](https://postcss.org/api/#comment): stand-alone comment. Comments inside selectors, at-rule parameters and values are stored in node’s `raws` property.\n\nYou can use [AST Explorer](https://astexplorer.net/#/2uBU1BLuJ1) to learn how PostCSS convert different CSS to AST.\n\nYou can find all nodes with specific types by adding method to plugin object:\n\n```code js\nmodule.exports = (opts = {}) => {\n  return {\n    postcssPlugin: 'PLUGIN NAME',\n    Once (root) {\n      // Calls once per file, since every file has single Root\n    },\n    Declaration (decl) {\n      // All declaration nodes\n    }\n  }\n}\nmodule.exports.postcss = true\n```\n\nHere is the full list of [plugin’s events](https://postcss.org/api/#plugin).\n\nIf you need declaration or at-rule with specific names, you can use quick search:\n\n```code js\n    Declaration: {\n      color: decl => {\n        // All `color` declarations\n      }\n      '*': decl => {\n        // All declarations\n      }\n    },\n    AtRule: {\n      media: atRule => {\n        // All @media at-rules\n      }\n    }\n```\n\nFor other cases, you can use regular expressions or specific parsers:\n\n- [Selector parser](https://github.com/postcss/postcss-selector-parser)\n- [Value parser](https://github.com/TrySound/postcss-value-parser)\n- [Dimension parser](https://github.com/jedmao/parse-css-dimension) for `number`, `length` and `percentage`.\n- [Media query parser](https://github.com/dryoma/postcss-media-query-parser)\n- [Font parser](https://github.com/jedmao/parse-css-font)\n- [Sides parser](https://github.com/jedmao/parse-css-sides) for `margin`, `padding` and `border` properties.\n\nOther tools to analyze AST:\n\n- [Property resolver](https://github.com/jedmao/postcss-resolve-prop)\n- [Function resolver](https://github.com/andyjansson/postcss-functions)\n- [Font helpers](https://github.com/jedmao/postcss-font-helpers)\n- [Margin helpers](https://github.com/jedmao/postcss-margin-helpers)\n\nDon’t forget that regular expression and parsers are heavy tasks. You can use `String#includes()` quick test before check node with heavy tool:\n\n```code js\nif (decl.value.includes('gradient(')) {\n  let value = valueParser(decl.value)\n  …\n}\n```\n\nThere two types or listeners: enter and exit. `Once`, `Root`, `AtRule`, and `Rule` will be called before processing children. `OnceExit`, `RootExit`, `AtRuleExit`, and `RuleExit` after processing all children inside node.\n\nYou may want to re-use some data between listeners. You can do with runtime-defined listeners:\n\n```code js\nmodule.exports = (opts = {}) => {\n  return {\n    postcssPlugin: 'vars-collector',\n    prepare (result) {\n      const variables = {}\n      return {\n        Declaration (node) {\n          if (node.variable) {\n            variables[node.prop] = node.value\n          }\n        },\n        OnceExit () {\n          console.log(variables)\n        }\n      }\n    }\n  }\n}\n```\n\n## Step 4: Change nodes\n\nWhen you find the right nodes, you will need to change them or to insert/delete other nodes around.\n\nPostCSS node has a DOM-like API to transform AST. Check out our [API docs](https://postcss.org/api/). Nodes has methods to travel around (like [`Node#next`](https://postcss.org/api/#node-next) or [`Node#parent`](https://postcss.org/api/#node-parent)), look to children (like [`Container#some`](https://postcss.org/api/#container-some)), remove a node or add a new node inside.\n\nPlugin’s methods will receive node creators in second argument:\n\n```code js\n    Declaration (node, { Rule }) {\n      let newRule = new Rule({ selector: 'a', source: node.source })\n      node.root().append(newRule)\n      newRule.append(node)\n    }\n```\n\nIf you added new nodes, it is important to copy [`Node#source`](https://postcss.org/api/#node-source) to generate correct source maps.\n\nPlugins will re-visit all nodes, which you changed or added. If you will change any children, plugin will re-visit parent as well. Only `Once` and `OnceExit` will not be called again.\n\n```code js\nconst plugin = () => {\n  return {\n    postcssPlugin: 'to-red',\n    Rule (rule) {\n      console.log(rule.toString())\n    },\n    Declaration (decl) {\n      console.log(decl.toString())\n      decl.value = 'red'\n    }\n  }\n}\nplugin.postcss = true\n\nawait postcss([plugin]).process('a { color: black }', { from })\n// => a { color: black }\n// => color: black\n// => a { color: red }\n// => color: red\n```\n\n## Step 5: Fight with frustration\n\n> I hate programming\n>\n> I hate programming\n>\n> I hate programming\n>\n> It works!\n>\n> I love programming\n\nYou will have bugs and a minimum of 10 minutes in debugging even a simple plugin. You may found that simple origin idea will not work in real-world and you need to change everything.\n\nDon’t worry. Every bug is findable, and finding another solution may make your plugin even better.\n\nStart from writing tests. Plugin boilerplate has a test template in `index.test.js`. Call `npx jest` to test your plugin.\n\nUse Node.js debugger in your text editor or just `console.log` to debug the code.\n\nPostCSS community can help you since we are all experiencing the same problems. Don’t afraid to ask in [special channel](https://github.com/orgs/postcss/discussions).\n\n## Step 6: Make it public\n\nWhen your plugin is ready, call `npx clean-publish` in your repository. [`clean-publish`](https://github.com/shashkovdanil/clean-publish/) is a tool to remove development configs from the npm package. We added this tool to our plugin boilerplate.\n\nWrite a tweet about your new plugin (even if it is a small one) with [`@postcss`](https://twitter.com/postcss) mention. Or tell about your plugin in [our chat]. We will help you with marketing.\n\n[Add your new plugin](https://github.com/himynameisdave/postcss-plugins#submitting-a-new-plugin) to PostCSS plugin catalog.\n\nThis should give you a solid starting point!", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "overview", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I links in postcss?\n\nAssistant: To links in postcss, here's what you do:\nDocumentation:\n\n- [Plugin Boilerplate](https://github.com/postcss/postcss-plugin-boilerplate)\n- [Plugin Guidelines](https://github.com/postcss/postcss/blob/main/docs/guidelines/plugin.md)\n- [PostCSS API](https://postcss.org/api/)\n- [AST playground](https://astexplorer.net/#/2uBU1BLuJ1)\n\nSupport:\n\n- [Ask questions](https://github.com/orgs/postcss/discussions)\n- [PostCSS twitter](https://twitter.com/postcss) with latest updates..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 1: create an idea in postcss?\n\nAssistant: To step 1: create an idea in postcss, here's what you do:\nThere are many fields where writing new PostCSS plugin will help your work:\n\n- **Compatibility fixes:** if you always forget to add hack for browser compatibility, you can create PostCSS plugin to automatically insert this hack for you. [`postcss-flexbugs-fixes`](https://github.com/luisrudge/postcss-flexbugs-fixes) and [`postcss-100vh-fix`](https://github.com/postcss/postcss-100vh-fix) are good examples.\n- **Automate routine operations:** let’s computer do routine operations, free yourself for creative tasks. For instance, PostCSS with [RTLCSS](https://rtlcss.com/) can automatically convert a design to right-to-left languages (like Arabic or Hebrew) or with [postcss-dark-theme-class](https://github.com/postcss/postcss-dark-theme-class) can insert media queries for dark/light theme switcher.\n- **Preventing popular mistakes:** “if an error happened twice, it will happen again.” PostCSS plugin can check your source code for popular mistakes and save your time for unnecessary debugging. The best way to do it is to [write new Stylelint plugin](https://stylelint.io/developer-guide/plugins) (Stylelint uses PostCSS inside).\n- **Increasing code maintainability:** [CSS Modules](https://github.com/css-modules/css-modules) or [`postcss-autoreset`](https://github.com/maximkoretskiy/postcss-autoreset) are great example how PostCSS can increase code maintainability by isolation.\n- **Polyfills:** we already have a lot polyfills for CSS drafts in [`postcss-preset-env`](https://github.com/csstools/postcss-preset-env). If you find a new draft, you can add a new plugin and send it to this preset.\n- **New CSS syntax:** we recommend avoiding adding new syntax to CSS. If you want to add a new feature, it is always better to write a CSS draft proposal, send it to [CSSWG](https://github.com/w3c/csswg-drafts) and then implement polyfill. [`postcss-easing-gradients`](https://github.com/larsenwork/postcss-easing-gradients) with [this proposal](https://github.com/w3c/csswg-drafts/issues/1332) is a good example. However, there are a lot of cases when you can’t send a proposal. For instance, browser’s parser performance limited CSSWG nested syntax a lot and you may want to have non-official Sass-like syntax from [`postcss-nested`](https://github.com/postcss/postcss-nested)..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 2: create a project in postcss?\n\nAssistant: To step 2: create a project in postcss, here's what you do:\nThere are two ways to write a plugin:\n\n- Create a **private** plugin. Use this way only if the plugin is related to specific things of projects. For instance, you want to automate a specific task for your unique UI library.\n- Publish a **public** plugin. It is always the recommended way. Remember that private front-end systems, even in Google, often became unmaintained. On the other hand, many popular plugins were created during the work on a closed source project.\n\nFor private plugin:\n\n1. Create a new file in `postcss/` folder with the name of your plugin.\n2. Copy [plugin template](https://github.com/postcss/postcss-plugin-boilerplate/blob/main/template/index.t.js) from our boilerplate.\n\nFor public plugins:\n\n1. Use the guide in [PostCSS plugin boilerplate](https://github.com/postcss/postcss-plugin-boilerplate/) to create a plugin directory.\n2. Create a repository on GitHub or GitLab.\n3. Publish your code there.\n\n```code js\nmodule.exports = (opts = {}) => {\n  // Plugin creator to check options or prepare shared state\n  return {\n    postcssPlugin: 'PLUGIN NAME'\n    // Plugin listeners\n  }\n}\nmodule.exports.postcss = true\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 3: find nodes in postcss?\n\nAssistant: To step 3: find nodes in postcss, here's what you do:\nMost of the PostCSS plugins do two things:\n\n1. Find something in CSS (for instance, `will-change` property).\n2. Change found elements (for instance, insert `transform: translateZ(0)` before `will-change` as a polyfill for old browsers).\n\nPostCSS parses CSS to the tree of nodes (we call it AST). This tree may content:\n\n- [`Root`](https://postcss.org/api/#root): node of the top of the tree, which represent CSS file.\n- [`AtRule`](https://postcss.org/api/#atrule): statements begin with `@` like `@charset \"UTF-8\"` or `@media (screen) {}`.\n- [`Rule`](https://postcss.org/api/#rule): selector with declaration inside. For instance `input, button {}`.\n- [`Declaration`](https://postcss.org/api/#declaration): key-value pair like `color: black`;\n- [`Comment`](https://postcss.org/api/#comment): stand-alone comment. Comments inside selectors, at-rule parameters and values are stored in node’s `raws` property.\n\nYou can use [AST Explorer](https://astexplorer.net/#/2uBU1BLuJ1) to learn how PostCSS convert different CSS to AST.\n\nYou can find all nodes with specific types by adding method to plugin object:\n\n```code js\nmodule.exports = (opts = {}) => {\n  return {\n    postcssPlugin: 'PLUGIN NAME',\n    Once (root) {\n      // Calls once per file, since every file has single Root\n    },\n    Declaration (decl) {\n      // All declaration nodes\n    }\n  }\n}\nmodule.exports.postcss = true\n```\n\nHere is the full list of [plugin’s events](https://postcss.org/api/#plugin).\n\nIf you need declaration or at-rule with specific names, you can use quick search:\n\n```code js\n    Declaration: {\n      color: decl => {\n        // All `color` declarations\n      }\n      '*': decl => {\n        // All declarations\n      }\n    },\n    AtRule: {\n      media: atRule => {\n        // All @media at-rules\n      }\n    }\n```\n\nFor other cases, you can use regular expressions or specific parsers:\n\n- [Selector parser](https://github.com/postcss/postcss-selector-parser)\n- [Value parser](https://github.com/TrySound/postcss-value-parser)\n- [Dimension parser](https://github.com/jedmao/parse-css-dimension) for `number`, `length` and `percentage`.\n- [Media query parser](https://github.com/dryoma/postcss-media-query-parser)\n- [Font parser](https://github.com/jedmao/parse-css-font)\n- [Sides parser](https://github.com/jedmao/parse-css-sides) for `margin`, `padding` and `border` properties.\n\nOther tools to analyze AST:\n\n- [Property resolver](https://github.com/jedmao/postcss-resolve-prop)\n- [Function resolver](https://github.com/andyjansson/postcss-functions)\n- [Font helpers](https://github.com/jedmao/postcss-font-helpers)\n- [Margin helpers](https://github.com/jedmao/postcss-margin-helpers)\n\nDon’t forget that regular expression and parsers are heavy tasks. You can use `String#includes()` quick test before check node with heavy tool:\n\n```code js\nif (decl.value.includes('gradient(')) {\n  let value = valueParser(decl.value)\n  …\n}\n```\n\nThere two types or listeners: enter and exit. `Once`, `Root`, `AtRule`, and `Rule` will be called before processing children. `OnceExit`, `RootExit`, `AtRuleExit`, and `RuleExit` after processing all children inside node.\n\nYou may want to re-use some data between listeners. You can do with runtime-defined listeners:\n\n```code js\nmodule.exports = (opts = {}) => {\n  return {\n    postcssPlugin: 'vars-collector',\n    prepare (result) {\n      const variables = {}\n      return {\n        Declaration (node) {\n          if (node.variable) {\n            variables[node.prop] = node.value\n          }\n        },\n        OnceExit () {\n          console.log(variables)\n        }\n      }\n    }\n  }\n}\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 4: change nodes in postcss?\n\nAssistant: To step 4: change nodes in postcss, here's what you do:\nWhen you find the right nodes, you will need to change them or to insert/delete other nodes around.\n\nPostCSS node has a DOM-like API to transform AST. Check out our [API docs](https://postcss.org/api/). Nodes has methods to travel around (like [`Node#next`](https://postcss.org/api/#node-next) or [`Node#parent`](https://postcss.org/api/#node-parent)), look to children (like [`Container#some`](https://postcss.org/api/#container-some)), remove a node or add a new node inside.\n\nPlugin’s methods will receive node creators in second argument:\n\n```code js\n    Declaration (node, { Rule }) {\n      let newRule = new Rule({ selector: 'a', source: node.source })\n      node.root().append(newRule)\n      newRule.append(node)\n    }\n```\n\nIf you added new nodes, it is important to copy [`Node#source`](https://postcss.org/api/#node-source) to generate correct source maps.\n\nPlugins will re-visit all nodes, which you changed or added. If you will change any children, plugin will re-visit parent as well. Only `Once` and `OnceExit` will not be called again.\n\n```code js\nconst plugin = () => {\n  return {\n    postcssPlugin: 'to-red',\n    Rule (rule) {\n      console.log(rule.toString())\n    },\n    Declaration (decl) {\n      console.log(decl.toString())\n      decl.value = 'red'\n    }\n  }\n}\nplugin.postcss = true\n\nawait postcss([plugin]).process('a { color: black }', { from })\n// => a { color: black }\n// => color: black\n// => a { color: red }\n// => color: red\n```.\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 5: fight with frustration in postcss?\n\nAssistant: To step 5: fight with frustration in postcss, here's what you do:\n> I hate programming\n>\n> I hate programming\n>\n> I hate programming\n>\n> It works!\n>\n> I love programming\n\nYou will have bugs and a minimum of 10 minutes in debugging even a simple plugin. You may found that simple origin idea will not work in real-world and you need to change everything.\n\nDon’t worry. Every bug is findable, and finding another solution may make your plugin even better.\n\nStart from writing tests. Plugin boilerplate has a test template in `index.test.js`. Call `npx jest` to test your plugin.\n\nUse Node.js debugger in your text editor or just `console.log` to debug the code.\n\nPostCSS community can help you since we are all experiencing the same problems. Don’t afraid to ask in [special channel](https://github.com/orgs/postcss/discussions)..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: How do I step 6: make it public in postcss?\n\nAssistant: To step 6: make it public in postcss, here's what you do:\nWhen your plugin is ready, call `npx clean-publish` in your repository. [`clean-publish`](https://github.com/shashkovdanil/clean-publish/) is a tool to remove development configs from the npm package. We added this tool to our plugin boilerplate.\n\nWrite a tweet about your new plugin (even if it is a small one) with [`@postcss`](https://twitter.com/postcss) mention. Or tell about your plugin in [our chat]. We will help you with marketing.\n\n[Add your new plugin](https://github.com/himynameisdave/postcss-plugins#submitting-a-new-plugin) to PostCSS plugin catalog..\nPretty straightforward, right?", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "section_detail", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: Can you give me some code examples for Writing a PostCSS Plugin in postcss?\n\nAssistant: Absolutely! Here are some practical examples to help you out:\n\n**Plugin Template**:\n\n```yaml\n```code js\nmodule.exports = (opts = {}) => {\n  // Plugin creator to check options or prepare shared state\n  return {\n    postcssPlugin: 'PLUGIN NAME'\n    // Plugin listeners\n  }\n}\nmodule.exports.postcss = true\n```\n```\n\nThis snippet shows you how to plugin template, which is an important aspect of writing a postcss plugin.\n\n**Finding Nodes Example**:\n\n```yaml\n```code js\nmodule.exports = (opts = {}) => {\n  return {\n    postcssPlugin: 'PLUGIN NAME',\n    Once (root) {\n      // Calls once per file, since every file has single Root\n    },\n    Declaration (decl) {\n      // All declaration nodes\n    }\n  }\n}\nmodule.exports.postcss = true\n```\n```\n\nThis snippet shows you how to finding nodes example, which is an important aspect of writing a postcss plugin.\n\n**Changing Nodes Example**:\n\n```yaml\n```code js\nconst plugin = () => {\n  return {\n    postcssPlugin: 'to-red',\n    Rule (rule) {\n      console.log(rule.toString())\n    },\n    Declaration (decl) {\n      console.log(decl.toString())\n      decl.value = 'red'\n    }\n  }\n}\nplugin.postcss = true\n\nawait postcss([plugin]).process('a { color: black }', { from })\n// => a { color: black }\n// => color: black\n// => a { color: red }\n// => color: red\n```\n```\n\nThis snippet shows you how to changing nodes example, which is an important aspect of writing a postcss plugin.\n\n**Preventing Infinite Loops Example**:\n\n```yaml\n```code js\n    Declaration: {\n      'will-change': decl => {\n        if (decl.parent.some(decl => decl.prop === 'transform')) {\n          decl.cloneBefore({ prop: 'transform', value: 'translate3d(0, 0, 0)' })\n        }\n      }\n    }\n```\n```\n\nThis snippet shows you how to preventing infinite loops example, which is an important aspect of writing a postcss plugin.\n\n**Using Symbols Example**:\n\n```yaml\n```code js\nconst processed = Symbol('processed')\n\nconst plugin = () => {\n  return {\n    postcssPlugin: 'example',\n    Rule (rule) {\n      if (!rule[processed]) {\n        process(rule)\n        rule[processed] = true\n      }\n    }\n  }\n}\nplugin.postcss = true\n```\n```\n\nThis snippet shows you how to using symbols example, which is an important aspect of writing a postcss plugin.\n\n**Adding Warnings Example**:\n\n```yaml\n```code js\n    Declaration: {\n      bad: (decl, { result }) {\n        decl.warn(result, 'Deprecated property bad')\n      }\n    }\n```\n```\n\nThis snippet shows you how to adding warnings example, which is an important aspect of writing a postcss plugin.\n\n**Adding Dependency Messages Example**:\n\n```yaml\n```code js\n    AtRule: {\n      import: (atRule, { result }) {\n        const importedFile = parseImport(atRule)\n        result.messages.push({\n          type: 'dependency',\n          plugin: 'postcss-import',\n          file: importedFile,\n          parent: result.opts.from\n        })\n      }\n    }\n```\n```\n\nThis snippet shows you how to adding dependency messages example, which is an important aspect of writing a postcss plugin.\n\n**Handling Syntax Errors Example**:\n\n```yaml\n```code js\nif (!variables[name]) {\n  throw decl.error(`Unknown variable ${name}`, { word: name })\n}\n```\n```\n\nThis snippet shows you how to handling syntax errors example, which is an important aspect of writing a postcss plugin.\n\n", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "code_examples", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
{"text": "System: You are a helpful postcss expert.\n\nUser: What are some tips for using Writing a PostCSS Plugin in postcss effectively?\n\nAssistant: Great question! Here are some tips to keep in mind:\n\nStart from writing tests. Plugin boilerplate has a test template in index.test.js. Call npx jest to test your plugin.\n\nUse Node.js debugger in your text editor or just console.log to debug the code.\n\nPostCSS community can help you since we are all experiencing the same problems. Don’t afraid to ask in special channel.\n\nStick to these, and you'll avoid a lot of headaches!", "metadata": {"source_url": "https://postcss.org/docs/writing-a-postcss-plugin", "title": "Writing a PostCSS Plugin", "description": "This documentation provides a comprehensive guide on how to create a PostCSS plugin, including steps for ideation, project setup, node manipulation, debugging, and publicizing the plugin.", "has_code_examples": true, "has_best_practices": true, "section_count": 7, "timestamp": "2025-02-28 22:37:01", "type": "best_practices", "page_metadata": {"description": "Transform CSS with the power of JavaScript. Auto-prefixing, future CSS syntaxes, modules, linting and more are possible with hundreds of PostCSS plugins.", "og:type": "article", "ogImage": "./base/og.jpg", "language": "en", "viewport": "width=device-width, initial-scale=1", "twitter:card": "summary", "og:url": "http://postcss.org/", "og:image": "./base/og.jpg", "ogUrl": "http://postcss.org/", "title": "Writing a PostCSS Plugin", "favicon": "https://postcss.org/docs/assets/favicon-DbGqNhKa.ico", "twitter:site": "@postcss", "twitter:creator": "@postcss", "scrapeId": "39e7068c-6ffe-4948-a994-87c2c5bc69f0", "sourceURL": "https://postcss.org/docs/writing-a-postcss-plugin", "url": "https://postcss.org/docs/writing-a-postcss-plugin", "statusCode": 200}}}
